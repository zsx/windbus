Index: cmake/CMakeLists.txt
===================================================================
--- cmake/CMakeLists.txt	(revision 634)
+++ cmake/CMakeLists.txt	(working copy)
@@ -351,13 +351,35 @@
 	set (EXT ".exe")
 endif(WIN32)
 
-set(TEST_SERVICE_DIR          ${CMAKE_BINARY_DIR}/test/data/valid-service-files     CACHE STRING "Full path to test file test/data/valid-service-files in builddir")
-set(TEST_SERVICE_BINARY       ${CMAKE_BINARY_DIR}/bin/release/test-service${EXT}       CACHE STRING "Full path to test file test/test-service in builddir")
-set(TEST_SHELL_SERVICE_BINARY ${CMAKE_BINARY_DIR}/bin/release/test-shell-service${EXT} CACHE STRING "Full path to test file test/test-shell-service in builddir")    
-set(TEST_EXIT_BINARY          ${CMAKE_BINARY_DIR}/bin/release/test-exit${EXT}          CACHE STRING "Full path to test file test/test-exit in builddir")
-set(TEST_SEGFAULT_BINARY      ${CMAKE_BINARY_DIR}/bin/release/test-segfault${EXT}      CACHE STRING "Full path to test file test/test-segfault in builddir")
-set(TEST_SLEEP_FOREVER_BINARY ${CMAKE_BINARY_DIR}/bin/release/test-sleep-forever${EXT} CACHE STRING "Full path to test file test/test-sleep-forever in builddir")
+if (MSVC_IDE)
+	if (test_debug)
+		set(test_debug TRUE CACHE TYPE STRING FORCE)
+		set(IDE_BIN Debug/ )
+		message(STATUS)
+		message(STATUS "Using Visual Studio: test programs will only work with the 'Debug' configuration!")
+		message(STATUS "To run the tests with the 'Release' configuration use -Dtest_debug=0")
+		message(STATUS "Add '..\\..\\test\\data' to the command line option of the test programs")
+		message(STATUS)
+	else (test_debug)
+		set(test_debug FALSE CACHE TYPE STRING FORCE)
+		set(IDE_BIN Release/)
+		message(STATUS)
+		message(STATUS "Using Visual Studio: test programs will only work with the 'Release' configuration!")
+		message(STATUS "To run the tests with the 'Debug' configuration use -Dtest_debug=1")
+		message(STATUS "Add '..\\..\\test\\data' to the command line option of the test programs")
+		message(STATUS)
+	endif (test_debug)
+	set (TEST_PATH_FORCE FORCE)
+	FILE(REMOVE ${CMAKE_BINARY_DIR}/data/dbus-1/services)
+endif (MSVC_IDE)
 
+set(TEST_SERVICE_DIR          ${CMAKE_BINARY_DIR}/test/data/valid-service-files     CACHE STRING "Full path to test file test/data/valid-service-files in builddir" )
+set(TEST_SERVICE_BINARY       ${CMAKE_BINARY_DIR}/bin/${IDE_BIN}test-service${EXT}       CACHE STRING "Full path to test file test/test-service in builddir" ${TEST_PATH_FORCE})
+set(TEST_SHELL_SERVICE_BINARY ${CMAKE_BINARY_DIR}/bin/${IDE_BIN}test-shell-service${EXT} CACHE STRING "Full path to test file test/test-shell-service in builddir" ${TEST_PATH_FORCE})
+set(TEST_EXIT_BINARY          ${CMAKE_BINARY_DIR}/bin/${IDE_BIN}test-exit${EXT}          CACHE STRING "Full path to test file test/test-exit in builddir" ${TEST_PATH_FORCE})
+set(TEST_SEGFAULT_BINARY      ${CMAKE_BINARY_DIR}/bin/${IDE_BIN}test-segfault${EXT}      CACHE STRING "Full path to test file test/test-segfault in builddir" ${TEST_PATH_FORCE})
+set(TEST_SLEEP_FOREVER_BINARY ${CMAKE_BINARY_DIR}/bin/${IDE_BIN}test-sleep-forever${EXT} CACHE STRING "Full path to test file test/test-sleep-forever in builddir" ${TEST_PATH_FORCE})
+
 #### Find socket directories
 if (NOT WIN32)
     if (NOT $ENV{TMPDIR} STREQUAL "")
Index: dbus-win.patch
===================================================================
--- dbus-win.patch	(revision 634)
+++ dbus-win.patch	(working copy)
@@ -1,10 +1,110 @@
+Index: dbus/dbus-threads.c
+===================================================================
+--- dbus/dbus-threads.c	(revision 634)
++++ dbus/dbus-threads.c	(working copy)
+@@ -810,7 +810,11 @@
+ dbus_bool_t
+ _dbus_threads_init_debug (void)
+ {
++#if defined(DBUS_WIN)
++  return _dbus_threads_init_platform_specific();
++#else
+   return dbus_threads_init (&fake_functions);
++#endif
+ }
+ 
+ #endif /* DBUS_BUILD_TESTS */
+Index: dbus/dbus-watch.c
+===================================================================
+--- dbus/dbus-watch.c	(revision 634)
++++ dbus/dbus-watch.c	(working copy)
+@@ -513,11 +513,7 @@
+    * which it has, and the transport should provide the
+    * appropriate watch type)
+    */
+-#ifdef DBUS_UNIX
+   return watch->fd;
+-#else
+-  return -1;
+-#endif
+ }
+ 
+ /**
+Index: dbus/dbus-mainloop.c
+===================================================================
+--- dbus/dbus-mainloop.c	(revision 634)
++++ dbus/dbus-mainloop.c	(working copy)
+@@ -883,6 +883,8 @@
+   
+   loop->depth -= 1;
+ 
++ _dbus_daemon_release ();
++
+   _dbus_verbose ("Quit main loop, depth %d -> %d\n",
+                  loop->depth + 1, loop->depth);
+ }
+Index: dbus/dbus-bus.c
+===================================================================
+--- dbus/dbus-bus.c	(revision 634)
++++ dbus/dbus-bus.c	(working copy)
+@@ -350,8 +350,10 @@
+ {
+   int i;
+   
++#if !defined(DBUS_WIN) && !defined(DBUS_WINCE)
++   // qt example pong says "QMutex::lock: Deadlock detected"
+   _DBUS_LOCK (bus);
+-
++#endif
+   /* We are expecting to have the connection saved in only one of these
+    * slots, but someone could in a pathological case set system and session
+    * bus to the same bus or something. Or set one of them to the starter
+@@ -366,7 +368,9 @@
+         }
+     }
+ 
++#if !defined(DBUS_WIN) && !defined(DBUS_WINCE)
+   _DBUS_UNLOCK (bus);
++#endif
+ }
+ 
+ static DBusConnection *
+Index: dbus/dbus-sysdeps-util.c
+===================================================================
+--- dbus/dbus-sysdeps-util.c	(revision 634)
++++ dbus/dbus-sysdeps-util.c	(working copy)
+@@ -141,6 +141,7 @@
+       exit (1);
+     }
+ 
++#ifndef DBUS_WIN_FIXME
+   _dbus_string_init_const (&str, "0xff");
+   if (!_dbus_string_parse_double (&str,
+ 				  0, &val, &pos))
+@@ -158,6 +159,7 @@
+       _dbus_warn ("_dbus_string_parse_double of \"0xff\" returned wrong position %d", pos);
+       exit (1);
+     }
++#endif
+ 
+ #ifdef DBUS_WIN
+   check_path_absolute ("c:/", TRUE);
+Index: dbus/dbus-sysdeps.h
+===================================================================
+--- dbus/dbus-sysdeps.h	(revision 634)
++++ dbus/dbus-sysdeps.h	(working copy)
+@@ -124,6 +124,7 @@
+  * 
+  */
+ 
++void        _dbus_daemon_release   (void);
+ dbus_bool_t _dbus_open_tcp_socket  (int              *fd,
+                                     DBusError        *error);
+ dbus_bool_t _dbus_close_socket     (int               fd,
 Index: bus/dispatch.c
 ===================================================================
-RCS file: /cvs/dbus/dbus/bus/dispatch.c,v
-retrieving revision 1.79
-diff -u -r1.79 dispatch.c
---- bus/dispatch.c	8 Mar 2007 08:30:17 -0000	1.79
-+++ bus/dispatch.c	8 Mar 2007 20:25:42 -0000
+--- bus/dispatch.c	(revision 634)
++++ bus/dispatch.c	(working copy)
 @@ -428,6 +428,11 @@
      }
  }
@@ -37,7 +137,7 @@
    _dbus_verbose (" ... done spinning to auth connection %p\n", connection);
  }
  
-@@ -2699,9 +2717,12 @@
+@@ -2714,9 +2732,12 @@
          }
        else
          {
@@ -50,7 +150,7 @@
          }
      }
    else
-@@ -4064,29 +4085,36 @@
+@@ -4079,8 +4100,12 @@
        _dbus_assert_not_reached ("initial connection setup failed");
      }
    
@@ -63,12 +163,7 @@
    
    check2_try_iterations (context, foo, "nonexistent_service_no_auto_start",
                           check_nonexistent_service_no_auto_start);
- 
--#ifdef DBUS_WIN_FIXME
-+#ifdef DBUS_WIN_FIXME
-   _dbus_warn("TODO: dispatch.c segfault_service_no_auto_start test\n");
- #else
-   check2_try_iterations (context, foo, "segfault_service_no_auto_start",
+@@ -4092,12 +4117,15 @@
                           check_segfault_service_no_auto_start);
  #endif
    
@@ -85,12 +180,7 @@
  
  #ifdef DBUS_WIN_FIXME    
    _dbus_warn("TODO: dispatch.c segfault_service_auto_start test\n");
--#else
-+#else
-   check2_try_iterations (context, foo, "segfault_service_auto_start",
-                          check_segfault_service_auto_start);
- #endif
-@@ -4106,8 +4134,12 @@
+@@ -4121,8 +4149,12 @@
    if (!check_existent_service_auto_start (context, foo))
      _dbus_assert_not_reached ("existent service auto start failed");
  
@@ -103,7 +193,7 @@
  
    _dbus_verbose ("Disconnecting foo, bar, and baz\n");
  
-@@ -4158,8 +4190,12 @@
+@@ -4173,8 +4205,12 @@
        _dbus_assert_not_reached ("initial connection setup failed");
      }
    
@@ -116,125 +206,3 @@
  
    kill_client_connection_unchecked (foo);
  
-Index: dbus/dbus-bus.c
-===================================================================
-RCS file: /cvs/dbus/dbus/dbus/dbus-bus.c,v
-retrieving revision 1.64
-diff -u -r1.64 dbus-bus.c
---- dbus/dbus-bus.c	28 Oct 2006 01:41:37 -0000	1.64
-+++ dbus/dbus-bus.c	8 Mar 2007 20:25:40 -0000
-@@ -350,8 +350,10 @@
- {
-   int i;
-   
-+#if !defined(DBUS_WIN) && !defined(DBUS_WINCE)
-+   // qt example pong says "QMutex::lock: Deadlock detected"
-   _DBUS_LOCK (bus);
--
-+#endif
-   /* We are expecting to have the connection saved in only one of these
-    * slots, but someone could in a pathological case set system and session
-    * bus to the same bus or something. Or set one of them to the starter
-@@ -366,7 +368,9 @@
-         }
-     }
- 
-+#if !defined(DBUS_WIN) && !defined(DBUS_WINCE)
-   _DBUS_UNLOCK (bus);
-+#endif
- }
- 
- static DBusConnection *
-Index: dbus/dbus-mainloop.c
-===================================================================
-RCS file: /cvs/dbus/dbus/dbus/dbus-mainloop.c,v
-retrieving revision 1.19
-diff -u -r1.19 dbus-mainloop.c
---- dbus/dbus-mainloop.c	20 Oct 2006 03:04:59 -0000	1.19
-+++ dbus/dbus-mainloop.c	8 Mar 2007 20:25:40 -0000
-@@ -883,6 +883,8 @@
-   
-   loop->depth -= 1;
- 
-+ _dbus_daemon_release ();
-+
-   _dbus_verbose ("Quit main loop, depth %d -> %d\n",
-                  loop->depth + 1, loop->depth);
- }
-Index: dbus/dbus-sysdeps-util.c
-===================================================================
-RCS file: /cvs/dbus/dbus/dbus/dbus-sysdeps-util.c,v
-retrieving revision 1.10
-diff -u -r1.10 dbus-sysdeps-util.c
---- dbus/dbus-sysdeps-util.c	13 Dec 2006 01:18:07 -0000	1.10
-+++ dbus/dbus-sysdeps-util.c	8 Mar 2007 20:25:41 -0000
-@@ -141,6 +141,7 @@
-       exit (1);
-     }
- 
-+#ifndef DBUS_WIN_FIXME
-   _dbus_string_init_const (&str, "0xff");
-   if (!_dbus_string_parse_double (&str,
- 				  0, &val, &pos))
-@@ -158,6 +159,8 @@
-       _dbus_warn ("_dbus_string_parse_double of \"0xff\" returned wrong position %d", pos);
-       exit (1);
-     }
-+#endif
-+
- #ifdef DBUS_WIN
-   check_path_absolute ("c:/", TRUE);
-   check_path_absolute ("c:/foo", TRUE);
-Index: dbus/dbus-sysdeps.h
-===================================================================
-RCS file: /cvs/dbus/dbus/dbus/dbus-sysdeps.h,v
-retrieving revision 1.69
-diff -u -r1.69 dbus-sysdeps.h
---- dbus/dbus-sysdeps.h	8 Mar 2007 20:25:15 -0000	1.69
-+++ dbus/dbus-sysdeps.h	8 Mar 2007 20:25:41 -0000
-@@ -119,6 +119,7 @@
-  * 
-  */
- 
-+void        _dbus_daemon_release   (void);
- dbus_bool_t _dbus_open_tcp_socket  (int              *fd,
-                                     DBusError        *error);
- dbus_bool_t _dbus_close_socket     (int               fd,
-Index: dbus/dbus-threads.c
-===================================================================
-RCS file: /cvs/dbus/dbus/dbus/dbus-threads.c,v
-retrieving revision 1.36
-diff -u -r1.36 dbus-threads.c
---- dbus/dbus-threads.c	28 Oct 2006 01:41:37 -0000	1.36
-+++ dbus/dbus-threads.c	8 Mar 2007 20:25:41 -0000
-@@ -810,7 +810,11 @@
- dbus_bool_t
- _dbus_threads_init_debug (void)
- {
-+#if defined(DBUS_WIN)
-+  return _dbus_threads_init_platform_specific();
-+#else
-   return dbus_threads_init (&fake_functions);
-+#endif
- }
- 
- #endif /* DBUS_BUILD_TESTS */
-Index: dbus/dbus-watch.c
-===================================================================
-RCS file: /cvs/dbus/dbus/dbus/dbus-watch.c,v
-retrieving revision 1.25
-diff -u -r1.25 dbus-watch.c
---- dbus/dbus-watch.c	21 Jun 2007 21:28:59 -0000	1.25
-+++ dbus/dbus-watch.c	22 Jun 2007 09:55:03 -0000
-@@ -513,11 +513,7 @@
-    * which it has, and the transport should provide the
-    * appropriate watch type)
-    */
--#ifdef DBUS_UNIX
-   return watch->fd;
--#else
--  return -1;
--#endif
- }
- 
- /**
Index: dbus/dbus-threads.c
===================================================================
--- dbus/dbus-threads.c	(revision 634)
+++ dbus/dbus-threads.c	(working copy)
@@ -810,7 +810,11 @@
 dbus_bool_t
 _dbus_threads_init_debug (void)
 {
+#if defined(DBUS_WIN)
+  return _dbus_threads_init_platform_specific();
+#else
   return dbus_threads_init (&fake_functions);
+#endif
 }
 
 #endif /* DBUS_BUILD_TESTS */
Index: dbus/dbus-watch.c
===================================================================
--- dbus/dbus-watch.c	(revision 634)
+++ dbus/dbus-watch.c	(working copy)
@@ -513,11 +513,7 @@
    * which it has, and the transport should provide the
    * appropriate watch type)
    */
-#ifdef DBUS_UNIX
   return watch->fd;
-#else
-  return -1;
-#endif
 }
 
 /**
Index: dbus/dbus-mainloop.c
===================================================================
--- dbus/dbus-mainloop.c	(revision 634)
+++ dbus/dbus-mainloop.c	(working copy)
@@ -883,6 +883,8 @@
   
   loop->depth -= 1;
 
+ _dbus_daemon_release ();
+
   _dbus_verbose ("Quit main loop, depth %d -> %d\n",
                  loop->depth + 1, loop->depth);
 }
Index: dbus/dbus-bus.c
===================================================================
--- dbus/dbus-bus.c	(revision 634)
+++ dbus/dbus-bus.c	(working copy)
@@ -350,8 +350,10 @@
 {
   int i;
   
+#if !defined(DBUS_WIN) && !defined(DBUS_WINCE)
+   // qt example pong says "QMutex::lock: Deadlock detected"
   _DBUS_LOCK (bus);
-
+#endif
   /* We are expecting to have the connection saved in only one of these
    * slots, but someone could in a pathological case set system and session
    * bus to the same bus or something. Or set one of them to the starter
@@ -366,7 +368,9 @@
         }
     }
 
+#if !defined(DBUS_WIN) && !defined(DBUS_WINCE)
   _DBUS_UNLOCK (bus);
+#endif
 }
 
 static DBusConnection *
Index: dbus/dbus-sysdeps-util.c
===================================================================
--- dbus/dbus-sysdeps-util.c	(revision 634)
+++ dbus/dbus-sysdeps-util.c	(working copy)
@@ -141,6 +141,7 @@
       exit (1);
     }
 
+#ifndef DBUS_WIN_FIXME
   _dbus_string_init_const (&str, "0xff");
   if (!_dbus_string_parse_double (&str,
 				  0, &val, &pos))
@@ -158,6 +159,7 @@
       _dbus_warn ("_dbus_string_parse_double of \"0xff\" returned wrong position %d", pos);
       exit (1);
     }
+#endif
 
 #ifdef DBUS_WIN
   check_path_absolute ("c:/", TRUE);
Index: dbus/dbus-sysdeps.h
===================================================================
--- dbus/dbus-sysdeps.h	(revision 634)
+++ dbus/dbus-sysdeps.h	(working copy)
@@ -124,6 +124,7 @@
  * 
  */
 
+void        _dbus_daemon_release   (void);
 dbus_bool_t _dbus_open_tcp_socket  (int              *fd,
                                     DBusError        *error);
 dbus_bool_t _dbus_close_socket     (int               fd,
Index: bus/dispatch.c
===================================================================
--- bus/dispatch.c	(revision 634)
+++ bus/dispatch.c	(working copy)
@@ -428,6 +428,11 @@
     }
 }
 
+#ifdef DBUS_WIN
+#include <tools/dbus-print-message.h>
+#include <tools/dbus-print-message.c>
+#endif
+
 static void
 spin_connection_until_authenticated (BusContext     *context,
                                      DBusConnection *connection)
@@ -439,6 +444,19 @@
       bus_test_run_bus_loop (context, FALSE);
       bus_test_run_clients_loop (FALSE);
     }
+#ifdef DBUS_WIN
+  if ( dbus_connection_get_dispatch_status(connection) != DBUS_DISPATCH_COMPLETE)
+    {
+      DBusMessage *message;
+	  message = dbus_connection_pop_message (connection);
+	  printf ("spin_connection_until_authenticated failed,\n");
+	  printf ("because of a non dispatched message:\n");
+	  print_message(message, FALSE);
+	  printf ("\n");	 
+	  _dbus_assert_not_reached ("spin_connection_until_authenticated failed\n ");
+    }
+#endif
+
   _dbus_verbose (" ... done spinning to auth connection %p\n", connection);
 }
 
@@ -2714,9 +2732,12 @@
         }
       else
         {
+/* no DBUS_ERROR_NO_MEMORY on windows (no have_fork_errnum)*/
+#ifndef DBUS_WIN_FIXME
           warn_unexpected (connection, message, "not this error");
 
           goto out;
+#endif
         }
     }
   else
@@ -4064,11 +4085,14 @@
   if (!check_add_match_all (context, baz))
     _dbus_assert_not_reached ("AddMatch message failed");
 
+#ifndef DBUS_WIN
+  // must fail on Windows?
   if (!check_get_connection_unix_user (context, baz))
     _dbus_assert_not_reached ("GetConnectionUnixUser message failed");
 
   if (!check_get_connection_unix_process_id (context, baz))
     _dbus_assert_not_reached ("GetConnectionUnixProcessID message failed");
+#endif
 
   if (!check_list_services (context, baz))
     _dbus_assert_not_reached ("ListActivatableNames message failed");
@@ -4079,8 +4103,12 @@
       _dbus_assert_not_reached ("initial connection setup failed");
     }
   
+#ifdef DBUS_WIN_FIXME
+  _dbus_warn("TODO: dispatch.c create_and_hello test\n");
+#else
   check1_try_iterations (context, "create_and_hello",
                          check_hello_connection);
+#endif
   
   check2_try_iterations (context, foo, "nonexistent_service_no_auto_start",
                          check_nonexistent_service_no_auto_start);
@@ -4092,12 +4120,15 @@
                          check_segfault_service_no_auto_start);
 #endif
   
+#ifdef DBUS_WIN_FIXME
+  _dbus_warn("TODO: dispatch.c existent_service_no_auto_start\n");
+#else
   check2_try_iterations (context, foo, "existent_service_no_auto_start",
                          check_existent_service_no_auto_start);
   
   check2_try_iterations (context, foo, "nonexistent_service_auto_start",
                          check_nonexistent_service_auto_start);
-  
+#endif
 
 #ifdef DBUS_WIN_FIXME    
   _dbus_warn("TODO: dispatch.c segfault_service_auto_start test\n");
@@ -4121,8 +4152,12 @@
   if (!check_existent_service_auto_start (context, foo))
     _dbus_assert_not_reached ("existent service auto start failed");
 
+#ifdef DBUS_WIN_FIXME  
+  _dbus_warn("TODO: dispatch.c check_shell_service_success_auto_start test\n");
+#else
   if (!check_shell_service_success_auto_start (context, foo))
     _dbus_assert_not_reached ("shell success service auto start failed");
+#endif
 
   _dbus_verbose ("Disconnecting foo, bar, and baz\n");
 
@@ -4173,8 +4208,12 @@
       _dbus_assert_not_reached ("initial connection setup failed");
     }
   
+#ifdef DBUS_WIN_FIXME  
+  _dbus_warn("TODO: dispatch.c: create_and_hello_sha1 test\n");
+#else
   check1_try_iterations (context, "create_and_hello_sha1",
                          check_hello_connection);
+#endif
 
   kill_client_connection_unchecked (foo);
 

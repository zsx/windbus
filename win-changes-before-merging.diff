? CMakeLists.txt
? ConfigureChecks.cmake
? README-WIN32.txt
? cmake
? config.h.cmake
? patches
? bus/CMakeLists.txt
? bus/service-win32.c
? bus/service.cmake
? bus/session.conf.cmake
? bus/system.conf.cmake
? dbus/CMakeLists.txt
? dbus/dbus-arch-deps.h.cmake
? dbus/dbus-example.c
? dbus/dbus-platform-deps.h
? dbus/dbus-sockets.h
? dbus/dbus-spawn-win32.c
? test/CMakeLists.txt
? test/org.freedektop.DBus.TestSuiteEchoService.service.cmake
? tools/CMakeLists.txt
Index: autogen.sh
===================================================================
RCS file: /cvs/dbus/dbus/autogen.sh,v
retrieving revision 1.6
diff -u -b -B -r1.6 autogen.sh
--- autogen.sh	31 Jan 2005 02:55:12 -0000	1.6
+++ autogen.sh	22 Jun 2006 11:39:08 -0000
@@ -31,8 +31,8 @@
 
 ($AUTOMAKE --version) < /dev/null > /dev/null 2>&1 || {
 	echo
-	echo "You must have automake installed to compile $PROJECT."
-	echo "Get ftp://ftp.cygnus.com/pub/home/tromey/automake-1.2d.tar.gz"
+	echo "You must have $AUTOMAKE installed to compile $PROJECT."
+	echo "Install the $AUTOMAKE package from ftp.gnu.org or a mirror."
 	echo "(or a newer version if it is available)"
 	DIE=1
 }
Index: configure.in
===================================================================
RCS file: /cvs/dbus/dbus/configure.in,v
retrieving revision 1.154
diff -u -b -B -r1.154 configure.in
--- configure.in	9 Jun 2006 21:43:14 -0000	1.154
+++ configure.in	22 Jun 2006 11:39:09 -0000
@@ -100,6 +100,20 @@
     AC_DEFINE(G_DISABLE_CHECKS,1,[Disable GLib public API sanity checking])
 fi
 
+### Check for Win32
+
+AC_MSG_CHECKING([for Win32])
+case "$host" in
+  *-*-mingw*)
+    dbus_native_win32=yes
+    ;;
+  *)
+    dbus_native_win32=no
+    ;;
+esac
+AC_MSG_RESULT([$dbus_native_win32])
+AM_CONDITIONAL(OS_WIN32, [test "$dbus_native_win32" = "yes"])
+
 #### gcc warning flags
 
 if test "x$GCC" = "xyes"; then
@@ -561,6 +575,8 @@
 AC_CHECK_LIB(socket,socket)
 AC_CHECK_LIB(nsl,gethostbyname)
 
+AC_CHECK_HEADERS(grp.h pwd.h sys/time.h sys/wait.h time.h unistd.h)
+
 AC_CHECK_FUNCS(vsnprintf vasprintf nanosleep usleep poll setenv unsetenv socketpair getgrouplist)
 
 AC_CHECK_HEADERS(execinfo.h, [AC_CHECK_FUNCS(backtrace)])
Index: bus/activation.c
===================================================================
RCS file: /cvs/dbus/dbus/bus/activation.c,v
retrieving revision 1.41
diff -u -b -B -r1.41 activation.c
--- bus/activation.c	22 Nov 2005 20:37:00 -0000	1.41
+++ bus/activation.c	22 Jun 2006 11:39:09 -0000
@@ -34,6 +34,7 @@
 #include <dbus/dbus-spawn.h>
 #include <dbus/dbus-timeout.h>
 #include <dirent.h>
+#include <stdlib.h>
 #include <errno.h>
 
 #define DBUS_SERVICE_SECTION "D-BUS Service"
@@ -781,37 +782,90 @@
   dbus_free (activation);
 }
 
-static void
-child_setup (void *data)
+static char **
+create_environ_for_child (BusActivation *activation)
 {
-  BusActivation *activation = data;
   const char *type;
+  char **e, **p, **newenv;
+  int envsize;
+  
+  type = bus_context_get_type (activation->context);
+
+  /* Make a copy of the current process's environment, except for
+   * those env vars we want to set in the child.
+   */
+  e = _environ;
+  envsize = 0;
+  while (*e++)
+    envsize++;
+  
+  newenv = dbus_new (char *, envsize + 5);
   
   /* If no memory, we simply have the child exit, so it won't try
    * to connect to the wrong thing.
    */
-  if (!_dbus_setenv ("DBUS_STARTER_ADDRESS", activation->server_address))
+  if (newenv == NULL)
     _dbus_exit (1);
   
-  type = bus_context_get_type (activation->context);
-  if (type != NULL)
-    {
-      if (!_dbus_setenv ("DBUS_STARTER_BUS_TYPE", type))
-        _dbus_exit (1);
+  e = _environ;
+  p = newenv;
 
-      if (strcmp (type, "session") == 0)
+  while (*e)
         {
-          if (!_dbus_setenv ("DBUS_SESSION_BUS_ADDRESS",
-                             activation->server_address))
-            _dbus_exit (1);
-        }
-      else if (strcmp (type, "system") == 0)
+      if (strncmp (*e, "DBUS_STARTER_ADDRESS=",
+		   strlen ("DBUS_STARTER_ADDRESS=")) == 0)
+	;
+      else if (strncmp (*e, "DBUS_STARTER_BUS_TYPE=",
+			strlen ("DBUS_STARTER_BUS_TYPE=")) == 0)
+	;
+      else if (type != NULL &&
+	       strcmp (type, "session") == 0 &&
+	       strncmp (*e, "DBUS_SESSION_BUS_ADDRESS=",
+			strlen ("DBUS_SESSION_BUS_ADDRESS=")) == 0)
+	;
+      else if (type != NULL &&
+	       strcmp (type, "system") == 0 &&
+	       strncmp (*e, "DBUS_SYSTEM_BUS_ADDRESS=",
+			strlen ("DBUS_SYSTEM_BUS_ADDRESS=")) == 0)
+	;
+      else
         {
-          if (!_dbus_setenv ("DBUS_SYSTEM_BUS_ADDRESS",
-                             activation->server_address))
+	  *p = _dbus_strdup (*e);
+	  if (*p == NULL)
             _dbus_exit (1);
+	  p++;
+	}
+      e++;
         }
+
+#define SETENV(name,value)					\
+   do {								\
+     *p = dbus_malloc (strlen (name) + 1 + strlen (value) + 1);	\
+     if (*p == NULL)						\
+       _dbus_exit (1);						\
+     strcpy (*p, name);						\
+     strcat (*p, "=");						\
+     strcat (*p, value);					\
+     p++;							\
+   } while (0)
+
+  SETENV ("DBUS_STARTER_ADDRESS", activation->server_address);
+
+  if (type != NULL)
+    {
+      SETENV ("DBUS_STARTER_BUS_TYPE", type);
+
+      if (strcmp (type, "session") == 0)
+	SETENV ("DBUS_SESSION_BUS_ADDRESS", activation->server_address);
+      else if (strcmp (type, "system") == 0)
+	SETENV ("DBUS_SYSTEM_BUS_ADDRESS", activation->server_address);
     }
+
+#undef SETENV
+
+  *p = NULL;
+
+  return newenv;
 }
 
 typedef struct
@@ -1305,6 +1359,7 @@
   DBusMessage *message;
   DBusString service_str;
   char **argv;
+  char **envp;
   int argc;
   dbus_bool_t retval;
   DBusHashIter iter;
@@ -1535,8 +1590,10 @@
     }
 
   _dbus_verbose ("Spawning %s ...\n", argv[0]);
-  if (!_dbus_spawn_async_with_babysitter (&pending_activation->babysitter, argv,
-                                          child_setup, activation, 
+   envp = create_environ_for_child (activation);                                            
+                                                                                            
+   if (!_dbus_spawn_async_with_babysitter (&pending_activation->babysitter, argv, envp,     
+ 					  NULL, NULL,                                                                    
                                           error))
     {
       _dbus_verbose ("Failed to spawn child\n");
Index: bus/bus.c
===================================================================
RCS file: /cvs/dbus/dbus/bus/bus.c,v
retrieving revision 1.67
diff -u -b -B -r1.67 bus.c
--- bus/bus.c	7 Jun 2006 20:07:34 -0000	1.67
+++ bus/bus.c	22 Jun 2006 11:39:09 -0000
@@ -1003,7 +1003,7 @@
 
 dbus_bool_t
 bus_context_allow_user (BusContext   *context,
-                        unsigned long uid)
+                        dbus_uid_t  uid)
 {
   return bus_policy_allow_user (context->policy,
                                 context->user_database,
Index: bus/bus.h
===================================================================
RCS file: /cvs/dbus/dbus/bus/bus.h,v
retrieving revision 1.27
diff -u -b -B -r1.27 bus.h
--- bus/bus.h	22 Nov 2005 20:37:00 -0000	1.27
+++ bus/bus.h	22 Jun 2006 11:39:10 -0000
@@ -89,7 +89,7 @@
 DBusUserDatabase* bus_context_get_user_database                  (BusContext       *context);
 
 dbus_bool_t       bus_context_allow_user                         (BusContext       *context,
-                                                                  unsigned long     uid);
+                                                                  dbus_uid_t        uid);
 BusPolicy*        bus_context_get_policy                         (BusContext       *context);
 
 BusClientPolicy*  bus_context_create_client_policy               (BusContext       *context,
Index: bus/config-parser.c
===================================================================
RCS file: /cvs/dbus/dbus/bus/config-parser.c,v
retrieving revision 1.42
diff -u -b -B -r1.42 config-parser.c
--- bus/config-parser.c	15 Jun 2005 02:31:38 -0000	1.42
+++ bus/config-parser.c	22 Jun 2006 11:39:10 -0000
@@ -81,7 +81,12 @@
     struct
     {
       PolicyType type;
-      unsigned long gid_uid_or_at_console;      
+      union
+      {
+	dbus_uid_t uid;
+	dbus_gid_t gid;
+	dbus_bool_t at_console;
+      } u;
     } policy;
 
     struct
@@ -889,7 +894,7 @@
           _dbus_string_init_const (&username, user);
 
           if (_dbus_get_user_id (&username,
-                                 &e->d.policy.gid_uid_or_at_console))
+                                 &e->d.policy.u.uid))
             e->d.policy.type = POLICY_USER;
           else
             _dbus_warn ("Unknown username \"%s\" in message bus configuration file\n",
@@ -901,7 +906,7 @@
           _dbus_string_init_const (&group_name, group);
 
           if (_dbus_get_group_id (&group_name,
-                                  &e->d.policy.gid_uid_or_at_console))
+                                  &e->d.policy.u.gid))
             e->d.policy.type = POLICY_GROUP;
           else
             _dbus_warn ("Unknown group \"%s\" in message bus configuration file\n",
@@ -913,7 +918,7 @@
            t = (strcmp (at_console, "true") == 0);
            if (t || strcmp (at_console, "false") == 0)
              {
-               e->d.policy.gid_uid_or_at_console = t; 
+               e->d.policy.u.at_console = t; 
                e->d.policy.type = POLICY_CONSOLE;
              }  
            else
@@ -1400,7 +1405,7 @@
           
           _dbus_string_init_const (&groupname, group);
           
-          if (_dbus_get_user_id (&groupname, &gid))
+          if (_dbus_get_group_id (&groupname, &gid))
             {
               rule = bus_policy_rule_new (BUS_POLICY_RULE_GROUP, allow); 
               if (rule == NULL)
@@ -1449,7 +1454,7 @@
               goto failed;
             }
           
-          if (!bus_policy_append_user_rule (parser->policy, pe->d.policy.gid_uid_or_at_console,
+          if (!bus_policy_append_user_rule (parser->policy, pe->d.policy.u.uid,
                                             rule))
             goto nomem;
           break;
@@ -1462,14 +1467,14 @@
               goto failed;
             }
           
-          if (!bus_policy_append_group_rule (parser->policy, pe->d.policy.gid_uid_or_at_console,
+          if (!bus_policy_append_group_rule (parser->policy, pe->d.policy.u.gid,
                                              rule))
             goto nomem;
           break;
         
 
         case POLICY_CONSOLE:
-          if (!bus_policy_append_console_rule (parser->policy, pe->d.policy.gid_uid_or_at_console,
+          if (!bus_policy_append_console_rule (parser->policy, pe->d.policy.u.at_console,
                                              rule))
             goto nomem;
           break;
@@ -2666,10 +2671,28 @@
     case ELEMENT_POLICY:
       if (a->d.policy.type != b->d.policy.type)
 	return FALSE;
-      if (a->d.policy.gid_uid_or_at_console != b->d.policy.gid_uid_or_at_console)
+      switch (a->d.policy.type)
+	{
+	case POLICY_USER:
+	  if (!DBUS_UID_EQUAL (a->d.policy.u.uid, b->d.policy.u.uid))
+	    return FALSE;
+	  break;
+
+	case POLICY_GROUP:
+	  if (!DBUS_GID_EQUAL (a->d.policy.u.gid, b->d.policy.u.gid))
 	return FALSE;
       break;
 
+	case POLICY_CONSOLE:
+	  if (a->d.policy.u.at_console != b->d.policy.u.at_console)
+	    return FALSE;
+	  break;
+
+	default:
+	  break;		/* TRUE or FALSE? */
+	}
+      break;
+
     case ELEMENT_LIMIT:
       if (strcmp (a->d.limit.name, b->d.limit.name))
 	return FALSE;
Index: bus/connection.c
===================================================================
RCS file: /cvs/dbus/dbus/bus/connection.c,v
retrieving revision 1.62
diff -u -b -B -r1.62 connection.c
--- bus/connection.c	10 Feb 2006 21:44:15 -0000	1.62
+++ bus/connection.c	22 Jun 2006 11:39:11 -0000
@@ -114,7 +114,7 @@
 
   /* val is NULL is 0 when it isn't in the hash yet */
   
-  val = _dbus_hash_table_lookup_ulong (connections->completed_by_user,
+  val = _dbus_hash_table_lookup_uid_t (connections->completed_by_user,
                                        uid);
 
   current_count = _DBUS_POINTER_TO_INT (val);
@@ -143,14 +143,14 @@
 
   if (current_count == 0)
     {
-      _dbus_hash_table_remove_ulong (connections->completed_by_user, uid);
+      _dbus_hash_table_remove_uid_t (connections->completed_by_user, uid);
       return TRUE;
     }
   else
     {
       dbus_bool_t retval;
       
-      retval = _dbus_hash_table_insert_ulong (connections->completed_by_user,
+      retval = _dbus_hash_table_insert_uid_t (connections->completed_by_user,
                                               uid, _DBUS_INT_TO_POINTER (current_count));
 
       /* only positive adjustment can fail as otherwise
@@ -252,7 +252,7 @@
     {
       if (d->name != NULL)
         {
-          unsigned long uid;
+          dbus_uid_t uid;
           
           _dbus_list_remove_link (&d->connections->completed, d->link_in_connection_list);
           d->link_in_connection_list = NULL;
@@ -369,7 +369,7 @@
 
 static dbus_bool_t
 allow_user_function (DBusConnection *connection,
-                     unsigned long   uid,
+                     dbus_uid_t      uid,
                      void           *data)
 {
   BusConnectionData *d;
@@ -429,7 +429,7 @@
   if (connections == NULL)
     goto failed_1;
 
-  connections->completed_by_user = _dbus_hash_table_new (DBUS_HASH_ULONG,
+  connections->completed_by_user = _dbus_hash_table_new (DBUS_HASH_UID_T,
                                                          NULL, NULL);
   if (connections->completed_by_user == NULL)
     goto failed_2;
@@ -770,12 +770,12 @@
 
 dbus_bool_t
 bus_connection_get_groups  (DBusConnection   *connection,
-                            unsigned long   **groups,
+                            dbus_gid_t      **groups,
                             int              *n_groups,
                             DBusError        *error)
 {
   BusConnectionData *d;
-  unsigned long uid;
+  dbus_uid_t uid;
   DBusUserDatabase *user_database;
   
   d = BUS_CONNECTION_DATA (connection);
@@ -794,13 +794,13 @@
                                            error))
         {
           _DBUS_ASSERT_ERROR_IS_SET (error);
-          _dbus_verbose ("Did not get any groups for UID %lu\n",
+          _dbus_verbose ("Did not get any groups for UID "DBUS_UID_FORMAT"\n",
                          uid);
           return FALSE;
         }
       else
         {
-          _dbus_verbose ("Got %d groups for UID %lu\n",
+          _dbus_verbose ("Got %d groups for UID "DBUS_UID_FORMAT"\n",
                          *n_groups, uid);
           return TRUE;
         }
@@ -811,10 +811,10 @@
 
 dbus_bool_t
 bus_connection_is_in_group (DBusConnection *connection,
-                            unsigned long   gid)
+                            dbus_gid_t      gid)
 {
   int i;
-  unsigned long *group_ids;
+  dbus_gid_t *group_ids;
   int n_group_ids;
 
   if (!bus_connection_get_groups (connection, &group_ids, &n_group_ids,
@@ -1254,7 +1254,7 @@
                          DBusError        *error)
 {
   BusConnectionData *d;
-  unsigned long uid;
+  dbus_uid_t uid;
   
   d = BUS_CONNECTION_DATA (connection);
   _dbus_assert (d != NULL);
@@ -1344,7 +1344,7 @@
                               DBusError       *error)
 {
   BusConnectionData *d;
-  unsigned long uid;
+  dbus_uid_t uid;
   
   d = BUS_CONNECTION_DATA (requesting_completion);
   _dbus_assert (d != NULL);
@@ -1365,7 +1365,7 @@
           bus_context_get_max_connections_per_user (connections->context))
         {
           dbus_set_error (error, DBUS_ERROR_LIMITS_EXCEEDED,
-                          "The maximum number of active connections for UID %lu has been reached",
+                          "The maximum number of active connections for UID "DBUS_UID_FORMAT" has been reached",
                           uid);
           return FALSE;
         }
Index: bus/connection.h
===================================================================
RCS file: /cvs/dbus/dbus/bus/connection.h,v
retrieving revision 1.21
diff -u -b -B -r1.21 connection.h
--- bus/connection.h	10 Aug 2004 03:06:59 -0000	1.21
+++ bus/connection.h	22 Jun 2006 11:39:11 -0000
@@ -106,9 +106,9 @@
 void        bus_connection_disconnected (DBusConnection *connection);
 
 dbus_bool_t      bus_connection_is_in_group (DBusConnection       *connection,
-                                             unsigned long         gid);
+                                             dbus_gid_t           gid);
 dbus_bool_t      bus_connection_get_groups  (DBusConnection       *connection,
-                                             unsigned long       **groups,
+                                             dbus_gid_t          **groups,
                                              int                  *n_groups,
                                              DBusError            *error);
 BusClientPolicy* bus_connection_get_policy  (DBusConnection       *connection);
Index: bus/desktop-file.c
===================================================================
RCS file: /cvs/dbus/dbus/bus/desktop-file.c,v
retrieving revision 1.11
diff -u -b -B -r1.11 desktop-file.c
--- bus/desktop-file.c	30 Nov 2005 20:14:30 -0000	1.11
+++ bus/desktop-file.c	22 Jun 2006 11:39:11 -0000
@@ -393,7 +393,7 @@
 static dbus_bool_t
 parse_section_start (BusDesktopFileParser *parser, DBusError *error)
 {
-  int line_end;
+  int line_end, real_end;
   char *section_name;
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
@@ -401,6 +401,10 @@
   if (!_dbus_string_find (&parser->data, parser->pos, "\n", &line_end))
     line_end = parser->len;
   
+  real_end = line_end;
+  if (line_end - parser->pos >= 2 && _dbus_string_get_byte (&parser->data, line_end - 1) == '\r')
+    line_end--;
+  
   if (line_end - parser->pos <= 2 ||
       _dbus_string_get_byte (&parser->data, line_end - 1) != ']')
     {
@@ -433,10 +437,10 @@
       return FALSE;
     }
 
-  if (line_end == parser->len)
+  if (real_end == parser->len)
     parser->pos = parser->len;
   else
-    parser->pos = line_end + 1;
+    parser->pos = real_end + 1;
   
   parser->line_num += 1;
 
@@ -448,7 +452,7 @@
 static dbus_bool_t
 parse_key_value (BusDesktopFileParser *parser, DBusError *error)
 {
-  int line_end;
+  int line_end, real_end;
   int key_start, key_end;
   int value_start;
   int p;
@@ -461,6 +465,10 @@
   if (!_dbus_string_find (&parser->data, parser->pos, "\n", &line_end))
     line_end = parser->len;
   
+  real_end = line_end;
+  if (line_end - parser->pos >= 2 && _dbus_string_get_byte (&parser->data, line_end - 1) == '\r')
+    line_end--;
+  
   p = parser->pos;
   key_start = p;
   while (p < line_end &&
@@ -553,10 +561,10 @@
   line->key = tmp;
   line->value = value;
 
-  if (line_end == parser->len)
+  if (real_end == parser->len)
     parser->pos = parser->len;
   else
-    parser->pos = line_end + 1;
+    parser->pos = real_end + 1;
   
   parser->line_num += 1;
 
Index: bus/dispatch.c
===================================================================
RCS file: /cvs/dbus/dbus/bus/dispatch.c,v
retrieving revision 1.74
diff -u -b -B -r1.74 dispatch.c
--- bus/dispatch.c	22 Nov 2005 20:37:00 -0000	1.74
+++ bus/dispatch.c	22 Jun 2006 11:39:12 -0000
@@ -1,3 +1,8 @@
+#ifndef _MSC_VER
+#define PING() fprintf (stderr, "%s:%s:%d\n", __FILE__, __FUNCTION__, __LINE__); fflush (stderr)
+#else
+#define PING() 
+#endif
 /* -*- mode: C; c-file-style: "gnu" -*- */
 /* dispatch.c  Message dispatcher
  *
@@ -1059,7 +1064,11 @@
   dbus_bool_t retval;
   DBusError error;
   const char *base_service_name;
-  dbus_uint32_t uid;
+#ifndef _WIN32
+  dbus_uint32_t uid32;
+#else
+  dbus_uid_t uid;
+#endif
 
   retval = FALSE;
   dbus_error_init (&error);
@@ -1151,7 +1160,11 @@
     retry_get_property:
 
       if (!dbus_message_get_args (message, &error,
-                                  DBUS_TYPE_UINT32, &uid,
+#ifndef _WIN32
+                                  DBUS_TYPE_UINT32, &uid32,
+#else
+                                  DBUS_TYPE_STRING, &uid,
+#endif
                                   DBUS_TYPE_INVALID))
         {
           if (dbus_error_has_name (&error, DBUS_ERROR_NO_MEMORY))
@@ -1164,7 +1177,7 @@
           else
             {
               _dbus_assert (dbus_error_is_set (&error));
-              _dbus_warn ("Did not get the expected DBUS_TYPE_UINT32 from GetConnectionUnixUser\n");
+              _dbus_warn ("Did not get the expected type from GetConnectionUnixUser\n");
               goto out;
             }
         }
@@ -2623,6 +2636,7 @@
   const char *segv_service;
   dbus_uint32_t flags;
   
+  PING();
   message = dbus_message_new_method_call (DBUS_SERVICE_DBUS,
                                           DBUS_PATH_DBUS,
                                           DBUS_INTERFACE_DBUS,
@@ -2631,10 +2645,13 @@
   if (message == NULL)
     return TRUE;
 
+  PING();
   dbus_message_set_auto_start (message, FALSE);
   
+  PING();
   segv_service = "org.freedesktop.DBus.TestSuiteSegfaultService";
   flags = 0;
+  PING();
   if (!dbus_message_append_args (message,
                                  DBUS_TYPE_STRING, &segv_service,
                                  DBUS_TYPE_UINT32, &flags,
@@ -2644,6 +2661,7 @@
       return TRUE;
     }
   
+  PING();
   if (!dbus_connection_send (connection, message, &serial))
     {
       dbus_message_unref (message);
@@ -2653,10 +2671,13 @@
   dbus_message_unref (message);
   message = NULL;
 
+  PING();
   bus_test_run_everything (context);
+  PING();
   block_connection_until_message_from_bus (context, connection, "reply to activating segfault service");
   bus_test_run_everything (context);
 
+  PING();
   if (!dbus_connection_get_is_connected (connection))
     {
       _dbus_verbose ("connection was disconnected: %s %d\n", _DBUS_FUNCTION_NAME, __LINE__);
@@ -2665,6 +2686,7 @@
   
   retval = FALSE;
   
+  PING();
   message = pop_message_waiting_for_memory (connection);
   if (message == NULL)
     {
@@ -2673,10 +2695,13 @@
       goto out;
     }
 
+  PING();
   verbose_message_received (connection, message);
 
+  PING();
   if (dbus_message_get_type (message) == DBUS_MESSAGE_TYPE_ERROR)
     {
+  PING();
       if (!dbus_message_has_sender (message, DBUS_SERVICE_DBUS))
         {
           _dbus_warn ("Message has wrong sender %s\n",
@@ -2685,18 +2710,29 @@
           goto out;
         }
       
+  PING();
       if (dbus_message_is_error (message,
                                  DBUS_ERROR_NO_MEMORY))
         {
           ; /* good, this is a valid response */
         }
+#ifdef _WIN32
+      else if (dbus_message_is_error (message,
+                                      DBUS_ERROR_SPAWN_CHILD_EXITED))
+        {
+  PING();
+          ; /* good, this is expected also */
+        }
+#endif
       else if (dbus_message_is_error (message,
                                       DBUS_ERROR_SPAWN_CHILD_SIGNALED))
         {
+  PING();
           ; /* good, this is expected also */
         }
       else
         {
+  PING();
           warn_unexpected (connection, message, "not this error");
 
           goto out;
@@ -2704,13 +2740,16 @@
     }
   else
     {
+  PING();
       _dbus_warn ("Did not expect to successfully activate segfault service\n");
       goto out;
     }
 
+  PING();
   retval = TRUE;
   
  out:
+  PING();
   if (message)
     dbus_message_unref (message);
   
@@ -2783,6 +2822,13 @@
         {
           ; /* good, this is a valid response */
         }
+#ifdef _WIN32
+      else if (dbus_message_is_error (message,
+                                      DBUS_ERROR_SPAWN_CHILD_EXITED))
+        {
+          ; /* good, this is expected also */
+        }
+#endif
       else if (dbus_message_is_error (message,
                                       DBUS_ERROR_SPAWN_CHILD_SIGNALED))
         {
@@ -3572,28 +3618,35 @@
   if (context == NULL)
     return FALSE;
   
+  PING();
   foo = dbus_connection_open ("debug-pipe:name=test-server", &error);
   if (foo == NULL)
     _dbus_assert_not_reached ("could not alloc connection");
 
+  PING();
   if (!bus_setup_debug_client (foo))
     _dbus_assert_not_reached ("could not set up connection");
 
   spin_connection_until_authenticated (context, foo);
   
+  PING();
   if (!check_hello_message (context, foo))
     _dbus_assert_not_reached ("hello message failed");
 
+  PING();
   if (!check_double_hello_message (context, foo))
     _dbus_assert_not_reached ("double hello message failed");
 
+  PING();
   if (!check_add_match_all (context, foo))
     _dbus_assert_not_reached ("AddMatch message failed");
   
+  PING();
   bar = dbus_connection_open ("debug-pipe:name=test-server", &error);
   if (bar == NULL)
     _dbus_assert_not_reached ("could not alloc connection");
 
+  PING();
   if (!bus_setup_debug_client (bar))
     _dbus_assert_not_reached ("could not set up connection");
 
@@ -3617,15 +3670,20 @@
   if (!check_hello_message (context, baz))
     _dbus_assert_not_reached ("hello message failed");
 
+  PING();
   if (!check_add_match_all (context, baz))
     _dbus_assert_not_reached ("AddMatch message failed");
 
+  PING();
+  if (!getenv ("NO_UNIX_USER_TEST"))
   if (!check_get_connection_unix_user (context, baz))
     _dbus_assert_not_reached ("GetConnectionUnixUser message failed");
 
+  PING();
   if (!check_get_connection_unix_process_id (context, baz))
     _dbus_assert_not_reached ("GetConnectionUnixProcessID message failed");
   
+  PING();
   if (!check_no_leftovers (context))
     {
       _dbus_warn ("Messages were left over after setting up initial connections");
Index: bus/driver.c
===================================================================
RCS file: /cvs/dbus/dbus/bus/driver.c,v
retrieving revision 1.76
diff -u -b -B -r1.76 driver.c
--- bus/driver.c	22 Nov 2005 20:37:00 -0000	1.76
+++ bus/driver.c	22 Jun 2006 11:39:12 -0000
@@ -1040,8 +1040,10 @@
   BusService *serv;
   DBusConnection *conn;
   DBusMessage *reply;
-  unsigned long uid;
+  dbus_uid_t uid;
+#ifndef _WIN32
   dbus_uint32_t uid32;
+#endif
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 
@@ -1081,11 +1083,17 @@
       goto failed;
     }
 
+#ifndef _WIN32
   uid32 = uid;
   if (! dbus_message_append_args (reply,
                                   DBUS_TYPE_UINT32, &uid32,
                                   DBUS_TYPE_INVALID))
     goto oom;
+#else
+  if (! dbus_message_append_args (reply,
+                                  DBUS_TYPE_STRING, &uid,
+                                  DBUS_TYPE_INVALID))
+#endif
 
   if (! bus_transaction_send_from_driver (transaction, connection, reply))
     goto oom;
Index: bus/main.c
===================================================================
RCS file: /cvs/dbus/dbus/bus/main.c,v
retrieving revision 1.31
diff -u -b -B -r1.31 main.c
--- bus/main.c	15 Jun 2005 02:31:38 -0000	1.31
+++ bus/main.c	22 Jun 2006 11:39:12 -0000
@@ -40,10 +40,13 @@
 static void
 signal_handler (int sig)
 {
+#ifdef SIGHUP
   DBusString str;
+#endif
 
   switch (sig)
     {
+#ifdef SIGHUP
 #ifdef DBUS_BUS_ENABLE_DNOTIFY_ON_LINUX 
     case SIGIO: 
       /* explicit fall-through */
@@ -56,7 +59,7 @@
 	  exit (1);
 	}
       break;
-
+#endif
     case SIGTERM:
       _dbus_loop_quit (bus_context_get_loop (context));
       break;
@@ -356,6 +359,7 @@
 
           print_addr_fd = val;
         }
+      print_addr_fd = _dbus_encapsulate_fd (print_addr_fd);
     }
   _dbus_string_free (&addr_fd);
 
@@ -378,6 +382,7 @@
 
           print_pid_fd = val;
         }
+      print_pid_fd = _dbus_encapsulate_fd (print_pid_fd);
     }
   _dbus_string_free (&pid_fd);
 
@@ -402,7 +407,9 @@
 
   setup_reload_pipe (bus_context_get_loop (context));
 
+#ifdef SIGHUP
   _dbus_set_signal_handler (SIGHUP, signal_handler);
+#endif
   _dbus_set_signal_handler (SIGTERM, signal_handler);
 #ifdef DBUS_BUS_ENABLE_DNOTIFY_ON_LINUX 
   _dbus_set_signal_handler (SIGIO, signal_handler);
Index: bus/policy.c
===================================================================
RCS file: /cvs/dbus/dbus/bus/policy.c,v
retrieving revision 1.23
diff -u -b -B -r1.23 policy.c
--- bus/policy.c	29 Aug 2005 20:19:19 -0000	1.23
+++ bus/policy.c	22 Jun 2006 11:39:12 -0000
@@ -168,13 +168,13 @@
 
   policy->refcount = 1;
   
-  policy->rules_by_uid = _dbus_hash_table_new (DBUS_HASH_ULONG,
+  policy->rules_by_uid = _dbus_hash_table_new (DBUS_HASH_UID_T,
                                                NULL,
                                                free_rule_list_func);
   if (policy->rules_by_uid == NULL)
     goto failed;
 
-  policy->rules_by_gid = _dbus_hash_table_new (DBUS_HASH_ULONG,
+  policy->rules_by_gid = _dbus_hash_table_new (DBUS_HASH_UID_T,
                                                NULL,
                                                free_rule_list_func);
   if (policy->rules_by_gid == NULL)
@@ -291,7 +291,7 @@
    */
   if (_dbus_hash_table_get_n_entries (policy->rules_by_gid) > 0)
     {
-      unsigned long *groups;
+      dbus_gid_t *groups;
       int n_groups;
       int i;
       
@@ -303,7 +303,7 @@
         {
           DBusList **list;
           
-          list = _dbus_hash_table_lookup_ulong (policy->rules_by_gid,
+          list = _dbus_hash_table_lookup_gid_t (policy->rules_by_gid,
                                                 groups[i]);
           
           if (list != NULL)
@@ -332,7 +332,7 @@
     {
       DBusList **list;
       
-      list = _dbus_hash_table_lookup_ulong (policy->rules_by_uid,
+      list = _dbus_hash_table_lookup_uid_t (policy->rules_by_uid,
                                             uid);
 
       if (list != NULL)
@@ -379,8 +379,8 @@
 static dbus_bool_t
 list_allows_user (dbus_bool_t           def,
                   DBusList            **list,
-                  unsigned long         uid,
-                  const unsigned long  *group_ids,
+                  dbus_uid_t     uid,
+                  dbus_gid_t    *group_ids,
                   int                   n_group_ids)
 {
   DBusList *link;
@@ -399,9 +399,9 @@
           _dbus_verbose ("List %p user rule uid="DBUS_UID_FORMAT"\n",
                          list, rule->d.user.uid);
           
-          if (rule->d.user.uid == DBUS_UID_UNSET)
+          if (DBUS_UID_EQUAL (rule->d.user.uid, DBUS_UID_UNSET))
             ; /* '*' wildcard */
-          else if (rule->d.user.uid != uid)
+          else if (!DBUS_UID_EQUAL (rule->d.user.uid, uid))
             continue;
         }
       else if (rule->type == BUS_POLICY_RULE_GROUP)
@@ -409,7 +409,7 @@
           _dbus_verbose ("List %p group rule uid="DBUS_UID_FORMAT"\n",
                          list, rule->d.user.uid);
           
-          if (rule->d.group.gid == DBUS_GID_UNSET)
+          if (DBUS_GID_EQUAL (rule->d.group.gid, DBUS_GID_UNSET))
             ;  /* '*' wildcard */
           else
             {
@@ -418,7 +418,7 @@
               i = 0;
               while (i < n_group_ids)
                 {
-                  if (rule->d.group.gid == group_ids[i])
+                  if (DBUS_GID_EQUAL (rule->d.group.gid, group_ids[i]))
                     break;
                   ++i;
                 }
@@ -439,17 +439,17 @@
 dbus_bool_t
 bus_policy_allow_user (BusPolicy        *policy,
                        DBusUserDatabase *user_database,
-                       unsigned long     uid)
+                       dbus_uid_t        uid)
 {
   dbus_bool_t allowed;
-  unsigned long *group_ids;
+  dbus_gid_t *group_ids;
   int n_group_ids;
 
   /* On OOM or error we always reject the user */
   if (!_dbus_user_database_get_groups (user_database,
                                        uid, &group_ids, &n_group_ids, NULL))
     {
-      _dbus_verbose ("Did not get any groups for UID %lu\n",
+      _dbus_verbose ("Did not get any groups for UID "DBUS_UID_FORMAT"\n",
                      uid);
       return FALSE;
     }
@@ -469,7 +469,7 @@
 
   dbus_free (group_ids);
 
-  _dbus_verbose ("UID %lu allowed = %d\n", uid, allowed);
+  _dbus_verbose ("UID "DBUS_UID_FORMAT" allowed = %d\n", uid, allowed);
   
   return allowed;
 }
@@ -500,13 +500,15 @@
 
 
 
+/* We cheat here and know that dbus_uid_t is the same as dbus_gid_t on both Unix and Windows */
+
 static DBusList**
 get_list (DBusHashTable *hash,
-          unsigned long  key)
+          dbus_uid_t     key)
 {
   DBusList **list;
 
-  list = _dbus_hash_table_lookup_ulong (hash, key);
+  list = _dbus_hash_table_lookup_uid_t (hash, key);
 
   if (list == NULL)
     {
@@ -514,7 +516,7 @@
       if (list == NULL)
         return NULL;
 
-      if (!_dbus_hash_table_insert_ulong (hash, key, list))
+      if (!_dbus_hash_table_insert_uid_t (hash, key, list))
         {
           dbus_free (list);
           return NULL;
@@ -627,7 +629,7 @@
   _dbus_hash_iter_init (to_absorb, &iter);
   while (_dbus_hash_iter_next (&iter))
     {
-      unsigned long id = _dbus_hash_iter_get_ulong_key (&iter);
+      dbus_uid_t id = _dbus_hash_iter_get_uid_t_key (&iter);
       DBusList **list = _dbus_hash_iter_get_value (&iter);
       DBusList **target = get_list (dest, id);
 
Index: bus/policy.h
===================================================================
RCS file: /cvs/dbus/dbus/bus/policy.h,v
retrieving revision 1.16
diff -u -b -B -r1.16 policy.h
--- bus/policy.h	25 Aug 2004 22:11:49 -0000	1.16
+++ bus/policy.h	22 Jun 2006 11:39:12 -0000
@@ -114,7 +114,7 @@
                                                    DBusError        *error);
 dbus_bool_t      bus_policy_allow_user            (BusPolicy        *policy,
                                                    DBusUserDatabase *user_database,
-                                                   unsigned long     uid);
+                                                   dbus_uid_t        uid);
 dbus_bool_t      bus_policy_append_default_rule   (BusPolicy        *policy,
                                                    BusPolicyRule    *rule);
 dbus_bool_t      bus_policy_append_mandatory_rule (BusPolicy        *policy,
Index: bus/test-main.c
===================================================================
RCS file: /cvs/dbus/dbus/bus/test-main.c,v
retrieving revision 1.21
diff -u -b -B -r1.21 test-main.c
--- bus/test-main.c	3 Nov 2004 16:38:35 -0000	1.21
+++ bus/test-main.c	22 Jun 2006 11:39:13 -0000
@@ -80,6 +80,8 @@
 
   progname = argv[0];
 
+  setvbuf (stdout, NULL, _IONBF, 0);
+
   if (argc > 1)
     dir = argv[1];
   else
Index: dbus/Makefile.am
===================================================================
RCS file: /cvs/dbus/dbus/dbus/Makefile.am,v
retrieving revision 1.75
diff -u -b -B -r1.75 Makefile.am
--- dbus/Makefile.am	4 Jun 2006 16:02:16 -0000	1.75
+++ dbus/Makefile.am	22 Jun 2006 11:39:13 -0000
@@ -30,6 +30,7 @@
 	dbus-memory.h				\
 	dbus-message.h				\
 	dbus-pending-call.h			\
+	dbus-platform-deps.h			\
 	dbus-protocol.h				\
 	dbus-server.h				\
 	dbus-shared.h				\
@@ -80,6 +81,7 @@
 	dbus-server-unix.h			\
 	dbus-sha.c				\
 	dbus-sha.h				\
+	dbus-sockets.h				\
 	dbus-signature.c			\
 	dbus-timeout.c				\
 	dbus-timeout.h				\
@@ -139,7 +141,7 @@
 	dbus-message-util.c			\
 	dbus-shell.c				\
 	dbus-shell.h				\
-	dbus-spawn.c				\
+	$(DBUS_SPAWN_SOURCE)			\
 	dbus-spawn.h				\
 	dbus-string-util.c			\
 	dbus-sysdeps-util.c			\
Index: dbus/dbus-auth-script.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-auth-script.c,v
retrieving revision 1.17
diff -u -b -B -r1.17 dbus-auth-script.c
--- dbus/dbus-auth-script.c	26 Feb 2005 06:37:46 -0000	1.17
+++ dbus/dbus-auth-script.c	22 Jun 2006 11:39:13 -0000
@@ -360,19 +360,28 @@
       else if (_dbus_string_starts_with_c_str (&line,
                                                "NO_CREDENTIALS"))
         {
-          DBusCredentials creds = { -1, -1, -1 };
+          DBusCredentials creds = { -1, DBUS_UID_UNSET, DBUS_GID_UNSET };
           _dbus_auth_set_credentials (auth, &creds);
         }
       else if (_dbus_string_starts_with_c_str (&line,
                                                "ROOT_CREDENTIALS"))
         {
-          DBusCredentials creds = { -1, 0, 0 };
+          DBusCredentials creds = { -1, DBUS_UID_ROOT, DBUS_GID_ROOT };
           _dbus_auth_set_credentials (auth, &creds);          
         }
       else if (_dbus_string_starts_with_c_str (&line,
                                                "SILLY_CREDENTIALS"))
         {
+#ifndef _WIN32
           DBusCredentials creds = { -1, 4312, 1232 };
+#else
+          DBusCredentials creds =
+	    {
+	      -1,
+	      "S-1-5-21-1229054662-764737303-835922115-567",
+	      "S-1-5-21-1229054662-764737303-835922115-890"
+	    };
+#endif
           _dbus_auth_set_credentials (auth, &creds);          
         }
       else if (_dbus_string_starts_with_c_str (&line,
@@ -432,7 +441,7 @@
                     goto out;
                   }
 
-                if (!_dbus_string_append_uint (&username,
+                if (!_dbus_string_append_uid_t (&username,
                                                _dbus_getuid ()))
                   {
                     _dbus_warn ("no memory for userid\n");
Index: dbus/dbus-auth.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-auth.c,v
retrieving revision 1.47
diff -u -b -B -r1.47 dbus-auth.c
--- dbus/dbus-auth.c	30 Nov 2005 19:32:26 -0000	1.47
+++ dbus/dbus-auth.c	22 Jun 2006 11:39:13 -0000
@@ -966,7 +966,7 @@
 handle_server_data_external_mech (DBusAuth         *auth,
                                   const DBusString *data)
 {
-  if (auth->credentials.uid == DBUS_UID_UNSET)
+  if (DBUS_UID_EQUAL (auth->credentials.uid, DBUS_UID_UNSET))
     {
       _dbus_verbose ("%s: no credentials, mechanism EXTERNAL can't authenticate\n",
                      DBUS_AUTH_NAME (auth));
@@ -1027,7 +1027,7 @@
         }
     }
 
-  if (auth->desired_identity.uid == DBUS_UID_UNSET)
+  if (DBUS_UID_EQUAL (auth->desired_identity.uid, DBUS_UID_UNSET))
     {
       _dbus_verbose ("%s: desired user %s is no good\n",
                      DBUS_AUTH_NAME (auth),
@@ -1085,7 +1085,7 @@
   if (!_dbus_string_init (&plaintext))
     return FALSE;
   
-  if (!_dbus_string_append_uint (&plaintext,
+  if (!_dbus_string_append_uid_t (&plaintext,
                                  _dbus_getuid ()))
     goto failed;
 
Index: dbus/dbus-bus.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-bus.c,v
retrieving revision 1.50
diff -u -b -B -r1.50 dbus-bus.c
--- dbus/dbus-bus.c	3 May 2006 22:56:35 -0000	1.50
+++ dbus/dbus-bus.c	22 Jun 2006 11:39:14 -0000
@@ -573,6 +573,8 @@
   return bd->unique_name;
 }
 
+#ifndef _WIN32
+
 /**
  * Asks the bus to return the uid of the named
  * connection.
@@ -647,6 +649,7 @@
   return (unsigned long) uid;
 }
 
+#endif
 
 /**
  * Asks the bus to assign the given name to this connection by invoking
Index: dbus/dbus-connection.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-connection.c,v
retrieving revision 1.118
diff -u -b -B -r1.118 dbus-connection.c
--- dbus/dbus-connection.c	23 Apr 2006 18:54:47 -0000	1.118
+++ dbus/dbus-connection.c	22 Jun 2006 11:39:15 -0000
@@ -4122,7 +4122,7 @@
  */
 dbus_bool_t
 dbus_connection_get_unix_user (DBusConnection *connection,
-                               unsigned long  *uid)
+                               dbus_uid_t  *uid)
 {
   dbus_bool_t result;
 
Index: dbus/dbus-connection.h
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-connection.h,v
retrieving revision 1.40
diff -u -b -B -r1.40 dbus-connection.h
--- dbus/dbus-connection.h	30 Nov 2005 20:30:02 -0000	1.40
+++ dbus/dbus-connection.h	22 Jun 2006 11:39:15 -0000
@@ -30,6 +30,7 @@
 #include <dbus/dbus-errors.h>
 #include <dbus/dbus-memory.h>
 #include <dbus/dbus-message.h>
+#include <dbus/dbus-platform-deps.h>
 #include <dbus/dbus-shared.h>
 
 DBUS_BEGIN_DECLS
@@ -76,7 +77,7 @@
                                                     void           *data);
 typedef void        (* DBusWakeupMainFunction)     (void           *data);
 typedef dbus_bool_t (* DBusAllowUnixUserFunction)  (DBusConnection *connection,
-                                                    unsigned long   uid,
+                                                    dbus_uid_t      uid,
                                                     void           *data);
 
 typedef void (* DBusPendingCallNotifyFunction) (DBusPendingCall *pending,
@@ -145,7 +146,7 @@
                                                                  void                       *data,
                                                                  DBusFreeFunction            free_data_function);
 dbus_bool_t        dbus_connection_get_unix_user                (DBusConnection             *connection,
-                                                                 unsigned long              *uid);
+                                                                 dbus_uid_t                 *uid);
 dbus_bool_t        dbus_connection_get_unix_process_id          (DBusConnection             *connection,
                                                                  unsigned long              *pid);
 void               dbus_connection_set_unix_user_function       (DBusConnection             *connection,
Index: dbus/dbus-hash.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-hash.c,v
retrieving revision 1.20
diff -u -b -B -r1.20 dbus-hash.c
--- dbus/dbus-hash.c	6 Mar 2006 19:06:45 -0000	1.20
+++ dbus/dbus-hash.c	22 Jun 2006 11:39:16 -0000
@@ -1420,8 +1420,9 @@
  * are overwritten (and freed if the hash table has
  * a key_free_function and/or value_free_function).
  *
- * Returns #FALSE if memory for the new hash entry
- * can't be allocated.
+ * Returns #FALSE if memory for the new hash entry can't be
+ * allocated. If an entry with the given key already existed, that
+ * can't happen.
  * 
  * @param table the hash table.
  * @param key the hash entry key.
@@ -1432,10 +1433,26 @@
                                 char          *key,
                                 void          *value)
 {
+  DBusHashEntry *entry;
   DBusPreallocatedHash *preallocated;
 
   _dbus_assert (table->key_type == DBUS_HASH_STRING);
 
+  entry = (* table->find_function) (table, key, FALSE, NULL, NULL);
+  if (entry != NULL)
+    {
+      if (table->free_key_function && entry->key != key)
+	(* table->free_key_function) (entry->key);
+      
+      if (table->free_value_function && entry->value != value)
+	(* table->free_value_function) (entry->value);
+      
+      entry->key = key;
+      entry->value = value;
+
+      return TRUE;
+    }
+
   preallocated = _dbus_hash_table_preallocate_entry (table);
   if (preallocated == NULL)
     return FALSE;
Index: dbus/dbus-internals.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-internals.c,v
retrieving revision 1.44
diff -u -b -B -r1.44 dbus-internals.c
--- dbus/dbus-internals.c	13 Feb 2005 20:23:30 -0000	1.44
+++ dbus/dbus-internals.c	22 Jun 2006 11:39:16 -0000
@@ -28,7 +28,9 @@
 #include <string.h>
 #include <sys/types.h>
 #include <errno.h>
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
+#endif
 #include <fcntl.h>
 #include <stdlib.h>
 
@@ -188,13 +190,6 @@
  */
 
 /**
- * Fixed "out of memory" error message, just to avoid
- * making up a different string every time and wasting
- * space.
- */
-const char _dbus_no_memory_message[] = "Not enough memory";
-
-/**
  * Prints a warning message to stderr.
  *
  * @param format printf-style format string.
@@ -246,7 +241,12 @@
   
   if (!verbose_initted)
     {
+#ifdef _WIN32
+    	char *p = _dbus_getenv ("DBUS_VERBOSE"); 
+      verbose = p != NULL && *p == '1';
+#else
       verbose = _dbus_getenv ("DBUS_VERBOSE") != NULL;
+#endif
       verbose_initted = TRUE;
       if (!verbose)
         return;
Index: dbus/dbus-internals.h
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-internals.h,v
retrieving revision 1.55
diff -u -b -B -r1.55 dbus-internals.h
--- dbus/dbus-internals.h	26 Feb 2005 06:37:46 -0000	1.55
+++ dbus/dbus-internals.h	22 Jun 2006 11:39:16 -0000
@@ -81,7 +81,11 @@
                                ...) _DBUS_GNUC_PRINTF (1, 2);
 void _dbus_verbose_reset_real (void);
 
+#ifdef HAVE_GNUC_VARARGS
+# define _dbus_verbose(format, rest...) _dbus_verbose_real("[%s %d] " format, __FUNCTION__,__LINE__, ## rest)
+#else
 #  define _dbus_verbose _dbus_verbose_real
+#endif
 #  define _dbus_verbose_reset _dbus_verbose_reset_real
 #else
 #  ifdef HAVE_ISO_VARARGS
@@ -228,8 +232,7 @@
 
 const char* _dbus_header_field_to_string (int header_field);
 
-extern const char _dbus_no_memory_message[];
-#define _DBUS_SET_OOM(error) dbus_set_error_const ((error), DBUS_ERROR_NO_MEMORY, _dbus_no_memory_message)
+#define _DBUS_SET_OOM(error) dbus_set_error_const ((error), DBUS_ERROR_NO_MEMORY, NULL)
 
 #ifdef DBUS_BUILD_TESTS
 /* Memory debugging */
@@ -270,6 +273,10 @@
 #define _DBUS_LOCK(name)                _dbus_mutex_lock   (_dbus_lock_##name)
 #define _DBUS_UNLOCK(name)              _dbus_mutex_unlock (_dbus_lock_##name)
 
+#ifdef _WIN32
+_DBUS_DECLARE_GLOBAL_LOCK (win32_fds);
+_DBUS_DECLARE_GLOBAL_LOCK (win32_sids);
+#endif
 _DBUS_DECLARE_GLOBAL_LOCK (list);
 _DBUS_DECLARE_GLOBAL_LOCK (connection_slots);
 _DBUS_DECLARE_GLOBAL_LOCK (pending_call_slots);
@@ -281,7 +288,11 @@
 _DBUS_DECLARE_GLOBAL_LOCK (system_users);
 _DBUS_DECLARE_GLOBAL_LOCK (message_cache);
 _DBUS_DECLARE_GLOBAL_LOCK (shared_connections);
+#ifdef _WIN32
+#define _DBUS_N_GLOBAL_LOCKS (13)
+#else
 #define _DBUS_N_GLOBAL_LOCKS (11)
+#endif
 
 dbus_bool_t _dbus_threads_init_debug (void);
 
Index: dbus/dbus-mainloop.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-mainloop.c,v
retrieving revision 1.18
diff -u -b -B -r1.18 dbus-mainloop.c
--- dbus/dbus-mainloop.c	15 Jan 2005 07:15:38 -0000	1.18
+++ dbus/dbus-mainloop.c	22 Jun 2006 11:39:17 -0000
@@ -28,7 +28,7 @@
 #include <dbus/dbus-list.h>
 #include <dbus/dbus-sysdeps.h>
 
-#define MAINLOOP_SPEW 0
+#define MAINLOOP_SPEW 1
 
 #if MAINLOOP_SPEW
 #ifdef DBUS_ENABLE_VERBOSE_MODE
@@ -609,7 +609,7 @@
                   
               flags = dbus_watch_get_flags (wcb->watch);
                   
-              fds[n_fds].fd = dbus_watch_get_fd (wcb->watch);
+              fds[n_fds].fd = _dbus_re_encapsulate_socket (dbus_watch_get_fd (wcb->watch));
               fds[n_fds].revents = 0;
               fds[n_fds].events = 0;
               if (flags & DBUS_WATCH_READABLE)
Index: dbus/dbus-server-unix.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-server-unix.c,v
retrieving revision 1.29
diff -u -b -B -r1.29 dbus-server-unix.c
--- dbus/dbus-server-unix.c	25 Oct 2005 15:57:13 -0000	1.29
+++ dbus/dbus-server-unix.c	22 Jun 2006 11:39:17 -0000
@@ -22,17 +22,20 @@
  */
 
 #include "dbus-internals.h"
+#include "dbus-sockets.h"
 #include "dbus-server-unix.h"
 #include "dbus-transport-unix.h"
 #include "dbus-connection-internal.h"
 #include "dbus-string.h"
 #include <sys/types.h>
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
+#endif
 
 /**
- * @defgroup DBusServerUnix DBusServer implementations for UNIX
+ * @defgroup DBusServerUnix DBusServer implementations for UNIX and Winsock
  * @ingroup  DBusInternals
- * @brief Implementation details of DBusServer on UNIX
+ * @brief Implementation details of DBusServer on UNIX and Winsock
  *
  * @{
  */
@@ -102,7 +105,7 @@
   transport = _dbus_transport_new_for_fd (client_fd, &server->guid_hex, NULL);
   if (transport == NULL)
     {
-      close (client_fd);
+      _dbus_close (client_fd, NULL);
       SERVER_UNLOCK (server);
       return FALSE;
     }
@@ -219,7 +222,7 @@
       unix_server->watch = NULL;
     }
   
-  close (unix_server->fd);
+  _dbus_close (unix_server->fd, NULL);
   unix_server->fd = -1;
 
   if (unix_server->socket_name != NULL)
@@ -303,6 +306,8 @@
   return (DBusServer*) unix_server;
 }
 
+#ifndef _WIN32
+
 /**
  * Creates a new server listening on the given Unix domain socket.
  *
@@ -382,11 +387,94 @@
   return NULL;
 }
 
+#else
+
 /**
- * Creates a new server listening on the given hostname and port.
- * If the hostname is NULL, listens on localhost.
+ * Creates a new server listening on the given Windows named pipe.
  *
- * @param host the hostname to listen on.
+ * @param path the path for the domain socket.
+ * @param abstract #TRUE to use abstract socket namespace
+ * @param error location to store reason for failure.
+ * @returns the new server, or #NULL on failure.
+ */
+DBusServer*
+_dbus_server_new_for_domain_socket (const char     *path,
+                                    dbus_bool_t     abstract,
+                                    DBusError      *error)
+{
+  DBusServer *server;
+  DBusServerUnix *unix_server;
+  int listen_fd;
+  DBusString address;
+  char *path_copy;
+  
+  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
+
+  if (!_dbus_string_init (&address))
+    {
+      _DBUS_SET_OOM (error);
+      return NULL;
+    }
+
+  if ((abstract &&
+       !_dbus_string_append (&address, "unix:abstract=")) ||
+      (!abstract &&
+       !_dbus_string_append (&address, "unix:path=")) ||
+      !_dbus_string_append (&address, path))
+    {
+      _DBUS_SET_OOM (error);
+      goto failed_0;
+    }
+
+  path_copy = _dbus_strdup (path);
+  if (path_copy == NULL)
+    {
+      _DBUS_SET_OOM (error);
+      goto failed_0;
+    }
+  
+  listen_fd = _dbus_listen_unix_socket (path, abstract, error);
+  
+  if (listen_fd < 0)
+    {
+      _DBUS_ASSERT_ERROR_IS_SET (error);
+      goto failed_1;
+    }
+  
+  _dbus_fd_set_close_on_exec (listen_fd);
+  server = _dbus_server_new_for_fd (listen_fd, &address);
+  if (server == NULL)
+    {
+      _DBUS_SET_OOM (error);
+      goto failed_2;
+    }
+
+  unix_server = (DBusServerUnix*) server;
+  unix_server->socket_name = path_copy;
+  
+  _dbus_string_free (&address);
+  
+  return server;
+
+ failed_2:
+  _dbus_close (listen_fd, NULL);
+ failed_1:
+  dbus_free (path_copy);
+ failed_0:
+  _dbus_string_free (&address);
+
+  return NULL;
+}
+
+#endif
+
+
+/**
+ * Creates a new server listening on the given hostname and port.  If
+ * the hostname is NULL, listens on localhost. If the hostname is an
+ * empty string, listens on any local host address.
+ *
+ * @param host the hostname for the address to listen.
  * @param port the port to listen on.
  * @param error location to store reason for failure.
  * @returns the new server, or #NULL on failure.
@@ -419,7 +507,7 @@
       !_dbus_string_append_int (&address, port))
     {
       _dbus_string_free (&address);
-      dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
+      _DBUS_SET_OOM (error);
       return NULL;
     }
   
@@ -436,7 +524,7 @@
   if (server == NULL)
     {
       dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
-      close (listen_fd);
+      _dbus_close (listen_fd, NULL);
       _dbus_string_free (&address);
       return NULL;
     }
Index: dbus/dbus-spawn.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-spawn.c,v
retrieving revision 1.21
diff -u -b -B -r1.21 dbus-spawn.c
--- dbus/dbus-spawn.c	28 Jun 2005 15:14:21 -0000	1.21
+++ dbus/dbus-spawn.c	22 Jun 2006 11:39:17 -0000
@@ -841,6 +841,7 @@
 static void
 do_exec (int                       child_err_report_fd,
 	 char                    **argv,
+	 char                    **envp,
 	 DBusSpawnChildSetupFunc   child_setup,
 	 void                     *user_data)
 {
@@ -872,6 +873,9 @@
     }
 #endif
   
+  if (envp != NULL)
+    execve (argv[0], argv, envp);
+  else
   execv (argv[0], argv);
   
   /* Exec failed */
@@ -1009,10 +1013,16 @@
 }
 
 /**
- * Spawns a new process. The executable name and argv[0]
- * are the same, both are provided in argv[0]. The child_setup
- * function is passed the given user_data and is run in the child
- * just before calling exec().
+ * Spawns a new process. The executable name and argv[0] are the same,
+ * both are provided in argv[0]. The child_setup function is passed
+ * the given user_data and is run in the child just before calling
+ * exec(). This works only on Unix. On Windows, the child_setup
+ * function is run in the same process that calls this function. So
+ * instead of using a child_setup function to modify the environment
+ * variables of the child, create a copy of _environ and modify it,
+ * and pass as envp to this function. Note that it really has to be a
+ * copy, each string in this environment array needs to be allocated
+ * by D-BUS. It will be freed by this function.
  *
  * Also creates a "babysitter" which tracks the status of the
  * child process, advising the parent if the child exits.
@@ -1021,6 +1031,7 @@
  *
  * @param sitter_p return location for babysitter or #NULL
  * @param argv the executable and arguments
+ * @param envp the environment for the child or #NULL to use parent's
  * @param child_setup function to call in child pre-exec()
  * @param user_data user data for setup function
  * @param error error object to be filled in if function fails
@@ -1029,6 +1040,7 @@
 dbus_bool_t
 _dbus_spawn_async_with_babysitter (DBusBabysitter          **sitter_p,
                                    char                    **argv,
+                                   char                    **envp,
                                    DBusSpawnChildSetupFunc   child_setup,
                                    void                     *user_data,
                                    DBusError                *error)
@@ -1142,6 +1154,7 @@
 	{
 	  do_exec (child_err_report_pipe[WRITE_END],
 		   argv,
+		   envp,
 		   child_setup, user_data);
           _dbus_assert_not_reached ("Got to code after exec() - should have exited on error");
 	}
@@ -1153,6 +1166,16 @@
     }
   else
     {      
+      /* Free the envp */
+      if (envp != NULL)
+	{
+	  char **e = envp;
+
+	  while (*e)
+	    dbus_free (*e++);
+	  dbus_free (envp);
+	}
+      
       /* Close the uncared-about ends of the pipes */
       close_and_invalidate (&child_err_report_pipe[WRITE_END]);
       close_and_invalidate (&babysitter_pipe[1]);
@@ -1215,7 +1238,7 @@
   /*** Test launching nonexistent binary */
   
   argv[0] = "/this/does/not/exist/32542sdgafgafdg";
-  if (_dbus_spawn_async_with_babysitter (&sitter, argv,
+  if (_dbus_spawn_async_with_babysitter (&sitter, argv, NULL,
                                          NULL, NULL,
                                          &error))
     {
@@ -1260,7 +1283,7 @@
   /*** Test launching segfault binary */
   
   argv[0] = TEST_SEGFAULT_BINARY;
-  if (_dbus_spawn_async_with_babysitter (&sitter, argv,
+  if (_dbus_spawn_async_with_babysitter (&sitter, argv, NULL,
                                          NULL, NULL,
                                          &error))
     {
@@ -1305,7 +1328,7 @@
   /*** Test launching exit failure binary */
   
   argv[0] = TEST_EXIT_BINARY;
-  if (_dbus_spawn_async_with_babysitter (&sitter, argv,
+  if (_dbus_spawn_async_with_babysitter (&sitter, argv, NULL,
                                          NULL, NULL,
                                          &error))
     {
@@ -1350,7 +1373,7 @@
   /*** Test launching sleeping binary then killing it */
 
   argv[0] = TEST_SLEEP_FOREVER_BINARY;
-  if (_dbus_spawn_async_with_babysitter (&sitter, argv,
+  if (_dbus_spawn_async_with_babysitter (&sitter, argv, NULL,
                                          NULL, NULL,
                                          &error))
     {
Index: dbus/dbus-spawn.h
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-spawn.h,v
retrieving revision 1.7
diff -u -b -B -r1.7 dbus-spawn.h
--- dbus/dbus-spawn.h	9 Sep 2004 10:20:17 -0000	1.7
+++ dbus/dbus-spawn.h	22 Jun 2006 11:39:17 -0000
@@ -37,6 +37,7 @@
 
 dbus_bool_t _dbus_spawn_async_with_babysitter     (DBusBabysitter           **sitter_p,
                                                    char                     **argv,
+                                                   char                     **envp,
                                                    DBusSpawnChildSetupFunc    child_setup,
                                                    void                      *user_data,
                                                    DBusError                 *error);
Index: dbus/dbus-string.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-string.c,v
retrieving revision 1.69
diff -u -b -B -r1.69 dbus-string.c
--- dbus/dbus-string.c	16 Feb 2006 00:43:41 -0000	1.69
+++ dbus/dbus-string.c	22 Jun 2006 11:39:18 -0000
@@ -35,6 +35,11 @@
 /* for DBUS_VA_COPY */
 #include "dbus-sysdeps.h"
 
+#ifdef _WIN32
+/* for alloca */
+#include <malloc.h>
+#endif
+
 /**
  * @defgroup DBusString string class
  * @ingroup  DBusInternals
@@ -1193,7 +1198,6 @@
                                     va_list            args)
 {
   int len;
-  char c;
   va_list args_copy;
 
   DBUS_STRING_PREAMBLE (str);
@@ -1201,7 +1205,34 @@
   DBUS_VA_COPY (args_copy, args);
 
   /* Measure the message length without terminating nul */
+#ifndef _WIN32
+  {
+    char c;
   len = vsnprintf (&c, 1, format, args);
+  }
+#else
+  /* MSVCRT's vsnprintf semantics are a bit different */
+#if 0
+  /* The C library source in the Platform SDK indicates that this
+   * would work, but alas, it doesn't. At least not on Windows
+   * 2000. Presumably those sources correspond to the C library on
+   * some newer or even future Windows version.
+   */
+  len = _vsnprintf (NULL, _DBUS_INT_MAX, format, args);
+#else
+  /* So what the heck, do it like this. Let's hope nobody uses this to
+   * print over a megabyte.
+   */
+  {
+    const int N = 1000000;
+    char *p = alloca (N);
+
+    len = _vsnprintf (p, N, format, args);
+    if (len == -1)
+      return FALSE;
+  }
+#endif
+#endif
 
   if (!_dbus_string_lengthen (str, len))
     {
Index: dbus/dbus-sysdeps-util.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-sysdeps-util.c,v
retrieving revision 1.6
diff -u -b -B -r1.6 dbus-sysdeps-util.c
--- dbus/dbus-sysdeps-util.c	24 Feb 2006 16:13:08 -0000	1.6
+++ dbus/dbus-sysdeps-util.c	22 Jun 2006 11:39:18 -0000
@@ -24,6 +24,7 @@
 #include "dbus-sysdeps.h"
 #include "dbus-internals.h"
 #include "dbus-protocol.h"
+#include "dbus-sockets.h"
 #include "dbus-string.h"
 #define DBUS_USERDB_INCLUDES_PRIVATE 1
 #include "dbus-userdb.h"
@@ -33,15 +34,28 @@
 #include <stdlib.h>
 #include <string.h>
 #include <signal.h>
+#ifdef HAVE_UNISTD_H
 #include <unistd.h>
+#endif
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <sys/stat.h>
+#ifdef HAVE_GRP_H
 #include <grp.h>
-#include <sys/socket.h>
+#endif
 #include <dirent.h>
-#include <sys/un.h>
+
+#ifdef _WIN32
+#include <ctype.h>
+#include <windows.h>
+#include <aclapi.h>
+
+#ifndef F_OK
+#define	F_OK 0
+#endif
+
+#endif
 
 #ifndef O_BINARY
 #define O_BINARY 0
@@ -65,6 +79,8 @@
 		     int               print_pid_fd,
                      DBusError        *error)
 {
+#ifndef _WIN32
+
   const char *s;
   pid_t child_pid;
   int dev_null_fd;
@@ -174,6 +190,14 @@
     _dbus_assert_not_reached ("setsid() failed");
   
   return TRUE;
+
+#else  /* _WIN32 */
+
+  dbus_set_error_const (error, DBUS_ERROR_FAILED,
+			"Not implemented: _dbus_become_daemon\n");
+  return FALSE;
+
+#endif /* _WIN32 */
 }
 
 
@@ -247,6 +271,8 @@
                         dbus_gid_t     gid,
                         DBusError     *error)
 {
+#ifndef _WIN32
+
   /* setgroups() only works if we are a privileged process,
    * so we don't return error on failure; the only possible
    * failure is that we don't have perms to do it.
@@ -277,6 +303,15 @@
     }
   
   return TRUE;
+
+#else  /* Win32 */
+
+  dbus_set_error_const (error, DBUS_ERROR_FAILED,
+			"Not implemented: _dbus_change_identity\n");
+
+  return FALSE;
+
+#endif /* Win32 */
 }
 
 /** Installs a UNIX signal handler
@@ -288,6 +323,7 @@
 _dbus_set_signal_handler (int               sig,
                           DBusSignalHandler handler)
 {
+#ifndef _WIN32
   struct sigaction act;
   sigset_t empty_mask;
   
@@ -296,6 +332,9 @@
   act.sa_mask    = empty_mask;
   act.sa_flags   = 0;
   sigaction (sig,  &act, 0);
+#else
+  /* XXX */
+#endif
 }
 
 
@@ -348,6 +387,7 @@
 _dbus_user_at_console (const char *username,
                        DBusError  *error)
 {
+#ifndef _WIN32
 
   DBusString f;
   dbus_bool_t result;
@@ -378,6 +418,80 @@
   _dbus_string_free (&f);
 
   return result;
+
+#else
+
+  dbus_bool_t retval = FALSE;
+  wchar_t *wusername;
+  DWORD sid_length;
+  PSID user_sid, console_user_sid;
+  HWINSTA winsta;
+
+  wusername = _dbus_win32_utf8_to_utf16 (username, error);
+  if (!wusername)
+    return FALSE;
+
+  if (!_dbus_win32_account_to_sid (wusername, &user_sid, error))
+    goto out0;
+
+  /* Now we have the SID for username. Get the SID of the
+   * user at the "console" (window station WinSta0)
+   */
+  if (!(winsta = OpenWindowStation ("WinSta0", FALSE, READ_CONTROL)))
+    {
+      _dbus_win32_set_error_from_win32_error (error, GetLastError ());
+      goto out2;
+    }
+
+  sid_length = 0;
+  GetUserObjectInformation (winsta, UOI_USER_SID,
+			    NULL, 0, &sid_length);
+  if (sid_length == 0)
+    {
+      /* Nobody is logged on */
+      goto out2;
+    }
+  
+  if (sid_length < 0 || sid_length > 1000)
+    {
+      dbus_set_error_const (error, DBUS_ERROR_FAILED, "Invalid SID length");
+      goto out3;
+    }
+
+  console_user_sid = dbus_malloc (sid_length);
+  if (!console_user_sid)
+    {
+      _DBUS_SET_OOM (error);
+      goto out3;
+    }
+
+  if (!GetUserObjectInformation (winsta, UOI_USER_SID,
+				 console_user_sid, sid_length, &sid_length))
+    {
+      _dbus_win32_set_error_from_win32_error (error, GetLastError ());
+      goto out4;
+    }
+
+  if (!IsValidSid (console_user_sid))
+    {
+      dbus_set_error_const (error, DBUS_ERROR_FAILED, "Invalid SID");
+      goto out4;
+    }
+
+  retval = EqualSid (user_sid, console_user_sid);
+
+ out4:
+  dbus_free (console_user_sid);
+ out3:
+  CloseWindowStation (winsta);
+ out2:
+  dbus_free (user_sid);
+ out0:
+  dbus_free (wusername);
+
+  return retval;
+
+#endif
 }
 
 
@@ -390,10 +504,26 @@
 dbus_bool_t
 _dbus_path_is_absolute (const DBusString *filename)
 {
+#ifndef _WIN32
   if (_dbus_string_get_length (filename) > 0)
     return _dbus_string_get_byte (filename, 0) == '/';
   else
     return FALSE;
+#else
+  if (_dbus_string_get_length (filename) > 0 &&
+      (_dbus_string_get_byte (filename, 0) == '/' ||
+       _dbus_string_get_byte (filename, 0) == '\\'))
+    return TRUE;
+  
+  if (_dbus_string_get_length (filename) >= 3 &&
+      isalpha (_dbus_string_get_byte (filename, 0)) &&
+      _dbus_string_get_byte (filename, 1) == ':' &&
+      (_dbus_string_get_byte (filename, 2) == '/' ||
+       _dbus_string_get_byte (filename, 2) == '\\'))
+    return TRUE;
+
+  return FALSE;
+#endif
 }
 
 /**
@@ -410,12 +540,21 @@
             DBusError        *error)
 {
   const char *filename_c;
+#ifndef _WIN32
   struct stat sb;
+#else
+  WIN32_FILE_ATTRIBUTE_DATA wfad;
+  char *lastdot;
+  DWORD rc;
+  PSID owner_sid, group_sid;
+  PSECURITY_DESCRIPTOR sd;
+#endif
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
   
   filename_c = _dbus_string_get_const_data (filename);
 
+#ifndef _WIN32
   if (stat (filename_c, &sb) < 0)
     {
       dbus_set_error (error, _dbus_error_from_errno (errno),
@@ -431,6 +570,66 @@
   statbuf->atime = sb.st_atime;
   statbuf->mtime = sb.st_mtime;
   statbuf->ctime = sb.st_ctime;
+#else
+  if (!GetFileAttributesEx (filename_c, GetFileExInfoStandard, &wfad))
+    {
+      _dbus_win32_set_error_from_win32_error (error, GetLastError ());
+      return FALSE;
+    }
+
+  if (wfad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
+    statbuf->mode = _S_IFDIR;
+  else
+    statbuf->mode = _S_IFREG;
+
+  statbuf->mode |= _S_IREAD;
+  if (wfad.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
+    statbuf->mode |= _S_IWRITE;
+
+  lastdot = strrchr (filename_c, '.');
+  if (lastdot && stricmp (lastdot, ".exe") == 0)
+    statbuf->mode |= _S_IEXEC;
+
+  statbuf->mode |= (statbuf->mode & 0700) >> 3;
+  statbuf->mode |= (statbuf->mode & 0700) >> 6;
+
+  statbuf->nlink = 1;
+    
+  sd = NULL;
+  rc = GetNamedSecurityInfo ((char *) filename_c, SE_FILE_OBJECT,
+			     OWNER_SECURITY_INFORMATION |
+			     GROUP_SECURITY_INFORMATION,
+			     &owner_sid, &group_sid,
+			     NULL, NULL,
+			     &sd);
+  if (rc != ERROR_SUCCESS)
+    {
+      _dbus_win32_set_error_from_win32_error (error, rc);
+      if (sd != NULL)
+	LocalFree (sd);
+      return FALSE;
+    }
+
+  statbuf->uid = _dbus_win32_sid_to_uid_t (owner_sid);
+  statbuf->gid = _dbus_win32_sid_to_uid_t (group_sid);
+
+  LocalFree (sd);
+			
+  statbuf->size = ((dbus_int64_t) wfad.nFileSizeHigh << 32) + wfad.nFileSizeLow;
+  
+  statbuf->atime =
+    (((dbus_int64_t) wfad.ftLastAccessTime.dwHighDateTime << 32) +
+     wfad.ftLastAccessTime.dwLowDateTime) / 10000000 - DBUS_INT64_CONSTANT (116444736000000000);
+
+  statbuf->mtime = 
+    (((dbus_int64_t) wfad.ftLastWriteTime.dwHighDateTime << 32) +
+     wfad.ftLastWriteTime.dwLowDateTime) / 10000000 - DBUS_INT64_CONSTANT (116444736000000000);
+
+  statbuf->ctime =
+    (((dbus_int64_t) wfad.ftCreationTime.dwHighDateTime << 32) +
+     wfad.ftCreationTime.dwLowDateTime) / 10000000 - DBUS_INT64_CONSTANT (116444736000000000);
+  
+#endif
 
   return TRUE;
 }
@@ -465,6 +664,7 @@
   filename_c = _dbus_string_get_const_data (filename);
 
   d = opendir (filename_c);
+  _dbus_verbose ("opendir %s = %p\n", filename_c, d);
   if (d == NULL)
     {
       dbus_set_error (error, _dbus_error_from_errno (errno),
@@ -512,6 +712,7 @@
  again:
   errno = 0;
   ent = readdir (iter->d);
+  _dbus_verbose ("readdir: %s\n", ent ? ent->d_name: "NULL");
   if (ent == NULL)
     {
       if (errno != 0)
@@ -548,6 +749,8 @@
   dbus_free (iter);
 }
 
+#ifndef _WIN32
+
 static dbus_bool_t
 fill_user_info_from_group (struct group  *g,
                            DBusGroupInfo *info,
@@ -569,6 +772,8 @@
   return TRUE;
 }
 
+#endif
+
 static dbus_bool_t
 fill_group_info (DBusGroupInfo    *info,
                  dbus_gid_t        gid,
@@ -577,14 +782,16 @@
 {
   const char *group_c_str;
 
-  _dbus_assert (groupname != NULL || gid != DBUS_GID_UNSET);
-  _dbus_assert (groupname == NULL || gid == DBUS_GID_UNSET);
+  _dbus_assert (groupname != NULL || !DBUS_GID_EQUAL (gid, DBUS_GID_UNSET));
+  _dbus_assert (groupname == NULL || DBUS_GID_EQUAL (gid, DBUS_GID_UNSET));
 
   if (groupname)
     group_c_str = _dbus_string_get_const_data (groupname);
   else
     group_c_str = NULL;
   
+#ifndef _WIN32
+
   /* For now assuming that the getgrnam() and getgrgid() flavors
    * always correspond to the pwnam flavors, if not we have
    * to add more configure checks.
@@ -642,6 +849,67 @@
       }
   }
 #endif  /* ! HAVE_GETPWNAM_R */
+#else  /* Win32 */
+
+  if (group_c_str)
+    {
+      PSID group_sid;
+      wchar_t *wgroupname = _dbus_win32_utf8_to_utf16 (group_c_str, error);
+
+      if (!wgroupname)
+	return FALSE;
+
+      if (!_dbus_win32_account_to_sid (wgroupname, &group_sid, error))
+	{
+	  dbus_free (wgroupname);
+	  return FALSE;
+	}
+
+      info->gid = _dbus_win32_sid_to_uid_t (group_sid);
+      info->groupname = _dbus_strdup (group_c_str);
+
+      dbus_free (group_sid);
+      dbus_free (wgroupname);
+
+      return TRUE;
+    }
+  else
+    {
+      dbus_bool_t retval = FALSE;
+      wchar_t *wname, *wdomain;
+      char *name, *domain;
+
+      info->gid = gid;
+
+      if (!_dbus_win32_sid_to_name_and_domain (gid, &wname, &wdomain, error))
+	return FALSE;
+
+      name = _dbus_win32_utf16_to_utf8 (wname, error);
+      if (!name)
+	goto out0;
+      
+      domain = _dbus_win32_utf16_to_utf8 (wdomain, error);
+      if (!domain)
+	goto out1;
+
+      info->groupname = dbus_malloc (strlen (domain) + 1 + strlen (name) + 1);
+
+      strcpy (info->groupname, domain);
+      strcat (info->groupname, "\\");
+      strcat (info->groupname, name);
+
+      retval = TRUE;
+
+      dbus_free (domain);
+    out1:
+      dbus_free (name);
+    out0:
+      dbus_free (wname);
+      dbus_free (wdomain);
+
+      return retval;
+    }
+#endif /* Win32 */
 }
 
 /**
@@ -708,6 +976,8 @@
   if (sep == 0)
     return _dbus_string_append (dirname, "."); /* empty string passed in */
     
+#ifndef _WIN32
+
   while (sep > 0 && _dbus_string_get_byte (filename, sep - 1) == '/')
     --sep;
 
@@ -733,6 +1003,52 @@
   else
     return _dbus_string_copy_len (filename, 0, sep - 0,
                                   dirname, _dbus_string_get_length (dirname));
+#else
+  
+  while (sep > 0 &&
+	 (_dbus_string_get_byte (filename, sep - 1) == '/' ||
+	  _dbus_string_get_byte (filename, sep - 1) == '\\'))
+    --sep;
+
+  _dbus_assert (sep >= 0);
+  
+  if (sep == 0 ||
+      (sep == 2 &&
+       _dbus_string_get_byte (filename, 1) == ':' &&
+       isalpha (_dbus_string_get_byte (filename, 0))))
+    return _dbus_string_copy_len (filename, 0, sep + 1,
+				  dirname, _dbus_string_get_length (dirname));
+
+  {
+    int sep1, sep2;
+    _dbus_string_find_byte_backward (filename, sep, '/', &sep1);
+    _dbus_string_find_byte_backward (filename, sep, '\\', &sep2);
+
+    sep = MAX (sep1, sep2);
+  }
+  if (sep < 0)
+    return _dbus_string_append (dirname, ".");
+  
+  while (sep > 0 &&
+	 (_dbus_string_get_byte (filename, sep - 1) == '/' ||
+	  _dbus_string_get_byte (filename, sep - 1) == '\\'))
+    --sep;
+
+  _dbus_assert (sep >= 0);
+  
+  if ((sep == 0 ||
+       (sep == 2 &&
+	_dbus_string_get_byte (filename, 1) == ':' &&
+	isalpha (_dbus_string_get_byte (filename, 0))))
+      &&
+      (_dbus_string_get_byte (filename, sep) == '/' ||
+       _dbus_string_get_byte (filename, sep) == '\\'))
+    return _dbus_string_copy_len (filename, 0, sep + 1,
+				  dirname, _dbus_string_get_length (dirname));
+  else
+    return _dbus_string_copy_len (filename, 0, sep - 0,
+                                  dirname, _dbus_string_get_length (dirname));
+#endif
 }
 /** @} */ /* DBusString stuff */
 
@@ -812,6 +1128,26 @@
   check_dirname ("///", "/");
   check_dirname ("", ".");  
 
+#ifdef _WIN32
+  check_dirname ("foo\\bar", "foo");
+  check_dirname ("foo\\\\bar", "foo");
+  check_dirname ("foo/\\/bar", "foo");
+  check_dirname ("foo\\bar/", "foo");
+  check_dirname ("foo//bar\\", "foo");
+  check_dirname ("foo\\bar/", "foo");
+  check_dirname ("foo/bar\\\\", "foo");
+  check_dirname ("\\foo", "\\");
+  check_dirname ("\\\\foo", "\\");
+  check_dirname ("\\", "\\");
+  check_dirname ("\\\\", "\\");
+  check_dirname ("\\/", "\\");
+  check_dirname ("/\\/", "/");
+  check_dirname ("a:\\foo\\bar", "a:\\foo");
+  check_dirname ("a:\\foo", "a:\\");
+  check_dirname ("a:/foo", "a:/");
+  check_dirname ("a:\\", "a:\\");
+  check_dirname ("a:/", "a:/");
+#endif
 
   _dbus_string_init_const (&str, "3.5");
   if (!_dbus_string_parse_double (&str,
@@ -831,6 +1167,7 @@
       exit (1);
     }
 
+#ifndef _WIN32
   _dbus_string_init_const (&str, "0xff");
   if (!_dbus_string_parse_double (&str,
 				  0, &val, &pos))
@@ -848,12 +1185,23 @@
       _dbus_warn ("_dbus_string_parse_double of \"0xff\" returned wrong position %d", pos);
       exit (1);
     }
+#endif
   
   check_path_absolute ("/", TRUE);
   check_path_absolute ("/foo", TRUE);
   check_path_absolute ("", FALSE);
   check_path_absolute ("foo", FALSE);
   check_path_absolute ("foo/bar", FALSE);
+#ifdef _WIN32
+  check_path_absolute ("\\", TRUE);
+  check_path_absolute ("\\foo", TRUE);
+  check_path_absolute ("", FALSE);
+  check_path_absolute ("foo\\bar", FALSE);
+  check_path_absolute ("a:\\", TRUE);
+  check_path_absolute ("a:\\foo", TRUE);
+  check_path_absolute ("a:", FALSE);
+  check_path_absolute ("a:foo\\bar", FALSE);
+#endif
   
   return TRUE;
 }
Index: dbus/dbus-sysdeps.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-sysdeps.c,v
retrieving revision 1.102
diff -u -b -B -r1.102 dbus-sysdeps.c
--- dbus/dbus-sysdeps.c	30 May 2006 15:34:10 -0000	1.102
+++ dbus/dbus-sysdeps.c	22 Jun 2006 11:39:20 -0000
@@ -3,6 +3,7 @@
  * 
  * Copyright (C) 2002, 2003  Red Hat, Inc.
  * Copyright (C) 2003 CodeFactory AB
+ * Copyright (C) 2005 Novell, Inc.
  *
  * Licensed under the Academic Free License version 2.1
  * 
@@ -26,28 +27,37 @@
 #include "dbus-sysdeps.h"
 #include "dbus-threads.h"
 #include "dbus-protocol.h"
+#include "dbus-hash.h"
+#include "dbus-sockets.h"
 #include "dbus-string.h"
 #include <sys/types.h>
 #include <stdlib.h>
 #include <string.h>
 #include <signal.h>
-#include <unistd.h>
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
-#include <sys/socket.h>
 #include <dirent.h>
-#include <sys/un.h>
+#include <locale.h>
+#include <sys/stat.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_GRP_H
+#include <grp.h>
+#endif
+#ifdef HAVE_PWD_H
 #include <pwd.h>
+#endif
+#ifdef HAVE_TIME_H
 #include <time.h>
-#include <locale.h>
+#endif
+#ifdef HAVE_SYS_TIME_H
 #include <sys/time.h>
-#include <sys/stat.h>
+#endif
+#ifdef HAVE_SYS_WAIT_H
 #include <sys/wait.h>
-#include <netinet/in.h>
-#include <netdb.h>
-#include <grp.h>
-
+#endif
 #ifdef HAVE_WRITEV
 #include <sys/uio.h>
 #endif
@@ -60,7 +70,28 @@
 #ifdef HAVE_GETPEERUCRED
 #include <ucred.h>
 #endif
+#ifdef _WIN32
+#include <ctype.h>
+#include <malloc.h>
+#include <windows.h>
+#include <aclapi.h>
+#include <lm.h>
+
+/* Declarations missing in mingw's headers */
+extern BOOL WINAPI ConvertStringSidToSidA (LPCSTR  StringSid,
+					   PSID   *Sid);
+extern BOOL WINAPI ConvertSidToStringSidA (PSID    Sid,
+					   LPSTR  *StringSid);
+#include <io.h>
+#include <share.h>
+
+#define mkdir(path, mode) _mkdir (path)
+
+#ifndef S_ISREG
+#define	S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)
+#endif
 
+#endif
 #ifndef O_BINARY
 #define O_BINARY 0
 #endif
@@ -69,6 +100,67 @@
 #define socklen_t int
 #endif
 
+#ifdef _WIN32
+
+typedef enum
+{
+  DBUS_WIN32_FD_UNUSED,
+  DBUS_WIN32_FD_BEING_OPENED,
+  DBUS_WIN32_FD_C_LIB,		/* Unix-style file descriptor
+				 * (implemented by the C runtime)
+				 */
+  DBUS_WIN32_FD_SOCKET,		/* Winsock SOCKET */
+  DBUS_WIN32_FD_NAMED_PIPE_HANDLE
+				/* HANDLE for a named pipe */
+} DBusWin32FDType;
+
+typedef struct
+{
+  DBusWin32FDType type;
+  int fd;			/* File descriptor, SOCKET or file HANDLE */
+  int port_file_fd;		/* File descriptor for file containing
+				 * port number for "pseudo-unix" sockets
+				 */
+  DBusString port_file;		/* File name for said file */
+  dbus_bool_t close_on_exec;
+  dbus_bool_t non_blocking;
+} DBusWin32FD;
+
+static DBusWin32FD *win32_fds = NULL;
+static int win32_n_fds = 0;
+
+_DBUS_DEFINE_GLOBAL_LOCK (win32_fds);
+
+static DBusHashTable *win32_sids = NULL;
+
+_DBUS_DEFINE_GLOBAL_LOCK (win32_sids);
+
+static int  win32_encap_randomizer;
+
+#if 0
+#define RANDOMIZE(n) ((n)^win32_encap_randomizer)
+#define UNRANDOMIZE(n) ((n)^win32_encap_randomizer)
+#else
+#define RANDOMIZE(n) ((n)+1000)
+#define UNRANDOMIZE(n) ((n)-1000)
+#endif
+
+static int  _dbus_win32_allocate_fd (void);
+static void _dbus_win32_deallocate_fd (int fd);
+static void _dbus_win32_startup_winsock (void);
+static void _dbus_win32_warn_win32_error (const char *message,
+					  int         code);
+
+#define _dbus_decapsulate_quick(i) win32_fds[UNRANDOMIZE (i)].fd
+
+const char*
+_dbus_lm_strerror(int error_number);
+#else
+
+#define _dbus_decapsulate_quick(i) (i)
+
+#endif
+
 /**
  * @addtogroup DBusInternalsUtils
  * @{
@@ -86,6 +178,10 @@
   if (s && *s)
     _dbus_print_backtrace ();
 #endif
+#if defined (_WIN32) && defined (__GNUC__)
+  if (IsDebuggerPresent ())
+    __asm__ __volatile__ ("int $03");
+#endif
   abort ();
   _exit (1); /* in case someone manages to ignore SIGABRT */
 }
@@ -123,11 +219,14 @@
        * will get upset about.
        */
       
-      putenv_value = malloc (len + 1);
+      putenv_value = malloc (len + 2);
       if (putenv_value == NULL)
         return FALSE;
 
       strcpy (putenv_value, varname);
+#ifdef _WIN32
+      strcat (putenv_value, "=");
+#endif
       
       return (putenv (putenv_value) == 0);
 #endif
@@ -194,6 +293,9 @@
             DBusString       *buffer,
             int               count)
 {
+#ifdef _WIN32
+  DBusWin32FDType type;
+#endif
   int bytes_read;
   int start;
   char *data;
@@ -210,21 +312,64 @@
 
   data = _dbus_string_get_data_len (buffer, start, count);
 
- again:
+#ifndef _WIN32
   
+ again:
   bytes_read = read (fd, data, count);
 
-  if (bytes_read < 0)
-    {
-      if (errno == EINTR)
+  if (bytes_read < 0 && errno == EINTR)
         goto again;
+
+#else
+
+  _DBUS_LOCK (win32_fds);
+
+  fd = UNRANDOMIZE (fd);
+
+  _dbus_assert (fd >= 0 && fd < win32_n_fds);
+  _dbus_assert (win32_fds != NULL);
+
+  type = win32_fds[fd].type;
+  fd = win32_fds[fd].fd;
+
+  _DBUS_UNLOCK (win32_fds);
+    
+  switch (type)
+    {
+    case DBUS_WIN32_FD_SOCKET:
+      _dbus_verbose ("recv: count=%d socket=%d\n", count, fd);
+      bytes_read = recv (fd, data, count, 0);
+      if (bytes_read == SOCKET_ERROR)
+	{
+	  DBUS_SOCKET_SET_ERRNO();
+	  _dbus_verbose ("recv: failed: %s\n", _dbus_strerror (errno));
+	  bytes_read = -1;
+	}
+      else
+	_dbus_verbose ("recv: = %d\n", bytes_read); 
+      break;
+
+    case DBUS_WIN32_FD_C_LIB:
+      _dbus_verbose ("read: count=%d fd=%d\n", count, fd);
+      bytes_read = read (fd, data, count);
+      if (bytes_read == -1)
+	_dbus_verbose ("read: failed: %s\n", _dbus_strerror (errno));
       else
+	_dbus_verbose ("read: = %d\n", bytes_read); 
+      break;
+
+    default:
+      _dbus_assert_not_reached ("unhandled fd type");
+    }
+
+#endif
+
+  if (bytes_read < 0)
         {
           /* put length back (note that this doesn't actually realloc anything) */
           _dbus_string_set_length (buffer, start);
           return -1;
         }
-    }
   else
     {
       /* put length back (doesn't actually realloc) */
@@ -255,18 +400,66 @@
              int               start,
              int               len)
 {
+#ifdef _WIN32
+  DBusWin32FDType type;
+#endif
   const char *data;
   int bytes_written;
   
   data = _dbus_string_get_const_data_len (buffer, start, len);
   
- again:
+#ifndef _WIN32
 
+ again:
   bytes_written = write (fd, data, len);
 
   if (bytes_written < 0 && errno == EINTR)
     goto again;
 
+#else
+
+  _DBUS_LOCK (win32_fds);
+
+  fd = UNRANDOMIZE (fd);
+
+  _dbus_assert (fd >= 0 && fd < win32_n_fds);
+  _dbus_assert (win32_fds != NULL);
+
+  type = win32_fds[fd].type;
+  fd = win32_fds[fd].fd;
+
+  _DBUS_UNLOCK (win32_fds);
+
+  switch (type)
+    {
+    case DBUS_WIN32_FD_SOCKET:
+      _dbus_verbose ("send: len=%d socket=%d\n", len, fd);
+      bytes_written = send (fd, data, len, 0);
+      if (bytes_written == SOCKET_ERROR)
+	{
+	  DBUS_SOCKET_SET_ERRNO();
+	  _dbus_verbose ("send: failed: %s\n", _dbus_strerror (errno));
+	  bytes_written = -1;
+	}
+      else
+	_dbus_verbose ("send: = %d\n", bytes_written); 
+      break;
+
+    case DBUS_WIN32_FD_C_LIB:
+      _dbus_verbose ("write: len=%d fd=%d\n", len, fd);
+      bytes_written = write (fd, data, len);
+      if (bytes_written == -1)
+	_dbus_verbose ("write: failed: %s\n", _dbus_strerror (errno));
+      else
+	_dbus_verbose ("write: = %d\n", bytes_written); 
+      break;
+
+    default:
+      _dbus_assert_not_reached ("unhandled fd type");
+    }
+
+#endif
+
 #if 0
   if (bytes_written > 0)
     _dbus_verbose_bytes_of_string (buffer, start, bytes_written);
@@ -304,12 +497,24 @@
                  int               start2,
                  int               len2)
 {
+#ifdef _WIN32
+  DBusWin32FDType type;
+  WSABUF vectors[2];
+  const char *data1;
+  const char *data2;
+  int rc;
+  DWORD bytes_written;
+  int ret1;
+#endif
+
   _dbus_assert (buffer1 != NULL);
   _dbus_assert (start1 >= 0);
   _dbus_assert (start2 >= 0);
   _dbus_assert (len1 >= 0);
   _dbus_assert (len2 >= 0);
   
+#ifndef _WIN32
+
 #ifdef HAVE_WRITEV
   {
     struct iovec vectors[2];
@@ -351,7 +556,7 @@
     ret1 = _dbus_write (fd, buffer1, start1, len1);
     if (ret1 == len1 && buffer2 != NULL)
       {
-        ret2 = _dbus_write (fd, buffer2, start2, len2);
+        int ret2 = _dbus_write (fd, buffer2, start2, len2);
         if (ret2 < 0)
           ret2 = 0; /* we can't report an error as the first write was OK */
        
@@ -361,6 +566,70 @@
       return ret1;
   }
 #endif /* !HAVE_WRITEV */   
+
+#else  /* Win32 */
+
+  _DBUS_LOCK (win32_fds);
+
+  fd = UNRANDOMIZE (fd);
+
+  _dbus_assert (fd >= 0 && fd < win32_n_fds);
+  _dbus_assert (win32_fds != NULL);
+
+  type = win32_fds[fd].type;
+  fd = win32_fds[fd].fd;
+
+  _DBUS_UNLOCK (win32_fds);
+
+  data1 = _dbus_string_get_const_data_len (buffer1, start1, len1);
+  
+  if (buffer2 != NULL)
+    data2 = _dbus_string_get_const_data_len (buffer2, start2, len2);
+  else
+    {
+      data2 = NULL;
+      start2 = 0;
+      len2 = 0;
+    }
+   
+  switch (type)
+    {
+    case DBUS_WIN32_FD_SOCKET:
+      vectors[0].buf = (char*) data1;
+      vectors[0].len = len1;
+      vectors[1].buf = (char*) data2;
+      vectors[1].len = len2;
+      
+      _dbus_verbose ("WSASend: len1+2=%d+%d socket=%d\n", len1, len2, fd);
+      rc = WSASend (fd, vectors, data2 ? 2 : 1, &bytes_written,
+		    0, NULL, NULL);
+      if (rc < 0)
+	{
+	  DBUS_SOCKET_SET_ERRNO ();
+	  _dbus_verbose ("WSASend: failed: %s\n", _dbus_strerror (errno));
+	  bytes_written = -1;
+	}
+      else
+	_dbus_verbose ("WSASend: = %ld\n", bytes_written);
+      return bytes_written;
+
+    case DBUS_WIN32_FD_C_LIB:
+      ret1 = _dbus_write (fd, buffer1, start1, len1);
+      if (ret1 == len1 && buffer2 != NULL)
+	{
+	  int ret2 = _dbus_write (fd, buffer2, start2, len2);
+	  if (ret2 < 0)
+	    ret2 = 0; /* we can't report an error as the first write was OK */
+       
+	  return ret1 + ret2;
+	}
+      else
+	return ret1;
+
+    default:
+      _dbus_assert_not_reached ("unhandled fd type");
+    }
+#endif
 }
 
 #define _DBUS_MAX_SUN_PATH_LENGTH 99
@@ -383,6 +652,10 @@
  * given path.  The connection fd is returned, and is set up as
  * nonblocking.
  * 
+ * On Windows there are no UNIX domain sockets. Instead, connects to a
+ * localhost-bound TCP socket, whose port number is stored in a file
+ * at the given path.
+ * 
  * Uses abstract sockets instead of filesystem-linked sockets if
  * requested (it's possible only on Linux; see "man 7 unix" on Linux).
  * On non-Linux abstract socket usage always fails.
@@ -397,6 +670,8 @@
                            dbus_bool_t     abstract,
                            DBusError      *error)
 {
+#ifndef _WIN32
+
   int fd;
   size_t path_len;
   struct sockaddr_un addr;  
@@ -482,8 +757,82 @@
     }
 
   return fd;
+
+#else  /* Win32 */
+
+  int fd, n, port;
+  char buf[7];
+
+  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
+
+  _dbus_verbose ("connecting to pseudo-unix socket at %s\n",
+                 path);
+  
+  if (abstract)
+    {
+      dbus_set_error (error, DBUS_ERROR_NOT_SUPPORTED,
+                      "Implementation does not support abstract socket namespace\n");
+      return -1;
+    }
+    
+  fd = _sopen (path, O_RDONLY, SH_DENYNO);
+
+  if (fd == -1)
+    {
+      dbus_set_error (error, _dbus_error_from_errno (errno),
+		      "Failed to open file %s: %s",
+		      path, _dbus_strerror (errno));
+      return -1;
+    }
+
+  n = read (fd, buf, sizeof (buf) - 1);
+  close (fd);
+
+  if (n == 0)
+    {
+      dbus_set_error (error, DBUS_ERROR_FAILED,
+		      "Failed to read port number from file %s",
+		      path);
+      return -1;
+    }
+
+  buf[n] = '\0';
+  port = atoi (buf);
+
+  if (port <= 0 || port > 0xFFFF)
+    {
+      dbus_set_error (error, DBUS_ERROR_FAILED,
+		      "Invalid port numer in file %s",
+		      path);
+      return -1;
+    }
+ 
+  return _dbus_connect_tcp_socket (NULL, port, error);
+
+#endif /* Win32 */
+}
+
+#ifdef _WIN32
+#if 0
+
+/**
+ * Opens the client side of a Windows named pipe. The connection D-BUS
+ * file descriptor index is returned. It is set up as nonblocking.
+ * 
+ * @param path the path to named pipe socket
+ * @param error return location for error code
+ * @returns connection D-BUS file descriptor or -1 on error
+ */
+int
+_dbus_connect_named_pipe (const char     *path,
+			  DBusError      *error)
+{
+  _dbus_assert_not_reached ("not implemented");
 }
 
+#endif
+#endif
+
 /**
  * Creates a socket and binds it to the given path,
  * then listens on the socket. The socket is
@@ -504,6 +853,8 @@
                           dbus_bool_t     abstract,
                           DBusError      *error)
 {
+#ifndef _WIN32
+
   int listen_fd;
   struct sockaddr_un addr;
   size_t path_len;
@@ -617,8 +968,114 @@
                 path);
   
   return listen_fd;
+
+#else  /* Win32 */
+
+  int listen_fd;
+  SOCKET sock;
+  struct sockaddr sa;
+  int addr_len;
+  int filefd;
+  int n, l;
+  DBusString portstr;
+
+  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
+
+  _dbus_verbose ("listening on pseudo-unix socket at %s\n",
+                 path);
+
+  if (abstract)
+    {
+      dbus_set_error (error, DBUS_ERROR_NOT_SUPPORTED,
+                      "Implementation does not support abstract socket namespace\n");
+      return -1;
+    }
+    
+  listen_fd = _dbus_listen_tcp_socket (NULL, 0, error);
+
+  if (listen_fd == -1)
+    return -1;
+
+  sock = win32_fds[UNRANDOMIZE (listen_fd)].fd;
+
+  addr_len = sizeof (sa);
+  if (getsockname (sock, &sa, &addr_len) == SOCKET_ERROR)
+    {
+      DBUS_SOCKET_SET_ERRNO ();
+      dbus_set_error (error, _dbus_error_from_errno (errno),
+		      "getsockname failed: %s",
+		      _dbus_strerror (errno));
+      _dbus_close (listen_fd, NULL);
+      return -1;
+    }
+
+  _dbus_assert (((struct sockaddr_in*) &sa)->sin_family == AF_INET);
+
+  filefd = _sopen (path, O_CREAT|O_WRONLY|_O_SHORT_LIVED, SH_DENYWR, 0666);
+
+  if (filefd == -1)
+    {
+      dbus_set_error (error, _dbus_error_from_errno (errno),
+		      "Failed to create pseudo-unix socket port number file %s: %s",
+		      path, _dbus_strerror (errno));
+      _dbus_close (listen_fd, NULL);
+      return -1;
+    }
+
+  win32_fds[UNRANDOMIZE (listen_fd)].port_file_fd = filefd;
+
+  /* Use strdup() to avoid memory leak in dbus-test */
+  path = strdup (path);
+  if (!path)
+    {
+      _DBUS_SET_OOM (error);
+      _dbus_close (listen_fd, NULL);
+      return -1;
+    }
+
+  _dbus_string_init_const (&win32_fds[UNRANDOMIZE (listen_fd)].port_file, path);
+
+  if (!_dbus_string_init (&portstr))
+    {
+      _DBUS_SET_OOM (error);
+      _dbus_close (listen_fd, NULL);
+      return -1;
+    }
+
+  if (!_dbus_string_append_int (&portstr, ntohs (((struct sockaddr_in*) &sa)->sin_port)))
+    {
+      _DBUS_SET_OOM (error);
+      _dbus_close (listen_fd, NULL);
+      return -1;
+    }
+
+  l = _dbus_string_get_length (&portstr);
+  n = write (filefd, _dbus_string_get_const_data (&portstr), l);
+  _dbus_string_free (&portstr);
+
+  if (n == -1)
+    {
+      dbus_set_error (error, _dbus_error_from_errno (errno),
+		      "Failed to write port number to file %s: %s",
+		      path, _dbus_strerror (errno));
+      _dbus_close (listen_fd, NULL);
+      return -1;
+    }
+  else if (n < l)
+    {
+      dbus_set_error (error, _dbus_error_from_errno (errno),
+		      "Failed to write port number to file %s",
+		      path);
+      _dbus_close (listen_fd, NULL);
+      return -1;
+    }
+
+  return listen_fd;
+
+#endif /* Win32 */
 }
 
+
 /**
  * Creates a socket and connects to a socket at the given host 
  * and port. The connection fd is returned, and is set up as
@@ -624,7 +1081,7 @@
  * and port. The connection fd is returned, and is set up as
  * nonblocking.
  *
- * @param host the host name to connect to
+ * @param host the host name to connect to, NULL for loopback
  * @param port the prot to connect to
  * @param error return location for error code
  * @returns connection file descriptor or -1 on error
@@ -637,14 +1094,19 @@
   int fd;
   struct sockaddr_in addr;
   struct hostent *he;
-  struct in_addr *haddr;
+  struct in_addr ina, *haddr;
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
   
+#ifdef _WIN32
+  _dbus_win32_startup_winsock ();
+#endif
+
   fd = socket (AF_INET, SOCK_STREAM, 0);
   
-  if (fd < 0)
+  if (DBUS_SOCKET_IS_INVALID (fd))
     {
+      DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error,
                       _dbus_error_from_errno (errno),
                       "Failed to create socket: %s",
@@ -654,43 +1116,54 @@
     }
 
   if (host == NULL)
+    {
     host = "localhost";
-
+      ina.s_addr = htonl (INADDR_LOOPBACK);
+      haddr = &ina;
+    }
+  else
+    {
   he = gethostbyname (host);
   if (he == NULL) 
     {
+	  DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error,
                       _dbus_error_from_errno (errno),
                       "Failed to lookup hostname: %s",
                       host);
-      close (fd);
+	  DBUS_CLOSE_SOCKET (fd);
       return -1;
     }
   
   haddr = ((struct in_addr *) (he->h_addr_list)[0]);
+    }
 
   _DBUS_ZERO (addr);
   memcpy (&addr.sin_addr, haddr, sizeof(struct in_addr));
   addr.sin_family = AF_INET;
   addr.sin_port = htons (port);
   
-  if (connect (fd, (struct sockaddr*) &addr, sizeof (addr)) < 0)
+  if (DBUS_SOCKET_API_RETURNS_ERROR (connect (fd,
+					      (struct sockaddr*) &addr,
+					      sizeof (addr))))
     {      
+      DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error,
                        _dbus_error_from_errno (errno),
                       "Failed to connect to socket %s:%d %s",
                       host, port, _dbus_strerror (errno));
 
-      close (fd);
+      DBUS_CLOSE_SOCKET (fd);
       fd = -1;
       
       return -1;
     }
 
+  fd = _dbus_encapsulate_socket (fd);
+
   if (!_dbus_set_fd_nonblocking (fd, error))
     {
-      close (fd);
-      fd = -1;
+      _dbus_close (fd, NULL);
 
       return -1;
     }
@@ -699,12 +1172,12 @@
 }
 
 /**
- * Creates a socket and binds it to the given path,
+ * Creates a socket and binds it to the given port,
  * then listens on the socket. The socket is
  * set to be nonblocking. 
  *
- * @param host the host name to listen on
- * @param port the prot to listen on
+ * @param host the interface to listen on, NULL for loopback, empty for any
+ * @param port the port to listen on
  * @param error return location for errors
  * @returns the listening file descriptor or -1 on error
  */
@@ -716,32 +1189,52 @@
   int listen_fd;
   struct sockaddr_in addr;
   struct hostent *he;
-  struct in_addr *haddr;
+  struct in_addr ina, *haddr;
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
   
+#ifdef _WIN32
+  _dbus_win32_startup_winsock ();
+#endif
+
   listen_fd = socket (AF_INET, SOCK_STREAM, 0);
   
-  if (listen_fd < 0)
+  if (DBUS_SOCKET_IS_INVALID (listen_fd))
     {
+      DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error, _dbus_error_from_errno (errno),
                       "Failed to create socket \"%s:%d\": %s",
                       host, port, _dbus_strerror (errno));
       return -1;
     }
 
+  if (host == NULL)
+    {
+      host = "localhost";
+      ina.s_addr = htonl (INADDR_LOOPBACK);
+      haddr = &ina;
+    }
+  else if (!host[0])
+    {
+      ina.s_addr = htonl (INADDR_ANY);
+      haddr = &ina;
+    }
+  else
+    {
   he = gethostbyname (host);
   if (he == NULL) 
     {
+	  DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error,
                       _dbus_error_from_errno (errno),
                       "Failed to lookup hostname: %s",
                       host);
-      close (listen_fd);
+	  DBUS_CLOSE_SOCKET (listen_fd);
       return -1;
     }
   
   haddr = ((struct in_addr *) (he->h_addr_list)[0]);
+    }
 
   _DBUS_ZERO (addr);
   memcpy (&addr.sin_addr, haddr, sizeof (struct in_addr));
@@ -750,25 +1243,29 @@
 
   if (bind (listen_fd, (struct sockaddr*) &addr, sizeof (struct sockaddr)))
     {
+      DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error, _dbus_error_from_errno (errno),
                       "Failed to bind socket \"%s:%d\": %s",
                       host, port, _dbus_strerror (errno));
-      close (listen_fd);
+      DBUS_CLOSE_SOCKET (listen_fd);
       return -1;
     }
 
-  if (listen (listen_fd, 30 /* backlog */) < 0)
+  if (DBUS_SOCKET_API_RETURNS_ERROR (listen (listen_fd, 30 /* backlog */)))
     {
+      DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error, _dbus_error_from_errno (errno),  
                       "Failed to listen on socket \"%s:%d\": %s",
                       host, port, _dbus_strerror (errno));
-      close (listen_fd);
+      DBUS_CLOSE_SOCKET (listen_fd);
       return -1;
     }
 
+  listen_fd = _dbus_encapsulate_socket (listen_fd);
+
   if (!_dbus_set_fd_nonblocking (listen_fd, error))
     {
-      close (listen_fd);
+      _dbus_close (listen_fd, NULL);
       return -1;
     }
   
@@ -779,6 +1276,8 @@
 write_credentials_byte (int             server_fd,
                         DBusError      *error)
 {
+#ifndef _WIN32
+
   int bytes_written;
   char buf[1] = { '\0' };
 #if defined(HAVE_CMSGCRED) && !defined(LOCAL_CREDS)
@@ -838,6 +1337,33 @@
       _dbus_verbose ("wrote credentials byte\n");
       return TRUE;
     }
+
+#else  /* Win32 */
+
+  /* FIXME: for the session bus credentials shouldn't matter (?), but
+   * for the system bus they are presumably essential. A rough outline
+   * of a way to implement the credential transfer would be this:
+   *
+   * client waits to *read* a byte.
+   *
+   * server creates a named pipe with a random name, sends a byte
+   * contining its length, and its name.
+   *
+   * client reads the name, connects to it (using Win32 API).
+   *
+   * server waits for connection to the named pipe, then calls
+   * ImpersonateNamedPipeClient(), notes its now-current credentials,
+   * calls RevertToSelf(), closes its handles to the named pipe, and
+   * is done. (Maybe there is some other way to get the SID of a named
+   * pipe client without having to use impersonation?)
+   *
+   * client closes its handles and is done.
+   *
+   */
+
+  return TRUE;
+
+#endif /* Win32 */
 }
 
 /**
@@ -863,6 +1389,8 @@
                                      DBusCredentials *credentials,
                                      DBusError       *error)
 {
+#ifndef _WIN32
+
   struct msghdr msg;
   struct iovec iov;
   char buf;
@@ -1002,6 +1530,15 @@
 		 credentials->gid);
     
   return TRUE;
+
+#else
+
+  /* FIXME bogus testing credentials */
+  _dbus_credentials_from_current_process (credentials);
+
+  return TRUE;
+
+#endif
 }
 
 /**
@@ -1049,16 +1586,23 @@
 
   addrlen = sizeof (addr);
   
+#ifndef _WIN32
  retry:
+#endif
   client_fd = accept (listen_fd, &addr, &addrlen);
   
-  if (client_fd < 0)
+  if (DBUS_SOCKET_IS_INVALID (client_fd))
     {
+      DBUS_SOCKET_SET_ERRNO ();
+#ifndef _WIN32
       if (errno == EINTR)
         goto retry;
+#else
+      client_fd = -1;
+#endif
     }
   
-  return client_fd;
+  return _dbus_encapsulate_socket (client_fd);
 }
 
 /** @} */
@@ -1238,6 +1782,7 @@
 	
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
     
+#ifndef _WIN32    
   directory = _dbus_string_get_const_data (dir);
 	
   if (stat (directory, &sb) < 0)
@@ -1255,7 +1800,7 @@
                      "%s directory is not private to the user", directory);
       return FALSE;
     }
-    
+#endif    
   return TRUE;
 }
 
@@ -1339,6 +1884,10 @@
 ascii_strtod (const char *nptr,
 	      char      **endptr)
 {
+  /* FIXME: The Win32 C library's strtod() doesn't handle hex.
+   * Presumably many Unixes don't either.
+   */
+
   char *fail_pos;
   double val;
   struct lconv *locale_data;
@@ -1507,6 +2056,9 @@
  * @addtogroup DBusInternalsUtils
  * @{
  */
+
+#ifndef _WIN32
+
 static dbus_bool_t
 fill_user_info_from_passwd (struct passwd *p,
                             DBusUserInfo  *info,
@@ -1530,6 +2082,349 @@
   return TRUE;
 }
 
+#else
+
+static dbus_bool_t
+fill_win32_user_info_name_and_groups (wchar_t 	  *wname,
+				      wchar_t 	  *wdomain,
+				      DBusUserInfo *info,
+				      DBusError    *error)
+{
+  dbus_bool_t retval = FALSE;
+  char *name, *domain;
+  LPLOCALGROUP_USERS_INFO_0 local_groups = NULL;
+  LPGROUP_USERS_INFO_0 global_groups = NULL;
+  DWORD nread, ntotal;
+
+  name = _dbus_win32_utf16_to_utf8 (wname, error);
+  if (!name)
+    return FALSE;
+
+  domain = _dbus_win32_utf16_to_utf8 (wdomain, error);
+  if (!domain)
+    goto out0;
+
+  info->username = dbus_malloc (strlen (domain) + 1 + strlen (name) + 1);
+  if (!info->username)
+    {
+      _DBUS_SET_OOM (error);
+      goto out1;
+    }
+
+  strcpy (info->username, domain);
+  strcat (info->username, "\\");
+  strcat (info->username, name);
+
+  info->n_group_ids = 0;
+  if (NetUserGetLocalGroups (NULL, wname, 0, LG_INCLUDE_INDIRECT,
+			     (LPBYTE *) &local_groups, MAX_PREFERRED_LENGTH,
+			     &nread, &ntotal) == NERR_Success)
+    {
+      DWORD i;
+      int n;
+
+      info->group_ids = dbus_new (dbus_gid_t, nread);
+      if (!info->group_ids)
+	{
+	  _DBUS_SET_OOM (error);
+	  goto out3;
+	}
+
+      for (i = n = 0; i < nread; i++)
+	{
+	  PSID group_sid;
+	  if (_dbus_win32_account_to_sid (local_groups[i].lgrui0_name,
+					  &group_sid, error))
+	    {
+	      info->group_ids[n++] = _dbus_win32_sid_to_uid_t (group_sid);
+	      dbus_free (group_sid);
+	    }
+	}
+      info->n_group_ids = n;
+    }
+
+  if (NetUserGetGroups (NULL, wname, 0,
+			(LPBYTE *) &global_groups, MAX_PREFERRED_LENGTH,
+			&nread, &ntotal) == NERR_Success)
+    {
+      DWORD i;
+      int n = info->n_group_ids;
+
+      info->group_ids = dbus_realloc (info->group_ids, (n + nread) * sizeof (dbus_gid_t));
+      if (!info->group_ids)
+	{
+	  _DBUS_SET_OOM (error);
+	  goto out4;
+	}
+
+      for (i = 0; i < nread; i++)
+	{
+	  PSID group_sid;
+	  if (_dbus_win32_account_to_sid (global_groups[i].grui0_name,
+					  &group_sid, error))
+	    {
+	      info->group_ids[n++] = _dbus_win32_sid_to_uid_t (group_sid);
+	      dbus_free (group_sid);
+	    }
+	}
+      info->n_group_ids = n;
+    }
+  
+  if (info->n_group_ids > 0)
+    {
+      /* FIXME: find out actual primary group */
+      info->primary_gid = info->group_ids[0];
+    }
+  else
+    {
+      info->group_ids = dbus_new (dbus_gid_t, 1);
+      info->n_group_ids = 1;
+      info->group_ids[0] = DBUS_GID_UNSET;
+      info->primary_gid = DBUS_GID_UNSET;
+    }
+
+  retval = TRUE;
+
+ out4:
+  if (global_groups != NULL)
+    NetApiBufferFree (global_groups);
+ out3:
+  if (local_groups != NULL)
+    NetApiBufferFree (local_groups);
+ out1:
+  dbus_free (domain);
+ out0:
+  dbus_free (name);
+
+  return retval;
+}
+
+static dbus_bool_t
+fill_win32_user_info_homedir (wchar_t  	 *wname,
+			      wchar_t  	 *wdomain,
+			      DBusUserInfo *info,
+			      DBusError    *error)
+{
+  dbus_bool_t retval = FALSE;
+  USER_INFO_1 *user_info = NULL;
+  wchar_t wcomputername[MAX_COMPUTERNAME_LENGTH + 1];
+  DWORD wcomputername_length = MAX_COMPUTERNAME_LENGTH + 1;
+  dbus_bool_t local_computer;
+  wchar_t *dc = NULL;
+  NET_API_STATUS ret = 0;
+
+  /* If the domain is this computer's name, assume it's a local user.
+   * Otherwise look up a DC for the domain, and ask it.
+   */
+
+  GetComputerNameW (wcomputername, &wcomputername_length);
+  local_computer = (wcsicmp (wcomputername, wdomain) == 0);
+
+  if (!local_computer)
+    {
+    	ret = NetGetAnyDCName (NULL, wdomain, (LPBYTE *) &dc);
+      if (ret != NERR_Success) {
+	      info->homedir = _dbus_strdup ("\\");
+      	_dbus_warn("NetGetAnyDCName() failed with errorcode %d '%s'\n",ret,_dbus_lm_strerror(ret));
+				return TRUE;
+			}
+    }
+      
+  /* No way to find out the profile of another user, let's try the
+   * "home directory" from NetUserGetInfo's USER_INFO_1.
+   */
+  ret = NetUserGetInfo (dc, wname, 1, (LPBYTE *) &user_info); 
+  if (ret == NERR_Success &&
+      user_info->usri1_home_dir != NULL &&
+      user_info->usri1_home_dir != 0xfeeefeee &&  /* freed memory http://www.gamedev.net/community/forums/topic.asp?topic_id=158402 */
+      user_info->usri1_home_dir[0] != '\0')
+    {
+      info->homedir = _dbus_win32_utf16_to_utf8 (user_info->usri1_home_dir, error);
+      if (!info->homedir)
+	goto out1;
+    }
+  else
+    {
+      _dbus_warn("NetUserGetInfo() failed with errorcode %d '%s', %s\n",ret,_dbus_lm_strerror(ret),_dbus_win32_utf16_to_utf8(dc,error));
+      /* Not set, so use something random. */
+      info->homedir = _dbus_strdup ("\\");
+    }
+  
+  retval = TRUE;
+
+ out1:
+  if (dc != NULL)
+    NetApiBufferFree (dc);
+  if (user_info != NULL)
+  	NetApiBufferFree (user_info);
+
+  return retval;
+}
+
+static dbus_bool_t
+fill_win32_user_info_from_name (wchar_t      *wname,
+				DBusUserInfo *info,
+				DBusError    *error)
+{
+  dbus_bool_t retval = FALSE;
+  PSID sid;
+  wchar_t *wdomain;
+  DWORD sid_length, wdomain_length;
+  SID_NAME_USE use;
+		     
+  sid_length = 0;
+  wdomain_length = 0;
+  if (!LookupAccountNameW (NULL, wname, NULL, &sid_length,
+			   NULL, &wdomain_length, &use) &&
+      GetLastError () != ERROR_INSUFFICIENT_BUFFER)
+    {
+      _dbus_win32_set_error_from_win32_error (error, GetLastError ());
+      return FALSE;
+    }
+
+  sid = dbus_malloc (sid_length);
+  if (!sid)
+    {
+      _DBUS_SET_OOM (error);
+      return FALSE;
+    }
+
+  wdomain = dbus_new (wchar_t, wdomain_length);
+  if (!wdomain)
+    {
+      _DBUS_SET_OOM (error);
+      goto out0;
+    }
+
+  if (!LookupAccountNameW (NULL, wname, sid, &sid_length,
+			   wdomain, &wdomain_length, &use))
+    {
+      _dbus_win32_set_error_from_win32_error (error, GetLastError ());
+      goto out1;
+    }
+
+  if (!IsValidSid (sid))
+    {
+      dbus_set_error_const (error, DBUS_ERROR_FAILED, "Invalid SID");
+      goto out1;
+    }
+
+  info->uid = _dbus_win32_sid_to_uid_t (sid);
+
+  if (!fill_win32_user_info_name_and_groups (wname, wdomain, info, error))
+    goto out1;
+    
+  if (!fill_win32_user_info_homedir (wname, wdomain, info, error))
+    goto out1;
+
+  retval = TRUE;
+
+ out1:
+  dbus_free (wdomain);
+ out0:
+  dbus_free (sid);
+
+  return retval;
+}
+
+dbus_bool_t
+_dbus_win32_sid_to_name_and_domain (dbus_uid_t uid,
+				    wchar_t  **wname,
+				    wchar_t  **wdomain,
+				    DBusError *error)
+{
+  PSID sid;
+  DWORD wname_length, wdomain_length;
+  SID_NAME_USE use;
+
+  if (!ConvertStringSidToSidA (uid, &sid))
+    {
+      _dbus_win32_set_error_from_win32_error (error, GetLastError ());
+      return FALSE;
+    }
+
+  wname_length = 0;
+  wdomain_length = 0;
+  if (!LookupAccountSidW (NULL, sid, NULL, &wname_length,
+			  NULL, &wdomain_length, &use) &&
+      GetLastError () != ERROR_INSUFFICIENT_BUFFER)
+    {
+      _dbus_win32_set_error_from_win32_error (error, GetLastError ());
+      goto out0;
+    }
+
+  *wname = dbus_new (wchar_t, wname_length);
+  if (!*wname)
+    {
+      _DBUS_SET_OOM (error);
+      goto out0;
+    }
+
+  *wdomain = dbus_new (wchar_t, wdomain_length);
+  if (!*wdomain)
+    {
+      _DBUS_SET_OOM (error);
+      goto out1;
+    }
+
+  if (!LookupAccountSidW (NULL, sid, *wname, &wname_length,
+			  *wdomain, &wdomain_length, &use))
+    {
+      _dbus_win32_set_error_from_win32_error (error, GetLastError ());
+      goto out2;
+    }
+
+  return TRUE;
+
+ out2:
+  dbus_free (*wdomain);
+  *wdomain = NULL;
+ out1:
+  dbus_free (*wname);
+  *wname = NULL;
+ out0:
+  LocalFree (sid);
+
+  return FALSE;
+}
+
+static dbus_bool_t
+fill_win32_user_info_from_uid (dbus_uid_t    uid,
+			       DBusUserInfo *info,
+			       DBusError    *error)
+{
+  dbus_bool_t retval = FALSE;
+  wchar_t *wname, *wdomain;
+
+  info->uid = uid;
+
+  if (!_dbus_win32_sid_to_name_and_domain (uid, &wname, &wdomain, error)) {
+   	_dbus_verbose("%s after _dbus_win32_sid_to_name_and_domain\n",__FUNCTION__);
+    return FALSE;
+ 	 }
+
+  if (!fill_win32_user_info_name_and_groups (wname, wdomain, info, error)) {
+  	_dbus_verbose("%s after fill_win32_user_info_name_and_groups\n",__FUNCTION__);
+    goto out0;
+ 	 }
+
+    
+  if (!fill_win32_user_info_homedir (wname, wdomain, info, error)) {
+  	_dbus_verbose("%s after fill_win32_user_info_homedir\n",__FUNCTION__);
+     goto out0; 
+ 	 }
+ 	 
+  retval = TRUE;
+
+ out0:
+  dbus_free (wdomain);
+  dbus_free (wname);
+
+  return retval;
+}
+
+#endif /* !_WIN32 */
+
 static dbus_bool_t
 fill_user_info (DBusUserInfo       *info,
                 dbus_uid_t          uid,
@@ -1539,8 +2434,8 @@
   const char *username_c;
   
   /* exactly one of username/uid provided */
-  _dbus_assert (username != NULL || uid != DBUS_UID_UNSET);
-  _dbus_assert (username == NULL || uid == DBUS_UID_UNSET);
+  _dbus_assert (username != NULL || !DBUS_UID_EQUAL (uid, DBUS_UID_UNSET));
+  _dbus_assert (username == NULL || DBUS_UID_EQUAL (uid, DBUS_UID_UNSET));
 
   info->uid = DBUS_UID_UNSET;
   info->primary_gid = DBUS_GID_UNSET;
@@ -1554,6 +2449,7 @@
   else
     username_c = NULL;
 
+#ifndef _WIN32
   /* For now assuming that the getpwnam() and getpwuid() flavors
    * are always symmetrical, if not we have to add more configure
    * checks
@@ -1575,7 +2471,7 @@
       result = getpwnam_r (username_c, &p_str, buf, sizeof (buf),
                            &p);
 #else
-    if (uid != DBUS_UID_UNSET)
+    if (!DBUS_UID_EQUAL (uid, DBUS_UID_UNSET))
       p = getpwuid_r (uid, &p_str, buf, sizeof (buf));
     else
       p = getpwnam_r (username_c, &p_str, buf, sizeof (buf));
@@ -1600,7 +2496,7 @@
     /* I guess we're screwed on thread safety here */
     struct passwd *p;
 
-    if (uid != DBUS_UID_UNSET)
+    if (!DBUS_UID_EQUAL (uid, DBUS_UID_UNSET))
       p = getpwuid (uid);
     else
       p = getpwnam (username_c);
@@ -1704,8 +2600,36 @@
  failed:
   _DBUS_ASSERT_ERROR_IS_SET (error);
   return FALSE;
+
+#else  /* Win32 */
+
+  if (!DBUS_UID_EQUAL (uid, DBUS_UID_UNSET))
+    {
+      if (!fill_win32_user_info_from_uid (uid, info, error)) {
+      	_dbus_verbose("%s after fill_win32_user_info_from_uid\n",__FUNCTION__);
+				return FALSE;
+			}
+    }
+  else
+    {
+      wchar_t *wname = _dbus_win32_utf8_to_utf16 (username_c, error);
+      
+      if (!wname)
+	return FALSE;
+      
+      if (!fill_win32_user_info_from_name (wname, info, error))
+	{
+	  dbus_free (wname);
+	  return FALSE;
+	}
+      dbus_free (wname);
+    }
+
+  return TRUE;
+#endif  /* Win32 */
 }
 
+
 /**
  * Gets user info for the given username.
  *
@@ -1754,17 +2678,6 @@
 }
 
 /**
- * Frees the members of info (but not info itself).
- *
- * @param info the group info
- */
-void
-_dbus_group_info_free (DBusGroupInfo    *info)
-{
-  dbus_free (info->groupname);
-}
-
-/**
  * Sets fields in DBusCredentials to DBUS_PID_UNSET,
  * DBUS_UID_UNSET, DBUS_GID_UNSET.
  *
@@ -1786,6 +2699,8 @@
 void
 _dbus_credentials_from_current_process (DBusCredentials *credentials)
 {
+#ifndef _WIN32
+
   /* The POSIX spec certainly doesn't promise this, but
    * we need these assertions to fail as soon as we're wrong about
    * it so we can do the porting fixups
@@ -1797,6 +2712,12 @@
   credentials->pid = getpid ();
   credentials->uid = getuid ();
   credentials->gid = getgid ();
+
+#else
+  credentials->pid = _dbus_getpid ();
+  credentials->uid = _dbus_getuid ();
+  credentials->gid = _dbus_getgid ();
+#endif
 }
 
 /**
@@ -1811,13 +2732,13 @@
 _dbus_credentials_match (const DBusCredentials *expected_credentials,
                          const DBusCredentials *provided_credentials)
 {
-  if (provided_credentials->uid == DBUS_UID_UNSET)
+  if (DBUS_UID_EQUAL (provided_credentials->uid, DBUS_UID_UNSET))
     return FALSE;
-  else if (expected_credentials->uid == DBUS_UID_UNSET)
+  else if (DBUS_UID_EQUAL (expected_credentials->uid, DBUS_UID_UNSET))
     return FALSE;
-  else if (provided_credentials->uid == 0)
+  else if (DBUS_UID_EQUAL (provided_credentials->uid, DBUS_UID_ROOT))
     return TRUE;
-  else if (provided_credentials->uid == expected_credentials->uid)
+  else if (DBUS_UID_EQUAL (provided_credentials->uid, expected_credentials->uid))
     return TRUE;
   else
     return FALSE;
@@ -1830,26 +2751,79 @@
 unsigned long
 _dbus_getpid (void)
 {
+#ifndef _WIN32
   return getpid ();
+#else
+  return GetCurrentProcessId ();
+#endif
 }
 
 /** Gets our UID
- * @returns process UID
+ * @returns process user identifier
  */
 dbus_uid_t
 _dbus_getuid (void)
 {
+#ifndef _WIN32
   return getuid ();
+#else
+  dbus_uid_t retval = DBUS_UID_UNSET;
+  HANDLE process_token = NULL;
+  TOKEN_USER *token_user = NULL;
+  DWORD n;
+
+  if (!OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &process_token))
+    _dbus_win32_warn_win32_error ("OpenProcessToken failed", GetLastError ());
+  else if ((!GetTokenInformation (process_token, TokenUser,
+				  NULL, 0, &n) &&
+	    GetLastError () != ERROR_INSUFFICIENT_BUFFER) ||
+	   (token_user = alloca (n)) == NULL ||
+	   !GetTokenInformation (process_token, TokenUser,
+				 token_user, n, &n))
+    _dbus_win32_warn_win32_error ("GetTokenInformation failed", GetLastError ());
+  else
+    retval = _dbus_win32_sid_to_uid_t (token_user->User.Sid);
+
+  if (process_token != NULL)
+    CloseHandle (process_token);
+
+	_dbus_verbose("_dbus_getuid()=%d\n",retval);
+  return retval;
+#endif
 }
 
 #ifdef DBUS_BUILD_TESTS
 /** Gets our GID
- * @returns process GID
+ * @returns process group identifier
  */
 dbus_gid_t
 _dbus_getgid (void)
 {
+#ifndef _WIN32
   return getgid ();
+#else
+  dbus_gid_t retval = DBUS_GID_UNSET;
+  HANDLE process_token = NULL;
+  TOKEN_PRIMARY_GROUP *token_primary_group = NULL;
+  DWORD n;
+
+  if (!OpenProcessToken (GetCurrentProcess (), TOKEN_QUERY, &process_token))
+    _dbus_win32_warn_win32_error ("OpenProcessToken failed", GetLastError ());
+  else if ((!GetTokenInformation (process_token, TokenPrimaryGroup,
+				  NULL, 0, &n) &&
+	    GetLastError () != ERROR_INSUFFICIENT_BUFFER) ||
+	   (token_primary_group = alloca (n)) == NULL ||
+	   !GetTokenInformation (process_token, TokenPrimaryGroup,
+				 token_primary_group, n, &n))
+    _dbus_win32_warn_win32_error ("GetTokenInformation failed", GetLastError ());
+  else
+    retval = _dbus_win32_sid_to_uid_t (token_primary_group->PrimaryGroup);
+
+  if (process_token != NULL)
+    CloseHandle (process_token);
+
+  return retval;
+#endif
 }
 #endif
 
@@ -1964,6 +2938,10 @@
     }
 #else /* ! HAVE_POLL */
 
+#ifdef _WIN32
+  char msg[200], *msgp;
+#endif
+
   fd_set read_set, write_set, err_set;
   int max_fd = 0;
   int i;
@@ -1974,44 +2952,124 @@
   FD_ZERO (&write_set);
   FD_ZERO (&err_set);
 
-  for (i = 0; i < n_fds; i++)
+#ifdef _WIN32
+  _DBUS_LOCK (win32_fds);
+
+  _dbus_assert (win32_fds != NULL);
+
+  msgp = msg;
+  msgp += sprintf (msgp, "select: to=%d ", timeout_milliseconds);
+  for (i = 0; i < n_fds; i++)
+    {
+      static dbus_bool_t warned = FALSE;
+      DBusPollFD *f = fds+i;
+      int fd = UNRANDOMIZE (f->fd);
+
+      _dbus_assert (fd >= 0 && fd < win32_n_fds);
+
+      if (!warned &&
+	  win32_fds[fd].type != DBUS_WIN32_FD_SOCKET)
+	{
+	  _dbus_warn ("Can poll only sockets on Win32");
+	  warned = TRUE;
+	}
+
+      if (f->events & _DBUS_POLLIN)
+	msgp += sprintf (msgp, "R:%d ", _dbus_decapsulate_quick (f->fd));
+
+      if (f->events & _DBUS_POLLOUT)
+	msgp += sprintf (msgp, "W:%d ", _dbus_decapsulate_quick (f->fd));
+
+      msgp += sprintf (msgp, "E:%d ", _dbus_decapsulate_quick (f->fd));
+    }
+
+  msgp += sprintf (msgp, "\n");
+  _dbus_verbose ("%s",msg);
+#endif
+
+  for (i = 0; i < n_fds; i++)
     {
       DBusPollFD *fdp = &fds[i];
 
+#ifdef _WIN32
+      if (win32_fds[UNRANDOMIZE (fdp->fd)].type != DBUS_WIN32_FD_SOCKET)
+	continue;
+#endif
+
       if (fdp->events & _DBUS_POLLIN)
-	FD_SET (fdp->fd, &read_set);
+	FD_SET (_dbus_decapsulate_quick (fdp->fd), &read_set);
 
       if (fdp->events & _DBUS_POLLOUT)
-	FD_SET (fdp->fd, &write_set);
+	FD_SET (_dbus_decapsulate_quick (fdp->fd), &write_set);
 
-      FD_SET (fdp->fd, &err_set);
+      FD_SET (_dbus_decapsulate_quick (fdp->fd), &err_set);
 
-      max_fd = MAX (max_fd, fdp->fd);
+      max_fd = MAX (max_fd, _dbus_decapsulate_quick (fdp->fd));
     }
     
+#ifdef _WIN32
+  _DBUS_UNLOCK (win32_fds);
+#endif
+    
   tv.tv_sec = timeout_milliseconds / 1000;
   tv.tv_usec = (timeout_milliseconds % 1000) * 1000;
 
   ready = select (max_fd + 1, &read_set, &write_set, &err_set,
                   timeout_milliseconds < 0 ? NULL : &tv);
 
-  if (ready > 0)
+  if (DBUS_SOCKET_API_RETURNS_ERROR (ready))
+    {
+      DBUS_SOCKET_SET_ERRNO ();
+#ifdef _WIN32
+      if (errno != EWOULDBLOCK)
+	_dbus_verbose ("select: failed: %s\n", _dbus_strerror (errno));
+#endif
+    }
+#ifdef _WIN32
+  else if (ready == 0)
+    _dbus_verbose ("select: = 0\n");
+#endif
+  else if (ready > 0)
     {
+#ifdef _WIN32
+      msgp = msg;
+      msgp += sprintf (msgp, "select: = %d:", ready);
+      _DBUS_LOCK (win32_fds);
+      for (i = 0; i < n_fds; i++)
+	{
+	  DBusPollFD *f = fds+i;
+
+	  if (FD_ISSET (_dbus_decapsulate_quick (f->fd), &read_set))
+	    msgp += sprintf (msgp, "R:%d ", _dbus_decapsulate_quick (f->fd));
+
+	  if (FD_ISSET (_dbus_decapsulate_quick (f->fd), &write_set))
+	    msgp += sprintf (msgp, "W:%d ", _dbus_decapsulate_quick (f->fd));
+
+	  if (FD_ISSET (_dbus_decapsulate_quick (f->fd), &err_set))
+	    msgp += sprintf (msgp, "E:%d ", _dbus_decapsulate_quick (f->fd));
+	}
+      msgp += sprintf (msgp, "\n");
+      _dbus_verbose ("%s",msg);
+
+#endif
       for (i = 0; i < n_fds; i++)
 	{
 	  DBusPollFD *fdp = &fds[i];
 
 	  fdp->revents = 0;
 
-	  if (FD_ISSET (fdp->fd, &read_set))
+	  if (FD_ISSET (_dbus_decapsulate_quick (fdp->fd), &read_set))
 	    fdp->revents |= _DBUS_POLLIN;
 
-	  if (FD_ISSET (fdp->fd, &write_set))
+	  if (FD_ISSET (_dbus_decapsulate_quick (fdp->fd), &write_set))
 	    fdp->revents |= _DBUS_POLLOUT;
 
-	  if (FD_ISSET (fdp->fd, &err_set))
+	  if (FD_ISSET (_dbus_decapsulate_quick (fdp->fd), &err_set))
 	    fdp->revents |= _DBUS_POLLERR;
 	}
+#ifdef _WIN32
+      _DBUS_UNLOCK (win32_fds);
+#endif
     }
 
   return ready;
@@ -2036,6 +3094,7 @@
 void
 _dbus_sleep_milliseconds (int milliseconds)
 {
+#ifndef _WIN32
 #ifdef HAVE_NANOSLEEP
   struct timespec req;
   struct timespec rem;
@@ -2052,18 +3111,22 @@
 #else /* ! HAVE_USLEEP */
   sleep (MAX (milliseconds / 1000, 1));
 #endif
+#else  /* _WIN32 */
+  Sleep (milliseconds);
+#endif /* !_WIN32 */
 }
 
 /**
  * Get current time, as in gettimeofday().
  *
  * @param tv_sec return location for number of seconds
- * @param tv_usec return location for number of microseconds (thousandths)
+ * @param tv_usec return location for number of microseconds
  */
 void
 _dbus_get_current_time (long *tv_sec,
                         long *tv_usec)
 {
+#ifndef _WIN32
   struct timeval t;
 
   gettimeofday (&t, NULL);
@@ -2072,6 +3135,24 @@
     *tv_sec = t.tv_sec;
   if (tv_usec)
     *tv_usec = t.tv_usec;
+#else
+  FILETIME ft;
+  dbus_uint64_t *time64 = (dbus_uint64_t *) &ft;
+
+  GetSystemTimeAsFileTime (&ft);
+
+  /* Convert from 100s of nanoseconds since 1601-01-01
+   * to Unix epoch. Yes, this is Y2038 unsafe.
+   */
+  *time64 -= DBUS_INT64_CONSTANT (116444736000000000);
+  *time64 /= 10;
+
+  if (tv_sec)
+    *tv_sec = *time64 / 1000000;
+
+  if (tv_usec)
+    *tv_usec = *time64 % 1000000;
+#endif
 }
 
 /**
@@ -2099,7 +3180,7 @@
   
   filename_c = _dbus_string_get_const_data (filename);
   
-  /* O_BINARY useful on Cygwin */
+  /* O_BINARY useful on Cygwin and Win32 */
   fd = open (filename_c, O_RDONLY | O_BINARY);
   if (fd < 0)
     {
@@ -2139,10 +3220,11 @@
   if (sb.st_size > 0 && S_ISREG (sb.st_mode))
     {
       int bytes_read;
+      const int encapsulated_fd = _dbus_encapsulate_fd (fd);
 
       while (total < (int) sb.st_size)
         {
-          bytes_read = _dbus_read (fd, str,
+          bytes_read = _dbus_read (encapsulated_fd, str,
                                    sb.st_size - total);
           if (bytes_read <= 0)
             {
@@ -2154,7 +3236,7 @@
               _dbus_verbose ("read() failed: %s",
                              _dbus_strerror (errno));
               
-              close (fd);
+              _dbus_close (encapsulated_fd, NULL);
               _dbus_string_set_length (str, orig_len);
               return FALSE;
             }
@@ -2162,7 +3244,7 @@
             total += bytes_read;
         }
 
-      close (fd);
+      _dbus_close (encapsulated_fd, NULL);
       return TRUE;
     }
   else if (sb.st_size != 0)
@@ -2251,6 +3333,8 @@
       goto out;
     }
 
+  fd = _dbus_encapsulate_fd (fd);
+
   need_unlink = TRUE;
   
   total = 0;
@@ -2275,7 +3359,7 @@
       total += bytes_written;
     }
 
-  if (close (fd) < 0)
+  if (_dbus_close (fd, NULL) < 0)
     {
       dbus_set_error (error, _dbus_error_from_errno (errno),
                       "Could not close file %s: %s",
@@ -2286,7 +3370,11 @@
 
   fd = -1;
   
-  if (rename (tmp_filename_c, filename_c) < 0)
+  if (
+#ifdef WIN32
+      (unlink (filename_c) == -1 && errno != ENOENT) ||
+#endif
+      rename (tmp_filename_c, filename_c) < 0)
     {
       dbus_set_error (error, _dbus_error_from_errno (errno),
                       "Could not rename %s to %s: %s",
@@ -2306,7 +3394,7 @@
    */
 
   if (fd >= 0)
-    close (fd);
+    _dbus_close (fd, NULL);
         
   if (need_unlink && unlink (tmp_filename_c) < 0)
     _dbus_verbose ("Failed to unlink temp file %s: %s\n",
@@ -2444,6 +3532,7 @@
       _dbus_string_get_length (next_component) == 0)
     return TRUE;
   
+#ifndef _WIN32
   dir_ends_in_slash = '/' == _dbus_string_get_byte (dir,
                                                     _dbus_string_get_length (dir) - 1);
 
@@ -2458,6 +3547,25 @@
       if (!_dbus_string_append_byte (dir, '/'))
         return FALSE;
     }
+#else
+  dir_ends_in_slash =
+    ('/' == _dbus_string_get_byte (dir, _dbus_string_get_length (dir) - 1) ||
+     '\\' == _dbus_string_get_byte (dir, _dbus_string_get_length (dir) - 1));
+
+  file_starts_with_slash =
+     ('/' == _dbus_string_get_byte (next_component, 0) ||
+      '\\' == _dbus_string_get_byte (next_component, 0));
+
+  if (dir_ends_in_slash && file_starts_with_slash)
+    {
+      _dbus_string_shorten (dir, 1);
+    }
+  else if (!(dir_ends_in_slash || file_starts_with_slash))
+    {
+      if (!_dbus_string_append_byte (dir, '\\'))
+        return FALSE;
+    }
+#endif
 
   return _dbus_string_copy (next_component, 0, dir,
                             _dbus_string_get_length (dir));
@@ -2565,14 +3673,18 @@
   old_len = _dbus_string_get_length (str);
   fd = -1;
 
+#ifndef _WIN32
   /* note, urandom on linux will fall back to pseudorandom */
   fd = open ("/dev/urandom", O_RDONLY);
+#endif
+
   if (fd < 0)
     return pseudorandom_generate_random_bytes (str, n_bytes);
 
+#ifndef _WIN32
   if (_dbus_read (fd, str, n_bytes) != n_bytes)
     {
-      close (fd);
+      _dbus_close (fd, NULL);
       _dbus_string_set_length (str, old_len);
       return pseudorandom_generate_random_bytes (str, n_bytes);
     }
@@ -2583,6 +3695,10 @@
   close (fd);
   
   return TRUE;
+#else
+  _dbus_assert_not_reached ("whoa");
+  return FALSE;
+#endif
 }
 
 /**
@@ -2634,6 +3750,67 @@
 {
   const char *msg;
   
+#ifdef _WIN32
+  switch (error_number)
+    {
+    case WSAEINTR: return "Interrupted function call";
+    case WSAEACCES: return "Permission denied";
+    case WSAEFAULT: return "Bad address";
+    case WSAEINVAL: return "Invalid argument";
+    case WSAEMFILE: return "Too many open files";
+    case WSAEWOULDBLOCK: return "Resource temporarily unavailable";
+    case WSAEINPROGRESS: return "Operation now in progress";
+    case WSAEALREADY: return "Operation already in progress";
+    case WSAENOTSOCK: return "Socket operation on nonsocket";
+    case WSAEDESTADDRREQ: return "Destination address required";
+    case WSAEMSGSIZE: return "Message too long";
+    case WSAEPROTOTYPE: return "Protocol wrong type for socket";
+    case WSAENOPROTOOPT: return "Bad protocol option";
+    case WSAEPROTONOSUPPORT: return "Protocol not supported";
+    case WSAESOCKTNOSUPPORT: return "Socket type not supported";
+    case WSAEOPNOTSUPP: return "Operation not supported";
+    case WSAEPFNOSUPPORT: return "Protocol family not supported";
+    case WSAEAFNOSUPPORT: return "Address family not supported by protocol family";
+    case WSAEADDRINUSE: return "Address already in use";
+    case WSAEADDRNOTAVAIL: return "Cannot assign requested address";
+    case WSAENETDOWN: return "Network is down";
+    case WSAENETUNREACH: return "Network is unreachable";
+    case WSAENETRESET: return "Network dropped connection on reset";
+    case WSAECONNABORTED: return "Software caused connection abort";
+    case WSAECONNRESET: return "Connection reset by peer";
+    case WSAENOBUFS: return "No buffer space available";
+    case WSAEISCONN: return "Socket is already connected";
+    case WSAENOTCONN: return "Socket is not connected";
+    case WSAESHUTDOWN: return "Cannot send after socket shutdown";
+    case WSAETIMEDOUT: return "Connection timed out";
+    case WSAECONNREFUSED: return "Connection refused";
+    case WSAEHOSTDOWN: return "Host is down";
+    case WSAEHOSTUNREACH: return "No route to host";
+    case WSAEPROCLIM: return "Too many processes";
+    case WSAEDISCON: return "Graceful shutdown in progress";
+    case WSATYPE_NOT_FOUND: return "Class type not found";
+    case WSAHOST_NOT_FOUND: return "Host not found";
+    case WSATRY_AGAIN: return "Nonauthoritative host not found";
+    case WSANO_RECOVERY: return "This is a nonrecoverable error";
+    case WSANO_DATA: return "Valid name, no data record of requested type";
+    case WSA_INVALID_HANDLE: return "Specified event object handle is invalid";
+    case WSA_INVALID_PARAMETER: return "One or more parameters are invalid";
+    case WSA_IO_INCOMPLETE: return "Overlapped I/O event object not in signaled state";
+    case WSA_IO_PENDING: return "Overlapped operations will complete later";
+    case WSA_NOT_ENOUGH_MEMORY: return "Insufficient memory available";
+    case WSA_OPERATION_ABORTED: return "Overlapped operation aborted";
+#ifdef WSAINVALIDPROCTABLE
+    case WSAINVALIDPROCTABLE: return "Invalid procedure table from service provider";
+#endif
+#ifdef WSAINVALIDPROVIDER
+    case WSAINVALIDPROVIDER: return "Invalid service provider version number";
+#endif
+#ifdef WSAPROVIDERFAILEDINIT
+    case WSAPROVIDERFAILEDINIT: return "Unable to initialize a service provider";
+#endif
+    case WSASYSCALLFAILURE: return "System call failure";
+    }
+#endif
   msg = strerror (error_number);
   if (msg == NULL)
     msg = "unknown";
@@ -2641,13 +3818,347 @@
   return msg;
 }
 
+#ifdef _WIN32
+#include <lmerr.h>
+/* lan manager error codes */ 
+const char*
+_dbus_lm_strerror(int error_number)
+{
+  const char *msg;
+  switch (error_number)
+    {
+    case NERR_NetNotStarted:                return "The workstation driver is not installed.";
+    case NERR_UnknownServer:                return "The server could not be located.";
+    case NERR_ShareMem:                     return "An internal error occurred. The network cannot access a shared memory segment.";
+    case NERR_NoNetworkResource:            return "A network resource shortage occurred.";
+    case NERR_RemoteOnly:                   return "This operation is not supported on workstations.";
+    case NERR_DevNotRedirected:             return "The device is not connected.";
+    case NERR_ServerNotStarted:             return "The Server service is not started.";
+    case NERR_ItemNotFound:                 return "The queue is empty.";
+    case NERR_UnknownDevDir:                return "The device or directory does not exist.";
+    case NERR_RedirectedPath:               return "The operation is invalid on a redirected resource.";
+    case NERR_DuplicateShare:               return "The name has already been shared.";
+    case NERR_NoRoom:                       return "The server is currently out of the requested resource.";
+    case NERR_TooManyItems:                 return "Requested addition of items exceeds the maximum allowed.";
+    case NERR_InvalidMaxUsers:              return "The Peer service supports only two simultaneous users.";
+    case NERR_BufTooSmall:                  return "The API return buffer is too small.";
+    case NERR_RemoteErr:                    return "A remote API error occurred.";
+    case NERR_LanmanIniError:               return "An error occurred when opening or reading the configuration file.";
+    case NERR_NetworkError:                 return "A general network error occurred.";
+    case NERR_WkstaInconsistentState:       return "The Workstation service is in an inconsistent state. Restart the computer before restarting the Workstation service.";
+    case NERR_WkstaNotStarted:              return "The Workstation service has not been started.";
+    case NERR_BrowserNotStarted:            return "The requested information is not available.";
+    case NERR_InternalError:                return "An internal error occurred.";
+    case NERR_BadTransactConfig:            return "The server is not configured for transactions.";
+    case NERR_InvalidAPI:                   return "The requested API is not supported on the remote server.";
+    case NERR_BadEventName:                 return "The event name is invalid.";
+    case NERR_DupNameReboot:                return "The computer name already exists on the network. Change it and restart the computer.";
+    case NERR_CfgCompNotFound:              return "The specified component could not be found in the configuration information.";
+    case NERR_CfgParamNotFound:             return "The specified parameter could not be found in the configuration information.";
+    case NERR_LineTooLong:                  return "A line in the configuration file is too long.";
+    case NERR_QNotFound:                    return "The printer does not exist.";
+    case NERR_JobNotFound:                  return "The print job does not exist.";
+    case NERR_DestNotFound:                 return "The printer destination cannot be found.";
+    case NERR_DestExists:                   return "The printer destination already exists.";
+    case NERR_QExists:                      return "The printer queue already exists.";
+    case NERR_QNoRoom:                      return "No more printers can be added.";
+    case NERR_JobNoRoom:                    return "No more print jobs can be added.";
+    case NERR_DestNoRoom:                   return "No more printer destinations can be added.";
+    case NERR_DestIdle:                     return "This printer destination is idle and cannot accept control operations.";
+    case NERR_DestInvalidOp:                return "This printer destination request contains an invalid control function.";
+    case NERR_ProcNoRespond:                return "The print processor is not responding.";
+    case NERR_SpoolerNotLoaded:             return "The spooler is not running.";
+    case NERR_DestInvalidState:             return "This operation cannot be performed on the print destination in its current state.";
+    case NERR_QInvalidState:                return "This operation cannot be performed on the printer queue in its current state.";
+    case NERR_JobInvalidState:              return "This operation cannot be performed on the print job in its current state.";
+    case NERR_SpoolNoMemory:                return "A spooler memory allocation failure occurred.";
+    case NERR_DriverNotFound:               return "The device driver does not exist.";
+    case NERR_DataTypeInvalid:              return "The data type is not supported by the print processor.";
+    case NERR_ProcNotFound:                 return "The print processor is not installed.";
+    case NERR_ServiceTableLocked:           return "The service database is locked.";
+    case NERR_ServiceTableFull:             return "The service table is full.";
+    case NERR_ServiceInstalled:             return "The requested service has already been started.";
+    case NERR_ServiceEntryLocked:           return "The service does not respond to control actions.";
+    case NERR_ServiceNotInstalled:          return "The service has not been started.";
+    case NERR_BadServiceName:               return "The service name is invalid.";
+    case NERR_ServiceCtlTimeout:            return "The service is not responding to the control function.";
+    case NERR_ServiceCtlBusy:               return "The service control is busy.";
+    case NERR_BadServiceProgName:           return "The configuration file contains an invalid service program name.";
+    case NERR_ServiceNotCtrl:               return "The service could not be controlled in its present state.";
+    case NERR_ServiceKillProc:              return "The service ended abnormally.";
+    case NERR_ServiceCtlNotValid:           return "The requested pause or stop is not valid for this service.";
+    case NERR_NotInDispatchTbl:             return "The service control dispatcher could not find the service name in the dispatch table.";
+    case NERR_BadControlRecv:               return "The service control dispatcher pipe read failed.";
+    case NERR_ServiceNotStarting:           return "A thread for the new service could not be created.";
+    case NERR_AlreadyLoggedOn:              return "This workstation is already logged on to the local-area network.";
+    case NERR_NotLoggedOn:                  return "The workstation is not logged on to the local-area network.";
+    case NERR_BadUsername:                  return "The user name or group name parameter is invalid.";
+    case NERR_BadPassword:                  return "The password parameter is invalid.";
+    case NERR_UnableToAddName_W:            return "@W The logon processor did not add the message alias.";
+    case NERR_UnableToAddName_F:            return "The logon processor did not add the message alias.";
+    case NERR_UnableToDelName_W:            return "@W The logoff processor did not delete the message alias.";
+    case NERR_UnableToDelName_F:            return "The logoff processor did not delete the message alias.";
+    case NERR_LogonsPaused:                 return "Network logons are paused.";
+    case NERR_LogonServerConflict:          return "A centralized logon-server conflict occurred.";
+    case NERR_LogonNoUserPath:              return "The server is configured without a valid user path.";
+    case NERR_LogonScriptError:             return "An error occurred while loading or running the logon script.";
+    case NERR_StandaloneLogon:              return "The logon server was not specified. Your computer will be logged on as STANDALONE.";
+    case NERR_LogonServerNotFound:          return "The logon server could not be found.";
+    case NERR_LogonDomainExists:            return "There is already a logon domain for this computer.";
+    case NERR_NonValidatedLogon:            return "The logon server could not validate the logon.";
+    case NERR_ACFNotFound:                  return "The security database could not be found.";
+    case NERR_GroupNotFound:                return "The group name could not be found.";
+    case NERR_UserNotFound:                 return "The user name could not be found.";
+    case NERR_ResourceNotFound:             return "The resource name could not be found.";
+    case NERR_GroupExists:                  return "The group already exists.";
+    case NERR_UserExists:                   return "The user account already exists.";
+    case NERR_ResourceExists:               return "The resource permission list already exists.";
+    case NERR_NotPrimary:                   return "This operation is only allowed on the primary domain controller of the domain.";
+    case NERR_ACFNotLoaded:                 return "The security database has not been started.";
+    case NERR_ACFNoRoom:                    return "There are too many names in the user accounts database.";
+    case NERR_ACFFileIOFail:                return "A disk I/O failure occurred.";
+    case NERR_ACFTooManyLists:              return "The limit of 64 entries per resource was exceeded.";
+    case NERR_UserLogon:                    return "Deleting a user with a session is not allowed.";
+    case NERR_ACFNoParent:                  return "The parent directory could not be located.";
+    case NERR_CanNotGrowSegment:            return "Unable to add to the security database session cache segment.";
+    case NERR_SpeGroupOp:                   return "This operation is not allowed on this special group.";
+    case NERR_NotInCache:                   return "This user is not cached in user accounts database session cache.";
+    case NERR_UserInGroup:                  return "The user already belongs to this group.";
+    case NERR_UserNotInGroup:               return "The user does not belong to this group.";
+    case NERR_AccountUndefined:             return "This user account is undefined.";
+    case NERR_AccountExpired:               return "This user account has expired.";
+    case NERR_InvalidWorkstation:           return "The user is not allowed to log on from this workstation.";
+    case NERR_InvalidLogonHours:            return "The user is not allowed to log on at this time.";
+    case NERR_PasswordExpired:              return "The password of this user has expired.";
+    case NERR_PasswordCantChange:           return "The password of this user cannot change.";
+    case NERR_PasswordHistConflict:         return "This password cannot be used now.";
+    case NERR_PasswordTooShort:             return "The password does not meet the password policy requirements. Check the minimum password length, password complexity and password history requirements.";
+    case NERR_PasswordTooRecent:            return "The password of this user is too recent to change.";
+    case NERR_InvalidDatabase:              return "The security database is corrupted.";
+    case NERR_DatabaseUpToDate:             return "No updates are necessary to this replicant network/local security database.";
+    case NERR_SyncRequired:                 return "This replicant database is outdated; synchronization is required.";
+    case NERR_UseNotFound:                  return "The network connection could not be found.";
+    case NERR_BadAsgType:                   return "This asg_type is invalid.";
+    case NERR_DeviceIsShared:               return "This device is currently being shared.";
+    case NERR_NoComputerName:               return "The computer name could not be added as a message alias. The name may already exist on the network.";
+    case NERR_MsgAlreadyStarted:            return "The Messenger service is already started.";
+    case NERR_MsgInitFailed:                return "The Messenger service failed to start.";
+    case NERR_NameNotFound:                 return "The message alias could not be found on the network.";
+    case NERR_AlreadyForwarded:             return "This message alias has already been forwarded.";
+    case NERR_AddForwarded:                 return "This message alias has been added but is still forwarded.";
+    case NERR_AlreadyExists:                return "This message alias already exists locally.";
+    case NERR_TooManyNames:                 return "The maximum number of added message aliases has been exceeded.";
+    case NERR_DelComputerName:              return "The computer name could not be deleted.";
+    case NERR_LocalForward:                 return "Messages cannot be forwarded back to the same workstation.";
+    case NERR_GrpMsgProcessor:              return "An error occurred in the domain message processor.";
+    case NERR_PausedRemote:                 return "The message was sent, but the recipient has paused the Messenger service.";
+    case NERR_BadReceive:                   return "The message was sent but not received.";
+    case NERR_NameInUse:                    return "The message alias is currently in use. Try again later.";
+    case NERR_MsgNotStarted:                return "The Messenger service has not been started.";
+    case NERR_NotLocalName:                 return "The name is not on the local computer.";
+    case NERR_NoForwardName:                return "The forwarded message alias could not be found on the network.";
+    case NERR_RemoteFull:                   return "The message alias table on the remote station is full.";
+    case NERR_NameNotForwarded:             return "Messages for this alias are not currently being forwarded.";
+    case NERR_TruncatedBroadcast:           return "The broadcast message was truncated.";
+    case NERR_InvalidDevice:                return "This is an invalid device name.";
+    case NERR_WriteFault:                   return "A write fault occurred.";
+    case NERR_DuplicateName:                return "A duplicate message alias exists on the network.";
+    case NERR_DeleteLater:                  return "@W This message alias will be deleted later.";
+    case NERR_IncompleteDel:                return "The message alias was not successfully deleted from all networks.";
+    case NERR_MultipleNets:                 return "This operation is not supported on computers with multiple networks.";
+    case NERR_NetNameNotFound:              return "This shared resource does not exist.";
+    case NERR_DeviceNotShared:              return "This device is not shared.";
+    case NERR_ClientNameNotFound:           return "A session does not exist with that computer name.";
+    case NERR_FileIdNotFound:               return "There is not an open file with that identification number.";
+    case NERR_ExecFailure:                  return "A failure occurred when executing a remote administration command.";
+    case NERR_TmpFile:                      return "A failure occurred when opening a remote temporary file.";
+    case NERR_TooMuchData:                  return "The data returned from a remote administration command has been truncated to 64K.";
+    case NERR_DeviceShareConflict:          return "This device cannot be shared as both a spooled and a non-spooled resource.";
+    case NERR_BrowserTableIncomplete:       return "The information in the list of servers may be incorrect.";
+    case NERR_NotLocalDomain:               return "The computer is not active in this domain.";
+#ifdef NERR_IsDfsShare
+    case NERR_IsDfsShare:                   return "The share must be removed from the Distributed File System before it can be deleted.";
+#endif
+    case NERR_DevInvalidOpCode:             return "The operation is invalid for this device.";
+    case NERR_DevNotFound:                  return "This device cannot be shared.";
+    case NERR_DevNotOpen:                   return "This device was not open.";
+    case NERR_BadQueueDevString:            return "This device name list is invalid.";
+    case NERR_BadQueuePriority:             return "The queue priority is invalid.";
+    case NERR_NoCommDevs:                   return "There are no shared communication devices.";
+    case NERR_QueueNotFound:                return "The queue you specified does not exist.";
+    case NERR_BadDevString:                 return "This list of devices is invalid.";
+    case NERR_BadDev:                       return "The requested device is invalid.";
+    case NERR_InUseBySpooler:               return "This device is already in use by the spooler.";
+    case NERR_CommDevInUse:                 return "This device is already in use as a communication device.";
+    case NERR_InvalidComputer:              return "This computer name is invalid.";
+    case NERR_MaxLenExceeded:               return "The string and prefix specified are too long.";
+    case NERR_BadComponent:                 return "This path component is invalid.";
+    case NERR_CantType:                     return "Could not determine the type of input.";
+    case NERR_TooManyEntries:               return "The buffer for types is not big enough.";
+    case NERR_ProfileFileTooBig:            return "Profile files cannot exceed 64K.";
+    case NERR_ProfileOffset:                return "The start offset is out of range.";
+    case NERR_ProfileCleanup:               return "The system cannot delete current connections to network resources.";
+    case NERR_ProfileUnknownCmd:            return "The system was unable to parse the command line in this file.";
+    case NERR_ProfileLoadErr:               return "An error occurred while loading the profile file.";
+    case NERR_ProfileSaveErr:               return "@W Errors occurred while saving the profile file. The profile was partially saved.";
+    case NERR_LogOverflow:                  return "Log file %1 is full.";
+    case NERR_LogFileChanged:               return "This log file has changed between reads.";
+    case NERR_LogFileCorrupt:               return "Log file %1 is corrupt.";
+    case NERR_SourceIsDir:                  return "The source path cannot be a directory.";
+    case NERR_BadSource:                    return "The source path is illegal.";
+    case NERR_BadDest:                      return "The destination path is illegal.";
+    case NERR_DifferentServers:             return "The source and destination paths are on different servers.";
+    case NERR_RunSrvPaused:                 return "The Run server you requested is paused.";
+    case NERR_ErrCommRunSrv:                return "An error occurred when communicating with a Run server.";
+    case NERR_ErrorExecingGhost:            return "An error occurred when starting a background process.";
+    case NERR_ShareNotFound:                return "The shared resource you are connected to could not be found.";
+    case NERR_InvalidLana:                  return "The LAN adapter number is invalid.";
+    case NERR_OpenFiles:                    return "There are open files on the connection.";
+    case NERR_ActiveConns:                  return "Active connections still exist.";
+    case NERR_BadPasswordCore:              return "This share name or password is invalid.";
+    case NERR_DevInUse:                     return "The device is being accessed by an active process.";
+    case NERR_LocalDrive:                   return "The drive letter is in use locally.";
+    case NERR_AlertExists:                  return "The specified client is already registered for the specified event.";
+    case NERR_TooManyAlerts:                return "The alert table is full.";
+    case NERR_NoSuchAlert:                  return "An invalid or nonexistent alert name was raised.";
+    case NERR_BadRecipient:                 return "The alert recipient is invalid.";
+    case NERR_AcctLimitExceeded:            return "A user's session with this server has been deleted.";
+    case NERR_InvalidLogSeek:               return "The log file does not contain the requested record number.";
+    case NERR_BadUasConfig:                 return "The user accounts database is not configured correctly.";
+    case NERR_InvalidUASOp:                 return "This operation is not permitted when the Netlogon service is running.";
+    case NERR_LastAdmin:                    return "This operation is not allowed on the last administrative account.";
+    case NERR_DCNotFound:                   return "Could not find domain controller for this domain.";
+    case NERR_LogonTrackingError:           return "Could not set logon information for this user.";
+    case NERR_NetlogonNotStarted:           return "The Netlogon service has not been started.";
+    case NERR_CanNotGrowUASFile:            return "Unable to add to the user accounts database.";
+    case NERR_TimeDiffAtDC:                 return "This server's clock is not synchronized with the primary domain controller's clock.";
+    case NERR_PasswordMismatch:             return "A password mismatch has been detected.";
+    case NERR_NoSuchServer:                 return "The server identification does not specify a valid server.";
+    case NERR_NoSuchSession:                return "The session identification does not specify a valid session.";
+    case NERR_NoSuchConnection:             return "The connection identification does not specify a valid connection.";
+    case NERR_TooManyServers:               return "There is no space for another entry in the table of available servers.";
+    case NERR_TooManySessions:              return "The server has reached the maximum number of sessions it supports.";
+    case NERR_TooManyConnections:           return "The server has reached the maximum number of connections it supports.";
+    case NERR_TooManyFiles:                 return "The server cannot open more files because it has reached its maximum number.";
+    case NERR_NoAlternateServers:           return "There are no alternate servers registered on this server.";
+    case NERR_TryDownLevel:                 return "Try down-level (remote admin protocol) version of API instead.";
+    case NERR_UPSDriverNotStarted:          return "The UPS driver could not be accessed by the UPS service.";
+    case NERR_UPSInvalidConfig:             return "The UPS service is not configured correctly.";
+    case NERR_UPSInvalidCommPort:           return "The UPS service could not access the specified Comm Port.";
+    case NERR_UPSSignalAsserted:            return "The UPS indicated a line fail or low battery situation. Service not started.";
+    case NERR_UPSShutdownFailed:            return "The UPS service failed to perform a system shut down.";
+    case NERR_BadDosRetCode:                return "The program below returned an MS-DOS error code:";
+    case NERR_ProgNeedsExtraMem:            return "The program below needs more memory:";                                                      
+    case NERR_BadDosFunction:               return "The program below called an unsupported MS-DOS function:";
+    case NERR_RemoteBootFailed:             return "The workstation failed to boot.";
+    case NERR_BadFileCheckSum:              return "The file below is corrupt.";
+    case NERR_NoRplBootSystem:              return "No loader is specified in the boot-block definition file.";
+    case NERR_RplLoadrNetBiosErr:           return "NetBIOS returned an error:      The NCB and SMB are dumped above.";
+    case NERR_RplLoadrDiskErr:              return "A disk I/O error occurred.";
+    case NERR_ImageParamErr:                return "Image parameter substitution failed.";
+    case NERR_TooManyImageParams:           return "Too many image parameters cross disk sector boundaries.";
+    case NERR_NonDosFloppyUsed:             return "The image was not generated from an MS-DOS diskette formatted with /S.";
+    case NERR_RplBootRestart:               return "Remote boot will be restarted later.";
+    case NERR_RplSrvrCallFailed:            return "The call to the Remoteboot server failed.";
+    case NERR_CantConnectRplSrvr:           return "Cannot connect to the Remoteboot server.";
+    case NERR_CantOpenImageFile:            return "Cannot open image file on the Remoteboot server.";
+    case NERR_CallingRplSrvr:               return "Connecting to the Remoteboot server...";
+    case NERR_StartingRplBoot:              return "Connecting to the Remoteboot server...";
+    case NERR_RplBootServiceTerm:           return "Remote boot service was stopped; check the error log for the cause of the problem.";
+    case NERR_RplBootStartFailed:           return "Remote boot startup failed; check the error log for the cause of the problem.";
+    case NERR_RPL_CONNECTED:                return "A second connection to a Remoteboot resource is not allowed.";
+    case NERR_BrowserConfiguredToNotRun:    return "The browser service was configured with MaintainServerList=No.";
+    case NERR_RplNoAdaptersStarted:         return "Service failed to start since none of the network adapters started with this service.";
+    case NERR_RplBadRegistry:               return "Service failed to start due to bad startup information in the registry.";
+    case NERR_RplBadDatabase:               return "Service failed to start because its database is absent or corrupt.";
+    case NERR_RplRplfilesShare:             return "Service failed to start because RPLFILES share is absent.";
+    case NERR_RplNotRplServer:              return "Service failed to start because RPLUSER group is absent.";
+    case NERR_RplCannotEnum:                return "Cannot enumerate service records.";
+    case NERR_RplWkstaInfoCorrupted:        return "Workstation record information has been corrupted.";
+    case NERR_RplWkstaNotFound:             return "Workstation record was not found.";
+    case NERR_RplWkstaNameUnavailable:      return "Workstation name is in use by some other workstation.";
+    case NERR_RplProfileInfoCorrupted:      return "Profile record information has been corrupted.";
+    case NERR_RplProfileNotFound:           return "Profile record was not found.";
+    case NERR_RplProfileNameUnavailable:    return "Profile name is in use by some other profile.";
+    case NERR_RplProfileNotEmpty:           return "There are workstations using this profile.";
+    case NERR_RplConfigInfoCorrupted:       return "Configuration record information has been corrupted.";
+    case NERR_RplConfigNotFound:            return "Configuration record was not found.";
+    case NERR_RplAdapterInfoCorrupted:      return "Adapter ID record information has been corrupted.";
+    case NERR_RplInternal:                  return "An internal service error has occurred.";
+    case NERR_RplVendorInfoCorrupted:       return "Vendor ID record information has been corrupted.";
+    case NERR_RplBootInfoCorrupted:         return "Boot block record information has been corrupted.";
+    case NERR_RplWkstaNeedsUserAcct:        return "The user account for this workstation record is missing.";
+    case NERR_RplNeedsRPLUSERAcct:          return "The RPLUSER local group could not be found.";
+    case NERR_RplBootNotFound:              return "Boot block record was not found.";
+    case NERR_RplIncompatibleProfile:       return "Chosen profile is incompatible with this workstation.";
+    case NERR_RplAdapterNameUnavailable:    return "Chosen network adapter ID is in use by some other workstation.";
+    case NERR_RplConfigNotEmpty:            return "There are profiles using this configuration.";
+    case NERR_RplBootInUse:                 return "There are workstations, profiles, or configurations using this boot block.";
+    case NERR_RplBackupDatabase:            return "Service failed to backup Remoteboot database.";
+    case NERR_RplAdapterNotFound:           return "Adapter record was not found.";
+    case NERR_RplVendorNotFound:            return "Vendor record was not found.";
+    case NERR_RplVendorNameUnavailable:     return "Vendor name is in use by some other vendor record.";
+    case NERR_RplBootNameUnavailable:       return "(boot name, vendor ID) is in use by some other boot block record.";
+    case NERR_RplConfigNameUnavailable:     return "Configuration name is in use by some other configuration.";
+    case NERR_DfsInternalCorruption:        return "The internal database maintained by the Dfs service is corrupt.";
+    case NERR_DfsVolumeDataCorrupt:         return "One of the records in the internal Dfs database is corrupt.";
+    case NERR_DfsNoSuchVolume:              return "There is no DFS name whose entry path matches the input Entry Path.";
+    case NERR_DfsVolumeAlreadyExists:       return "A root or link with the given name already exists.";
+    case NERR_DfsAlreadyShared:             return "The server share specified is already shared in the Dfs.";
+    case NERR_DfsNoSuchShare:               return "The indicated server share does not support the indicated DFS namespace.";
+    case NERR_DfsNotALeafVolume:            return "The operation is not valid on this portion of the namespace.";
+    case NERR_DfsLeafVolume:                return "The operation is not valid on this portion of the namespace.";
+    case NERR_DfsVolumeHasMultipleServers:  return "The operation is ambiguous because the link has multiple servers.";
+    case NERR_DfsCantCreateJunctionPoint:   return "Unable to create a link.";
+    case NERR_DfsServerNotDfsAware:         return "The server is not Dfs Aware.";
+    case NERR_DfsBadRenamePath:             return "The specified rename target path is invalid.";
+    case NERR_DfsVolumeIsOffline:           return "The specified DFS link is offline.";
+    case NERR_DfsNoSuchServer:              return "The specified server is not a server for this link.";
+    case NERR_DfsCyclicalName:              return "A cycle in the Dfs name was detected.";
+    case NERR_DfsNotSupportedInServerDfs:   return "The operation is not supported on a server-based Dfs.";
+    case NERR_DfsDuplicateService:          return "This link is already supported by the specified server-share.";
+    case NERR_DfsCantRemoveLastServerShare: return "Can't remove the last server-share supporting this root or link.";
+    case NERR_DfsVolumeIsInterDfs:          return "The operation is not supported for an Inter-DFS link.";
+    case NERR_DfsInconsistent:              return "The internal state of the Dfs Service has become inconsistent.";
+    case NERR_DfsServerUpgraded:            return "The Dfs Service has been installed on the specified server.";
+    case NERR_DfsDataIsIdentical:           return "The Dfs data being reconciled is identical.";
+    case NERR_DfsCantRemoveDfsRoot:         return "The DFS root cannot be deleted. Uninstall DFS if required.";
+    case NERR_DfsChildOrParentInDfs:        return "A child or parent directory of the share is already in a Dfs.";
+    case NERR_DfsInternalError:             return "Dfs internal error.";
+/* the following are not defined in mingw */
+#if 0
+    case NERR_SetupAlreadyJoined:           return "This machine is already joined to a domain.";
+    case NERR_SetupNotJoined:               return "This machine is not currently joined to a domain.";
+    case NERR_SetupDomainController:        return "This machine is a domain controller and cannot be unjoined from a domain.";
+    case NERR_DefaultJoinRequired:          return "The destination domain controller does not support creating machine accounts in OUs.";
+    case NERR_InvalidWorkgroupName:         return "The specified workgroup name is invalid.";
+    case NERR_NameUsesIncompatibleCodePage: return "The specified computer name is incompatible with the default language used on the domain controller.";
+    case NERR_ComputerAccountNotFound:      return "The specified computer account could not be found.";
+    case NERR_PersonalSku:                  return "This version of Windows cannot be joined to a domain.";
+    case NERR_PasswordMustChange:           return "The password must change at the next logon.";
+    case NERR_AccountLockedOut:             return "The account is locked out.";
+    case NERR_PasswordTooLong:              return "The password is too long.";
+    case NERR_PasswordNotComplexEnough:     return "The password does not meet the complexity policy.";
+    case NERR_PasswordFilterError:          return "The password does not meet the requirements of the password filter DLLs.";
+#endif 
+		}
+  msg = strerror (error_number);
+  if (msg == NULL)
+    msg = "unknown";
+
+  return msg;
+}
+#endif
+
 /**
  * signal (SIGPIPE, SIG_IGN);
  */
 void
 _dbus_disable_sigpipe (void)
 {
+#ifndef _WIN32
   signal (SIGPIPE, SIG_IGN);
+#endif
 }
 
 /**
@@ -2660,6 +4171,7 @@
 void
 _dbus_fd_set_close_on_exec (int fd)
 {
+#ifndef _WIN32
   int val;
   
   val = fcntl (fd, F_GETFD, 0);
@@ -2670,15 +4182,30 @@
   val |= FD_CLOEXEC;
   
   fcntl (fd, F_SETFD, val);
+#else
+	int fd2;
+	if (fd < 0) 
+		return;
+  _DBUS_LOCK (win32_fds);
+
+  fd2 = UNRANDOMIZE (fd);
+	_dbus_verbose("fd %d %d %d\n",fd,fd2,win32_n_fds);
+  _dbus_assert (fd2 >= 0 && fd2 < win32_n_fds);
+  _dbus_assert (win32_fds != NULL);
+
+  win32_fds[fd2].close_on_exec = TRUE;
+
+  _DBUS_UNLOCK (win32_fds);
+#endif
 }
 
 /**
- * Converts a UNIX errno into a #DBusError name.
+ * Converts a UNIX errno or a Winsock error code into a #DBusError name.
  *
  * @todo should cover more errnos, specifically those
  * from open().
  * 
- * @param error_number the errno.
+ * @param error_number the errno or Winsock error code.
  * @returns an error name
  */
 const char*
@@ -2792,6 +4319,8 @@
 _dbus_close (int        fd,
              DBusError *error)
 {
+#ifndef _WIN32
+
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
   
  again:
@@ -2805,6 +4334,73 @@
       return FALSE;
     }
 
+#else
+
+  const int encapsulated_fd = fd;
+
+  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
+  
+  _DBUS_LOCK (win32_fds);
+
+  fd = UNRANDOMIZE (fd);
+
+  _dbus_assert (fd >= 0 && fd < win32_n_fds);
+  _dbus_assert (win32_fds != NULL);
+
+  switch (win32_fds[fd].type)
+    {
+    case DBUS_WIN32_FD_SOCKET:
+      if (win32_fds[fd].port_file_fd >= 0)
+	{
+	  _chsize (win32_fds[fd].port_file_fd, 0);
+	  close (win32_fds[fd].port_file_fd);
+	  win32_fds[fd].port_file_fd = -1;
+	  unlink (_dbus_string_get_const_data (&win32_fds[fd].port_file));
+	  free ((char *) _dbus_string_get_const_data (&win32_fds[fd].port_file));
+	}
+      
+      if (closesocket (win32_fds[fd].fd) == SOCKET_ERROR)
+	{
+	  DBUS_SOCKET_SET_ERRNO ();
+	  dbus_set_error (error, _dbus_error_from_errno (errno),
+			  "Could not close socket %d:%d:%d %s",
+			  encapsulated_fd, fd, win32_fds[fd].fd,
+			  _dbus_strerror (errno));
+	  _DBUS_UNLOCK (win32_fds);
+	  return FALSE;
+	}
+      _dbus_verbose ("closed socket %d:%d:%d\n",
+		     encapsulated_fd, fd, win32_fds[fd].fd);
+      _DBUS_UNLOCK (win32_fds);
+      break;
+
+    case DBUS_WIN32_FD_C_LIB:
+      if (close (win32_fds[fd].fd) == -1)
+	{
+	  dbus_set_error (error, _dbus_error_from_errno (errno),
+			  "Could not close fd %d:%d:%d: %s",
+			  encapsulated_fd, fd, win32_fds[fd].fd,
+			  _dbus_strerror (errno));
+	  _DBUS_UNLOCK (win32_fds);
+	  return FALSE;
+	}
+      _dbus_verbose ("closed C file descriptor %d:%d:%d\n",
+		     encapsulated_fd, fd, win32_fds[fd].fd);
+      _DBUS_UNLOCK (win32_fds);
+      break;
+
+    default:
+      _dbus_assert_not_reached ("unhandled fd type");
+    }
+
+  _DBUS_UNLOCK (win32_fds);
+
+  _dbus_win32_deallocate_fd (encapsulated_fd);
+
+  return TRUE;
+
+#endif
+
   return TRUE;
 }
 
@@ -2819,10 +4415,16 @@
 _dbus_set_fd_nonblocking (int             fd,
                           DBusError      *error)
 {
+#ifndef _WIN32
   int val;
+#else
+  u_long one = 1;
+  const int encapsulated_fd = fd;
+#endif
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
   
+#ifndef _WIN32
   val = fcntl (fd, F_GETFL, 0);
   if (val < 0)
     {
@@ -2846,6 +4448,41 @@
     }
 
   return TRUE;
+#else
+
+  _DBUS_LOCK (win32_fds);
+
+  fd = UNRANDOMIZE (fd);
+
+  _dbus_assert (fd >= 0 && fd < win32_n_fds);
+  _dbus_assert (win32_fds != NULL);
+
+  switch (win32_fds[fd].type)
+    {
+    case DBUS_WIN32_FD_SOCKET:
+      if (ioctlsocket (win32_fds[fd].fd, FIONBIO, &one) == SOCKET_ERROR)
+	{
+	  dbus_set_error (error, _dbus_error_from_errno (WSAGetLastError ()),
+			  "Failed to set socket %d:%d to nonblocking: %s",
+			  encapsulated_fd, win32_fds[fd].fd,
+			  _dbus_strerror (WSAGetLastError ()));
+	  _DBUS_UNLOCK (win32_fds);
+	  return FALSE;
+	}
+      break;
+
+    case DBUS_WIN32_FD_C_LIB:
+      _dbus_assert_not_reached ("only sockets can be set to nonblocking");
+      break;
+
+    default:
+      _dbus_assert_not_reached ("unhandled fd type");
+    }
+
+  _DBUS_UNLOCK (win32_fds);
+
+  return TRUE;
+#endif
 }
 
 #if !defined (DBUS_DISABLE_ASSERT) || defined(DBUS_BUILD_TESTS)
@@ -2893,8 +4530,12 @@
 _dbus_parse_uid (const DBusString      *uid_str,
                  dbus_uid_t            *uid)
 {
+  dbus_uid_t val;
+#ifdef _WIN32
+  PSID sid;
+#else
   int end;
-  long val;
+#endif
   
   if (_dbus_string_get_length (uid_str) == 0)
     {
@@ -2902,6 +4543,7 @@
       return FALSE;
     }
 
+#ifndef _WIN32
   val = -1;
   end = 0;
   if (!_dbus_string_parse_int (uid_str, 0, &val,
@@ -2916,6 +4558,15 @@
       _dbus_verbose ("string contained trailing stuff after UID\n");
       return FALSE;
     }
+#else
+  /* Yeah, it's a bit silly do convert back and forth to a PSID */
+  if (!ConvertStringSidToSidA (_dbus_string_get_const_data (uid_str), &sid))
+    return FALSE;
+
+  val = _dbus_win32_sid_to_uid_t (sid);
+  
+  LocalFree (sid);
+#endif
 
   *uid = val;
 
@@ -2975,6 +4626,163 @@
                  *fd1, *fd2);
   
   return TRUE;  
+
+#elif defined (_WIN32)
+
+  SOCKET temp, socket1 = -1, socket2 = -1;
+  struct sockaddr_in saddr;
+  int len;
+  u_long arg;
+  fd_set read_set, write_set;
+  struct timeval tv;
+
+  _dbus_win32_startup_winsock ();
+
+  temp = socket (AF_INET, SOCK_STREAM, 0);
+  if (temp == INVALID_SOCKET)
+    {
+      DBUS_SOCKET_SET_ERRNO ();
+      goto out0;
+    }
+  
+  arg = 1;
+  if (ioctlsocket (temp, FIONBIO, &arg) == SOCKET_ERROR)
+    {
+      DBUS_SOCKET_SET_ERRNO ();
+      goto out0;
+    }
+
+  _DBUS_ZERO (saddr);
+  saddr.sin_family = AF_INET;
+  saddr.sin_port = 0;
+  saddr.sin_addr.s_addr = htonl (INADDR_LOOPBACK);
+
+  if (bind (temp, (struct sockaddr *)&saddr, sizeof (saddr)))
+    {
+      DBUS_SOCKET_SET_ERRNO ();
+      goto out0;
+    }
+
+  if (listen (temp, 1) == SOCKET_ERROR)
+    {
+      DBUS_SOCKET_SET_ERRNO ();
+      goto out0;
+    }
+
+  len = sizeof (saddr);
+  if (getsockname (temp, (struct sockaddr *)&saddr, &len))
+    {
+      DBUS_SOCKET_SET_ERRNO ();
+      goto out0;
+    }
+
+  socket1 = socket (AF_INET, SOCK_STREAM, 0);
+  if (socket1 == INVALID_SOCKET)
+    {
+      DBUS_SOCKET_SET_ERRNO ();
+      goto out0;
+    }
+  
+  arg = 1;
+  if (ioctlsocket (socket1, FIONBIO, &arg) == SOCKET_ERROR)
+    {
+      DBUS_SOCKET_SET_ERRNO ();
+      goto out1;
+    }
+
+  if (connect (socket1, (struct sockaddr  *)&saddr, len) != SOCKET_ERROR ||
+      WSAGetLastError () != WSAEWOULDBLOCK)
+    {
+      dbus_set_error_const (error, DBUS_ERROR_FAILED,
+			    "_dbus_full_duplex_pipe socketpair() emulation failed");
+      goto out1;
+    }
+
+  FD_ZERO (&read_set);
+  FD_SET (temp, &read_set);
+  
+  tv.tv_sec = 0;
+  tv.tv_usec = 0;
+
+  if (select (0, &read_set, NULL, NULL, NULL) == SOCKET_ERROR)
+    {
+      DBUS_SOCKET_SET_ERRNO ();
+      goto out1;
+    }
+
+  _dbus_assert (FD_ISSET (temp, &read_set));
+
+  socket2 = accept (temp, (struct sockaddr *) &saddr, &len);
+  if (socket2 == INVALID_SOCKET)
+    {
+      DBUS_SOCKET_SET_ERRNO ();
+      goto out1;
+    }
+
+  FD_ZERO (&write_set);
+  FD_SET (socket1, &write_set);
+
+  tv.tv_sec = 0;
+  tv.tv_usec = 0;
+
+  if (select (0, NULL, &write_set, NULL, NULL) == SOCKET_ERROR)
+    {
+      DBUS_SOCKET_SET_ERRNO ();
+      goto out2;
+    }
+
+  _dbus_assert (FD_ISSET (socket1, &write_set));
+
+  if (blocking)
+    {
+      arg = 0;
+      if (ioctlsocket (socket1, FIONBIO, &arg) == SOCKET_ERROR)
+	{
+	  DBUS_SOCKET_SET_ERRNO ();
+	  goto out2;
+	}
+
+      arg = 0;
+      if (ioctlsocket (socket2, FIONBIO, &arg) == SOCKET_ERROR)
+	{
+	  DBUS_SOCKET_SET_ERRNO ();
+	  goto out2;
+	}
+    }
+  else
+    {
+      arg = 1;
+      if (ioctlsocket (socket2, FIONBIO, &arg) == SOCKET_ERROR)
+	{
+	  DBUS_SOCKET_SET_ERRNO ();
+	  goto out2;
+	}
+    }
+      
+  
+  *fd1 = _dbus_encapsulate_socket (socket1);
+  *fd2 = _dbus_encapsulate_socket (socket2);
+
+  _dbus_verbose ("full-duplex pipe %d:%d <-> %d:%d\n",
+                 *fd1, socket1, *fd2, socket2);
+  
+  closesocket (temp);
+
+  return TRUE;
+
+ out2:
+  closesocket (socket2);
+ out1:
+  closesocket (socket1);
+ out0:
+  closesocket (temp);
+
+  dbus_set_error (error, _dbus_error_from_errno (errno),
+		  "Could not setup socket pair: %s",
+		  _dbus_strerror (errno));
+  
+  return FALSE;
+  
 #else
   _dbus_warn ("_dbus_full_duplex_pipe() not implemented on this OS\n");
   dbus_set_error (error, DBUS_ERROR_FAILED,
@@ -2983,6 +4791,463 @@
 #endif
 }
 
+#ifdef _WIN32
+
+static int
+_dbus_win32_allocate_fd (void)
+{
+  int i;
+
+  _DBUS_LOCK (win32_fds);
+
+  if (win32_fds == NULL)
+    {
+      DBusString random;
+
+      win32_n_fds = 16;
+      /* Use malloc to avoid memory leak failure in dbus-test */
+      win32_fds = malloc (win32_n_fds * sizeof (*win32_fds));
+
+      _dbus_assert (win32_fds != NULL);
+
+      for (i = 0; i < win32_n_fds; i++)
+	win32_fds[i].type = DBUS_WIN32_FD_UNUSED;
+
+      _dbus_string_init (&random);
+      _dbus_generate_random_bytes (&random, sizeof (int));
+      memmove (&win32_encap_randomizer, _dbus_string_get_const_data (&random), sizeof (int));
+      win32_encap_randomizer &= 0xFF;
+      _dbus_string_free (&random);
+    }
+
+  for (i = 0; i < win32_n_fds && win32_fds[i].type != DBUS_WIN32_FD_UNUSED; i++)
+    ;
+
+  if (i == win32_n_fds)
+    {
+      int oldn = win32_n_fds;
+      int j;
+
+      win32_n_fds += 16;
+      win32_fds = realloc (win32_fds, win32_n_fds * sizeof (*win32_fds));
+
+      _dbus_assert (win32_fds != NULL);
+
+      for (j = oldn; j < win32_n_fds; j++)
+	win32_fds[i].type = DBUS_WIN32_FD_UNUSED;
+    }
+
+  win32_fds[i].type = DBUS_WIN32_FD_BEING_OPENED;
+  win32_fds[i].fd = -1;
+  win32_fds[i].port_file_fd = -1;
+  win32_fds[i].close_on_exec = FALSE;
+  win32_fds[i].non_blocking = FALSE;
+
+  _DBUS_UNLOCK (win32_fds);
+
+  return i;
+}
+
+static void
+_dbus_win32_deallocate_fd (int fd)
+{
+  _DBUS_LOCK (win32_fds);
+  win32_fds[UNRANDOMIZE (fd)].type = DBUS_WIN32_FD_UNUSED;
+  _DBUS_UNLOCK (win32_fds);
+}
+
+static void
+_dbus_win32_startup_winsock (void)
+{
+  /* Straight from MSDN, deuglified */
+
+  static dbus_bool_t beenhere = FALSE;
+
+  WORD wVersionRequested;
+  WSADATA wsaData;
+  int err;
+ 
+  if (beenhere)
+    return;
+
+  wVersionRequested = MAKEWORD (2, 0);
+ 
+  err = WSAStartup (wVersionRequested, &wsaData);
+  if (err != 0)
+    {
+      _dbus_assert_not_reached ("Could not initialize WinSock");
+      _dbus_abort ();
+    }
+ 
+  /* Confirm that the WinSock DLL supports 2.0.  Note that if the DLL
+   * supports versions greater than 2.0 in addition to 2.0, it will
+   * still return 2.0 in wVersion since that is the version we
+   * requested.
+   */
+  if (LOBYTE (wsaData.wVersion) != 2 ||
+      HIBYTE (wsaData.wVersion) != 0)
+    {
+      _dbus_assert_not_reached ("No usable WinSock found");
+      _dbus_abort ();
+    }
+
+  beenhere = TRUE;
+}
+
+int
+_dbus_encapsulate_socket (int socket)
+{
+  int i = _dbus_win32_allocate_fd ();
+  int retval;
+
+  win32_fds[i].fd = socket;
+  win32_fds[i].type = DBUS_WIN32_FD_SOCKET;
+
+  retval = RANDOMIZE (i);
+
+  _dbus_verbose ("encapsulated socket %d:%d:%d\n", retval, i, socket);
+
+  return retval;
+}
+
+int
+_dbus_re_encapsulate_socket (int socket)
+{
+  int i;
+  int retval = -1;
+
+  _DBUS_LOCK (win32_fds);
+
+  _dbus_assert (win32_fds != NULL);
+
+  for (i = 0; i < win32_n_fds; i++)
+    if (win32_fds[i].type == DBUS_WIN32_FD_SOCKET &&
+	win32_fds[i].fd == socket)
+      {
+	retval = RANDOMIZE (i);
+	break;
+      }
+  
+  _DBUS_UNLOCK (win32_fds);
+
+  return retval;
+}
+
+int
+_dbus_encapsulate_fd (int fd)
+{
+  int i = _dbus_win32_allocate_fd ();
+  int retval;
+
+  win32_fds[i].fd = fd;
+  win32_fds[i].type = DBUS_WIN32_FD_C_LIB;
+
+  retval = RANDOMIZE (i);
+
+  _dbus_verbose ("encapsulated C file descriptor %d:%d:%d\n", retval, i, fd);
+
+  return retval;
+}
+
+int
+_dbus_re_encapsulate_fd (int fd)
+{
+  int i;
+  int retval = -1;
+
+  _DBUS_LOCK (win32_fds);
+
+  _dbus_assert (win32_fds != NULL);
+
+  for (i = 0; i < win32_n_fds; i++)
+    if (win32_fds[i].type == DBUS_WIN32_FD_C_LIB &&
+	win32_fds[i].fd == fd)
+      {
+	retval = RANDOMIZE (i);
+	break;
+      }
+  
+  _DBUS_UNLOCK (win32_fds);
+
+  return retval;
+}
+
+int
+_dbus_decapsulate (int fd)
+{
+  if (fd == -1)
+    return -1;
+
+  _DBUS_LOCK (win32_fds);
+
+  fd = UNRANDOMIZE (fd);
+
+  _dbus_assert (fd >= 0 && fd < win32_n_fds);
+  _dbus_assert (win32_fds != NULL);
+
+  fd = win32_fds[fd].fd;
+  
+  _DBUS_UNLOCK (win32_fds);
+
+  return fd;
+}
+
+dbus_bool_t
+_dbus_win32_account_to_sid (const wchar_t *waccount,
+			    void      	 **ppsid,
+			    DBusError 	  *error)
+{
+  dbus_bool_t retval = FALSE;
+  DWORD sid_length, wdomain_length;
+  SID_NAME_USE use;
+  wchar_t *wdomain;
+		     
+  *ppsid = NULL;
+
+  sid_length = 0;
+  wdomain_length = 0;
+  if (!LookupAccountNameW (NULL, waccount, NULL, &sid_length,
+			   NULL, &wdomain_length, &use) &&
+      GetLastError () != ERROR_INSUFFICIENT_BUFFER)
+    {
+      _dbus_win32_set_error_from_win32_error (error, GetLastError ());
+      return FALSE;
+    }
+
+  *ppsid = dbus_malloc (sid_length);
+  if (!*ppsid)
+    {
+      _DBUS_SET_OOM (error);
+      return FALSE;
+    }
+
+  wdomain = dbus_new (wchar_t, wdomain_length);
+  if (!wdomain)
+    {
+      _DBUS_SET_OOM (error);
+      goto out1;
+    }
+
+  if (!LookupAccountNameW (NULL, waccount, (PSID) *ppsid, &sid_length,
+			   wdomain, &wdomain_length, &use))
+    {
+      _dbus_win32_set_error_from_win32_error (error, GetLastError ());
+      goto out2;
+    }
+
+  if (!IsValidSid ((PSID) *ppsid))
+    {
+      dbus_set_error_const (error, DBUS_ERROR_FAILED, "Invalid SID");
+      goto out2;
+    }
+
+  retval = TRUE;
+
+ out2:
+  dbus_free (wdomain);
+ out1:
+  if (!retval)
+    {
+      dbus_free (*ppsid);
+      *ppsid = NULL;
+    }
+
+  return retval;
+}
+
+
+/**
+ * Returns the UTF-16 form of a UTF-8 string. The result should be
+ * freed with dbus_free() when no longer needed.
+ *
+ * @param str the UTF-8 string
+ * @param error return location for error code
+ */
+wchar_t *
+_dbus_win32_utf8_to_utf16 (const char *str,
+			   DBusError  *error)
+{
+  DBusString s;
+  int n;
+  wchar_t *retval;
+
+  _dbus_string_init_const (&s, str);
+  
+  if (!_dbus_string_validate_utf8 (&s, 0, _dbus_string_get_length (&s)))
+    {
+      dbus_set_error_const (error, DBUS_ERROR_FAILED, "Invalid UTF-8");
+      return NULL;
+    }
+
+  n = MultiByteToWideChar (CP_UTF8, 0, str, -1, NULL, 0);
+
+  if (n == 0)
+    {
+      _dbus_win32_set_error_from_win32_error (error, GetLastError ());
+      return NULL;
+    }
+
+  retval = dbus_new (wchar_t, n);
+
+  if (!retval)
+    {
+      _DBUS_SET_OOM (error);
+      return NULL;
+    }
+
+  if (MultiByteToWideChar (CP_UTF8, 0, str, -1, retval, n) != n)
+    {
+      dbus_free (retval);
+      dbus_set_error_const (error, DBUS_ERROR_FAILED, "MultiByteToWideChar inconsistency");
+      return NULL;
+    }
+
+  return retval;
+}
+
+/**
+ * Returns the UTF-8 form of a UTF-16 string. The result should be
+ * freed with dbus_free() when no longer needed.
+ *
+ * @param str the UTF-16 string
+ * @param error return location for error code
+ */
+char *
+_dbus_win32_utf16_to_utf8 (const wchar_t *str,
+			   DBusError     *error)
+{
+  int n;
+  char *retval;
+
+  n = WideCharToMultiByte (CP_UTF8, 0, str, -1, NULL, 0, NULL, NULL);
+
+  if (n == 0)
+    {
+      _dbus_win32_set_error_from_win32_error (error, GetLastError ());
+      return NULL;
+    }
+
+  retval = dbus_malloc (n);
+
+  if (!retval)
+    {
+      _DBUS_SET_OOM (error);
+      return NULL;
+    }
+
+  if (WideCharToMultiByte (CP_UTF8, 0, str, -1, retval, n, NULL, NULL) != n)
+    {
+      dbus_free (retval);
+      dbus_set_error_const (error, DBUS_ERROR_FAILED, "WideCharToMultiByte inconsistency");
+      return NULL;
+    }
+
+  return retval;
+}
+
+/**
+ * Assigns an error name and message corresponding to a Win32 error
+ * code to a DBusError. Does nothing if error is #NULL.
+ *
+ * @param error the error.
+ * @param code the Win32 error code
+ */
+void
+_dbus_win32_set_error_from_win32_error (DBusError *error,
+					int        code)
+{
+  char *msg;
+
+  /* As we want the English message, use the A API */
+  FormatMessageA (FORMAT_MESSAGE_ALLOCATE_BUFFER |
+		  FORMAT_MESSAGE_IGNORE_INSERTS |
+		  FORMAT_MESSAGE_FROM_SYSTEM,
+		  NULL, code, MAKELANGID (LANG_ENGLISH, SUBLANG_ENGLISH_US),
+		  (LPTSTR) &msg, 0, NULL);
+  if (msg)
+    {
+      char *msg_copy;
+
+      msg_copy = dbus_malloc (strlen (msg));
+      strcpy (msg_copy, msg);
+      LocalFree (msg);
+      
+      dbus_set_error (error, "Win32 error", "%s", msg_copy);
+    }
+  else
+    dbus_set_error_const (error, "Win32 error", "Unknown error code or FormatMessage failed");
+}
+
+static void
+_dbus_win32_warn_win32_error (const char *message,
+			      int         code)
+{
+  DBusError error;
+
+  dbus_error_init (&error);
+  _dbus_win32_set_error_from_win32_error (&error, code);
+  _dbus_warn ("%s: %s\n", message, error.message);
+  dbus_error_free (&error);
+}
+
+static void
+sid_cache_shutdown (void *data)
+{
+  _dbus_hash_table_unref (win32_sids);
+  win32_sids = NULL;
+}
+  
+/**
+ * Returns the textual form of a SID. The return value points
+ * to statically allocated memory and should not be freed.
+ *
+ * @param psid pointer to the SID
+ */
+dbus_uid_t
+_dbus_win32_sid_to_uid_t (void *psid)
+{
+  dbus_uid_t retval;
+  char *string, *oldval;
+  
+  if (!IsValidSid ((PSID) psid)) {
+ 		_dbus_verbose("%s invalid sid\n",__FUNCTION__);
+    return "-";
+	}  
+  if (!ConvertSidToStringSidA ((PSID) psid, &string)) {
+ 		_dbus_verbose("%s invalid sid\n",__FUNCTION__);
+    return "-";
+  }
+  
+  _DBUS_LOCK (win32_sids);
+
+  if (win32_sids == NULL)
+    {
+      win32_sids = _dbus_hash_table_new (DBUS_HASH_STRING, NULL, NULL);
+      _dbus_register_shutdown_func (sid_cache_shutdown, NULL);
+    }
+
+  oldval = _dbus_hash_table_lookup_string (win32_sids, string);
+
+  if (oldval)
+    {
+		_dbus_verbose("%s sid %s found in cache\n",__FUNCTION__,oldval);
+      LocalFree (string);
+      retval = oldval;
+    }
+  else
+    {
+      _dbus_hash_table_insert_string (win32_sids, string, string);
+		_dbus_verbose("%s sid %s added to cache\n",__FUNCTION__,string);
+      retval = string;
+    }
+
+  _DBUS_UNLOCK (win32_sids);
+
+  return retval;
+}
+
+#endif
+
 /** @} end of sysdeps */
 
 /* tests in dbus-sysdeps-util.c */
Index: dbus/dbus-sysdeps.h
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-sysdeps.h,v
retrieving revision 1.49
diff -u -b -B -r1.49 dbus-sysdeps.h
--- dbus/dbus-sysdeps.h	8 Jul 2005 14:36:22 -0000	1.49
+++ dbus/dbus-sysdeps.h	22 Jun 2006 11:39:20 -0000
@@ -28,6 +28,8 @@
 #include <config.h>
 
 #include <dbus/dbus-errors.h>
+#include <dbus/dbus-arch-deps.h>
+#include <dbus/dbus-platform-deps.h>
 
 /* this is perhaps bogus, but strcmp() etc. are faster if we use the
  * stuff straight out of string.h, so have this here for now.
@@ -72,9 +74,34 @@
 dbus_bool_t _dbus_setenv (const char *varname,
 			  const char *value);
 
+#ifdef _WIN32
+int _dbus_encapsulate_socket    (int socket);
+int _dbus_re_encapsulate_socket (int socket);
+int _dbus_encapsulate_fd        (int fd);
+int _dbus_re_encapsulate_fd     (int fd);
+int _dbus_decapsulate           (int fd);
+
+dbus_bool_t _dbus_win32_account_to_sid (const wchar_t *waccount,
+					void         **ppsid,
+					DBusError     *error);
+
+dbus_bool_t _dbus_win32_sid_to_name_and_domain (dbus_uid_t uid,
+						wchar_t  **wname,
+						wchar_t  **wdomain,
+						DBusError *error);
+
+#else
+#define _dbus_encapsulate_socket(socket) (socket)
+#define _dbus_re_encapsulate_socket(socket) (socket)
+#define _dbus_encapsulate_fd(fd) (fd)
+#define _dbus_re_encapsulate_fd(fd) (fd)
+#define _dbus_decapsulate(fd) (fd)
+#endif
+
 int _dbus_read      (int               fd,
                      DBusString       *buffer,
                      int               count);
+		    
 int _dbus_write     (int               fd,
                      const DBusString *buffer,
                      int               start,
@@ -87,18 +114,86 @@
                      int               start2,
                      int               len2);
 
+#ifndef _WIN32
 typedef unsigned long dbus_pid_t;
-typedef unsigned long dbus_uid_t;
-typedef unsigned long dbus_gid_t;
 
 #define DBUS_PID_UNSET ((dbus_pid_t) -1)
 #define DBUS_UID_UNSET ((dbus_uid_t) -1)
 #define DBUS_GID_UNSET ((dbus_gid_t) -1)
 
+#define DBUS_UID_ROOT ((dbus_uid_t) 0)                
+#define DBUS_GID_ROOT ((dbus_gid_t) 0)                
+                                                       
+#define DBUS_UID_EQUAL(a,b) (a == b)                  
+#define DBUS_GID_EQUAL(a,b) DBUS_UID_EQUAL (a, b)     
+
 #define DBUS_PID_FORMAT "%lu"
 #define DBUS_UID_FORMAT "%lu"
 #define DBUS_GID_FORMAT "%lu"
 
+#define _dbus_string_append_uid_t(s,uid) _dbus_string_append_uint (s, uid)                            
+                                                                                                     
+#define DBUS_HASH_UID_T DBUS_HASH_ULONG                                                               
+#define DBUS_TYPE_UID DBUS_TYPE_UINT32                                                                
+                                                                                                     
+#define _dbus_hash_table_lookup_uid_t(ht,uid) _dbus_hash_table_lookup_ulong (ht, uid)                 
+#define _dbus_hash_table_insert_uid_t(ht,uid,value) _dbus_hash_table_insert_ulong (ht, uid, value)    
+#define _dbus_hash_table_remove_uid_t(ht,uid) _dbus_hash_table_remove_ulong (ht, uid)                 
+#define _dbus_hash_iter_get_uid_t_key(iter) _dbus_hash_iter_get_ulong_key (iter)                      
+                                                                                                     
+#define _dbus_hash_table_lookup_gid_t(ht,gid) _dbus_hash_table_lookup_uid_t (ht, gid)                 
+#define _dbus_hash_table_insert_gid_t(ht,gid,value) _dbus_hash_table_insert_uid_t (ht, gid, value)    
+#define _dbus_hash_table_remove_gid_t(ht,gid) _dbus_hash_table_remove_uid_t (ht, gid)                 
+
+#define DBUS_CONSOLE_DIR "/var/run/console/"
+#else                                                                                                                              
+                                                                                                                                  
+typedef unsigned long dbus_pid_t;                                                                                                  
+                                                                                                                                  
+#define DBUS_PID_UNSET ((dbus_pid_t) -1)                                                                                           
+#define DBUS_UID_UNSET "S-1-0-0" /* Null */                                                                                        
+#define DBUS_GID_UNSET DBUS_UID_UNSET                                                                                              
+                                                                                                                                  
+#define DBUS_UID_ROOT ((dbus_uid_t) "S-1-5-32-500") /* Builtin Admin */                                                            
+#define DBUS_GID_ROOT ((dbus_gid_t) "S-1-5-32-544") /* Builtin Admins */                                                           
+                                                                                                                                  
+#define DBUS_UID_EQUAL(a,b) (strcmp (a, b) == 0)                                                                                   
+#define DBUS_GID_EQUAL(a,b) DBUS_UID_EQUAL (a, b)                                                                                  
+                                                                                                                                  
+#define DBUS_PID_FORMAT "%lu"                                                                                                      
+#define DBUS_UID_FORMAT "%s"                                                                                                       
+#define DBUS_GID_FORMAT "%s"                                                                                                       
+                                                                                                                                  
+#define _dbus_string_append_uid_t(s,uid) _dbus_string_append (s, uid)                                                              
+                                                                                                                                  
+#define DBUS_HASH_UID_T DBUS_HASH_STRING                                                                                           
+#define DBUS_TYPE_UID DBUS_TYPE_STRING                                                                                             
+                                                                                                                                  
+#define _dbus_hash_table_lookup_uid_t(ht,uid) _dbus_hash_table_lookup_string (ht, uid)                                             
+#define _dbus_hash_table_insert_uid_t(ht,uid,value) _dbus_hash_table_insert_string (ht, uid, value)                                
+#define _dbus_hash_table_remove_uid_t(ht,uid) _dbus_hash_table_remove_string (ht, uid)                                             
+#define _dbus_hash_iter_get_uid_t_key(iter) _dbus_hash_iter_get_string_key (iter)                                                  
+                                                                                                                                  
+#define _dbus_hash_table_lookup_gid_t(ht,gid) _dbus_hash_table_lookup_uid_t (ht, gid)                                              
+#define _dbus_hash_table_insert_gid_t(ht,gid,value) _dbus_hash_table_insert_uid_t (ht, gid, value)                                 
+#define _dbus_hash_table_remove_gid_t(ht,gid) _dbus_hash_table_remove_uid_t (ht, gid)                                              
+                                                                                                                                  
+/* Don't define DBUS_CONSOLE_DIR on Win32 */                                                                                       
+                                                                                                                                  
+wchar_t    *_dbus_win32_utf8_to_utf16 (const char    *str,                                                                         
+			       DBusError     *error);                                                                                              
+                                                                                                                                  
+char       *_dbus_win32_utf16_to_utf8 (const wchar_t *str,                                                                         
+			       DBusError     *error);                                                                                              
+                                                                                                                                  
+void        _dbus_win32_set_error_from_win32_error (DBusError *error,                                                              
+					    int        code);                                                                                                  
+dbus_uid_t  _dbus_win32_sid_to_uid_t  (void *psid);                                                                                
+                                                                                                                                  
+#endif                                                                                                                             
+                                                                                                                                    
+                                                                                                                                    
+
 /**
  * Struct representing socket credentials
  */
@@ -281,7 +376,7 @@
   unsigned long nlink; /**< Number of hard links */
   dbus_uid_t    uid;   /**< User owning file */
   dbus_gid_t    gid;   /**< Group owning file */
-  unsigned long size;  /**< Size of file */
+  dbus_uint64_t size;  /**< Size of file */
   unsigned long atime; /**< Access time */
   unsigned long mtime; /**< Modify time */
   unsigned long ctime; /**< Creation time */
@@ -305,8 +400,8 @@
 dbus_bool_t _dbus_write_pid_file  (const DBusString *filename,
                                    unsigned long     pid,
                                    DBusError        *error);
-dbus_bool_t _dbus_change_identity (unsigned long     uid,
-                                   unsigned long     gid,
+dbus_bool_t _dbus_change_identity (dbus_uid_t        uid,
+                                   dbus_gid_t        gid,
                                    DBusError        *error);
 
 typedef void (* DBusSignalHandler) (int sig);
Index: dbus/dbus-test-main.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-test-main.c,v
retrieving revision 1.8
diff -u -b -B -r1.8 dbus-test-main.c
--- dbus/dbus-test-main.c	21 Feb 2005 19:38:06 -0000	1.8
+++ dbus/dbus-test-main.c	22 Jun 2006 11:39:20 -0000
@@ -37,7 +37,6 @@
 
   setlocale(LC_ALL, "");
 
-  
   if (argc > 1)
     test_data_dir = argv[1];
   else
Index: dbus/dbus-test.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-test.c,v
retrieving revision 1.42
diff -u -b -B -r1.42 dbus-test.c
--- dbus/dbus-test.c	24 Feb 2005 16:03:56 -0000	1.42
+++ dbus/dbus-test.c	22 Jun 2006 11:39:20 -0000
@@ -33,6 +33,7 @@
 die (const char *failure)
 {
   fprintf (stderr, "Unit test failed: %s\n", failure);
+  if (!getenv ("DONT_DIE"))
   exit (1);
 }
 
@@ -153,9 +154,9 @@
   run_data_test ("message", specific_test, _dbus_message_test, test_data_dir);
   
   run_test ("hash", specific_test, _dbus_hash_test);
-
+#ifndef _WIN32
   run_data_test ("spawn", specific_test, _dbus_spawn_test, test_data_dir);
-  
+#endif
   run_data_test ("userdb", specific_test, _dbus_userdb_test, test_data_dir);
   
   run_test ("keyring", specific_test, _dbus_keyring_test);
Index: dbus/dbus-threads.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-threads.c,v
retrieving revision 1.23
diff -u -b -B -r1.23 dbus-threads.c
--- dbus/dbus-threads.c	26 Feb 2005 06:37:46 -0000	1.23
+++ dbus/dbus-threads.c	22 Jun 2006 11:39:20 -0000
@@ -222,6 +222,10 @@
   
   DBusMutex **global_locks[] = {
 #define LOCK_ADDR(name) (& _dbus_lock_##name)
+#ifdef _WIN32
+    LOCK_ADDR (win32_fds),
+    LOCK_ADDR (win32_sids),
+#endif
     LOCK_ADDR (list),
     LOCK_ADDR (connection_slots),
     LOCK_ADDR (pending_call_slots),
Index: dbus/dbus-transport-unix.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-transport-unix.c,v
retrieving revision 1.49
diff -u -b -B -r1.49 dbus-transport-unix.c
--- dbus/dbus-transport-unix.c	30 May 2006 15:34:10 -0000	1.49
+++ dbus/dbus-transport-unix.c	22 Jun 2006 11:39:21 -0000
@@ -22,6 +22,7 @@
  */
 
 #include "dbus-internals.h"
+#include "dbus-sockets.h"
 #include "dbus-connection-internal.h"
 #include "dbus-transport-unix.h"
 #include "dbus-transport-protected.h"
@@ -481,6 +482,10 @@
       _dbus_verbose ("Not authenticated, not writing anything\n");
       return TRUE;
     }
+#ifndef TML_STUFF
+  else
+    _dbus_verbose ("Yes, authenticated\n");
+#endif
 
   if (transport->disconnected)
     {
Index: dbus/dbus-transport.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-transport.c,v
retrieving revision 1.46
diff -u -b -B -r1.46 dbus-transport.c
--- dbus/dbus-transport.c	5 May 2005 22:02:11 -0000	1.46
+++ dbus/dbus-transport.c	22 Jun 2006 11:39:21 -0000
@@ -162,8 +162,8 @@
   transport->max_live_messages_size = _DBUS_ONE_MEGABYTE * 63;
   
   transport->credentials.pid = -1;
-  transport->credentials.uid = -1;
-  transport->credentials.gid = -1;
+  transport->credentials.uid = DBUS_UID_UNSET;
+  transport->credentials.gid = DBUS_GID_UNSET;
 
   _dbus_counter_set_notify (transport->live_messages_size,
                             transport->max_live_messages_size,
@@ -963,11 +963,11 @@
  */
 dbus_bool_t
 _dbus_transport_get_unix_user (DBusTransport *transport,
-                               unsigned long *uid)
+                               dbus_uid_t    *uid)
 {
   DBusCredentials auth_identity;
 
-  *uid = _DBUS_INT32_MAX; /* better than some root or system user in
+  *uid = DBUS_UID_UNSET; /* better than some root or system user in
                            * case of bugs in the caller. Caller should
                            * never use this value on purpose, however.
                            */
@@ -977,7 +977,7 @@
   
   _dbus_auth_get_identity (transport->auth, &auth_identity);
 
-  if (auth_identity.uid != DBUS_UID_UNSET)
+  if (!DBUS_UID_EQUAL (auth_identity.uid, DBUS_UID_UNSET))
     {
       *uid = auth_identity.uid;
       return TRUE;
Index: dbus/dbus-transport.h
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-transport.h,v
retrieving revision 1.20
diff -u -b -B -r1.20 dbus-transport.h
--- dbus/dbus-transport.h	26 Feb 2005 06:37:46 -0000	1.20
+++ dbus/dbus-transport.h	22 Jun 2006 11:39:21 -0000
@@ -57,7 +57,7 @@
                                                            long                        size);
 long               _dbus_transport_get_max_received_size  (DBusTransport              *transport);
 dbus_bool_t        _dbus_transport_get_unix_user          (DBusTransport              *transport,
-                                                           unsigned long              *uid);
+                                                           dbus_uid_t                 *uid);
 dbus_bool_t        _dbus_transport_get_unix_fd            (DBusTransport              *transport,
                                                            int                        *fd_p);
 
Index: dbus/dbus-userdb-util.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-userdb-util.c,v
retrieving revision 1.7
diff -u -b -B -r1.7 dbus-userdb-util.c
--- dbus/dbus-userdb-util.c	7 Jun 2006 19:59:11 -0000	1.7
+++ dbus/dbus-userdb-util.c	22 Jun 2006 11:39:21 -0000
@@ -131,7 +131,7 @@
       return FALSE;
     }
 
-  _dbus_assert (info->uid == uid);
+  _dbus_assert (DBUS_UID_EQUAL (info->uid, uid));
   
   credentials->pid = DBUS_PID_UNSET;
   credentials->uid = info->uid;
@@ -158,7 +158,7 @@
   if (!_dbus_credentials_from_username (username, &creds))
     return FALSE;
 
-  if (creds.uid == DBUS_UID_UNSET)
+  if (DBUS_UID_EQUAL (creds.uid, DBUS_UID_UNSET))
     return FALSE;
 
   *uid = creds.uid;
@@ -233,24 +233,28 @@
     }
 
 
-  if (gid != DBUS_GID_UNSET)
-    info = _dbus_hash_table_lookup_ulong (db->groups, gid);
+  if (!DBUS_GID_EQUAL (gid, DBUS_GID_UNSET))
+    info = _dbus_hash_table_lookup_gid_t (db->groups, gid);
   else
     info = _dbus_hash_table_lookup_string (db->groups_by_name,
                                            _dbus_string_get_const_data (groupname));
   if (info)
     {
+       if (!DBUS_GID_EQUAL (gid, DBUS_GID_UNSET))                                   
       _dbus_verbose ("Using cache for GID "DBUS_GID_FORMAT" information\n",
-                     info->gid);
+ 		       gid);                                                                   
+       else                                                                         
+ 	_dbus_verbose ("Using cache for group %s information\n",                         
+ 		       _dbus_string_get_const_data (groupname));                               
       return info;
     }
   else
     {
-      if (gid != DBUS_GID_UNSET)
+       if (!DBUS_GID_EQUAL (gid, DBUS_GID_UNSET))              
 	_dbus_verbose ("No cache for GID "DBUS_GID_FORMAT"\n",
 		       gid);
       else
-	_dbus_verbose ("No cache for groupname \"%s\"\n",
+ 	_dbus_verbose ("No cache for group %s\n",                   
 		       _dbus_string_get_const_data (groupname));
       
       info = dbus_new0 (DBusGroupInfo, 1);
@@ -260,7 +264,7 @@
           return NULL;
         }
 
-      if (gid != DBUS_GID_UNSET)
+      if (!DBUS_GID_EQUAL (gid, DBUS_GID_UNSET))
         {
           if (!_dbus_group_info_fill_gid (info, gid, error))
             {
@@ -283,7 +287,7 @@
       gid = DBUS_GID_UNSET;
       groupname = NULL;
 
-      if (!_dbus_hash_table_insert_ulong (db->groups, info->gid, info))
+      if (!_dbus_hash_table_insert_gid_t (db->groups, info->gid, info))
         {
           dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
           _dbus_group_info_free_allocated (info);
@@ -295,7 +299,7 @@
                                            info->groupname,
                                            info))
         {
-          _dbus_hash_table_remove_ulong (db->groups, info->gid);
+          _dbus_hash_table_remove_gid_t (db->groups, info->gid);
           dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
           return NULL;
         }
Index: dbus/dbus-userdb.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-userdb.c,v
retrieving revision 1.19
diff -u -b -B -r1.19 dbus-userdb.c
--- dbus/dbus-userdb.c	6 Mar 2006 19:06:45 -0000	1.19
+++ dbus/dbus-userdb.c	22 Jun 2006 11:39:21 -0000
@@ -28,6 +28,15 @@
 #include "dbus-protocol.h"
 #include <string.h>
 
+#ifdef _WIN32
+#include <windows.h>
+/* Declarations missing in mingw's headers */
+extern BOOL WINAPI ConvertStringSidToSidA (LPCSTR  StringSid,
+					   PSID   *Sid);
+extern BOOL WINAPI ConvertSidToStringSidA (PSID    Sid,
+					   LPSTR  *StringSid);
+#endif
+
 /**
  * @addtogroup DBusInternalsUtils
  * @{
@@ -49,6 +58,12 @@
   dbus_free (info);
 }
 
+void
+_dbus_group_info_free (DBusGroupInfo *info)
+{
+  dbus_free (info->groupname);
+}
+
 /**
  * Frees the given #DBusGroupInfo's members with _dbus_group_info_free()
  * and also calls dbus_free() on the block itself
@@ -107,7 +122,9 @@
   DBusUserInfo *info;
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
-  _dbus_assert (uid != DBUS_UID_UNSET || username != NULL);
+  _dbus_assert (!DBUS_UID_EQUAL (uid, DBUS_UID_UNSET) || username != NULL);
+ 	
+ 	_dbus_verbose("%s uid=%d\n",__FUNCTION__,uid);
 
   /* See if the username is really a number */
   if (uid == DBUS_UID_UNSET)
@@ -118,8 +135,8 @@
         uid = n;
     }
 
-  if (uid != DBUS_UID_UNSET)
-    info = _dbus_hash_table_lookup_ulong (db->users, uid);
+   if (!DBUS_UID_EQUAL (uid, DBUS_UID_UNSET))                  
+     info = _dbus_hash_table_lookup_uid_t (db->users, uid);    
   else
     info = _dbus_hash_table_lookup_string (db->users_by_name, _dbus_string_get_const_data (username));
   
@@ -141,11 +158,11 @@
       info = dbus_new0 (DBusUserInfo, 1);
       if (info == NULL)
         {
-          dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
+          _DBUS_SET_OOM (error);
           return NULL;
         }
 
-      if (uid != DBUS_UID_UNSET)
+      if (!DBUS_UID_EQUAL (uid, DBUS_UID_UNSET))
         {
           if (!_dbus_user_info_fill_uid (info, uid, error))
             {
@@ -169,7 +186,7 @@
       username = NULL;
 
       /* insert into hash */
-      if (!_dbus_hash_table_insert_ulong (db->users, info->uid, info))
+      if (!_dbus_hash_table_insert_uid_t (db->users, info->uid, info))
         {
           dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
           _dbus_user_info_free_allocated (info);
@@ -180,8 +197,8 @@
                                            info->username,
                                            info))
         {
-          _dbus_hash_table_remove_ulong (db->users, info->uid);
-          dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
+          _dbus_hash_table_remove_uid_t (db->users, info->uid);
+          _DBUS_SET_OOM (error);
           return NULL;
         }
       
@@ -447,13 +464,13 @@
 
   db->refcount = 1;
 
-  db->users = _dbus_hash_table_new (DBUS_HASH_ULONG,
+  db->users = _dbus_hash_table_new (DBUS_HASH_UID_T,
                                     NULL, (DBusFreeFunction) _dbus_user_info_free_allocated);
   
   if (db->users == NULL)
     goto failed;
 
-  db->groups = _dbus_hash_table_new (DBUS_HASH_ULONG,
+  db->groups = _dbus_hash_table_new (DBUS_HASH_UID_T,
                                      NULL, (DBusFreeFunction) _dbus_group_info_free_allocated);
   
   if (db->groups == NULL)
Index: dbus/dbus-watch.c
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus-watch.c,v
retrieving revision 1.18
diff -u -b -B -r1.18 dbus-watch.c
--- dbus/dbus-watch.c	26 Nov 2004 01:53:13 -0000	1.18
+++ dbus/dbus-watch.c	22 Jun 2006 11:39:21 -0000
@@ -51,6 +51,31 @@
   unsigned int enabled : 1;            /**< Whether it's enabled. */
 };
 
+#include <stdio.h>
+static char *
+tml_watch_flags (unsigned int flags)
+{
+  static char buf[1000];
+  char *p = buf;
+
+  if (flags == 0)
+    return "NONE";
+  
+  if (flags & DBUS_WATCH_READABLE)
+    p += sprintf (p, "READ");
+  if (flags & DBUS_WATCH_WRITABLE)
+    p += sprintf (p, "%sWRITE", (p == buf) ? "" : "|");
+  if (flags & DBUS_WATCH_ERROR)
+    p += sprintf (p, "%sERROR", (p == buf) ? "" : "|");
+  if (flags & DBUS_WATCH_HANGUP)
+    p += sprintf (p, "%sHANGUP", (p == buf) ? "" : "|");
+
+  if (p == buf)
+    sprintf (buf, "UNK(%#x)", flags);
+
+  return buf;
+}
+
 /**
  * Creates a new DBusWatch. Used to add a file descriptor to be polled
  * by a main loop.
@@ -90,6 +115,11 @@
   watch->handler_data = data;
   watch->free_handler_data_function = free_data_function;
   
+#ifndef TML_STUFF
+  _dbus_verbose ("_dbuw_watch_new: watch=%p flags=%s fd=%d:%d enabled=%d\n",
+		 watch, tml_watch_flags (flags), fd, _dbus_decapsulate (fd), enabled);
+#endif
+
   return watch;
 }
 
@@ -122,6 +152,11 @@
   watch->refcount -= 1;
   if (watch->refcount == 0)
     {
+#ifndef TML_STUFF
+      _dbus_verbose ("_dbus_watch_unref: freeing watch=%p flags=%s fd=%d:%d\n",
+		     watch, tml_watch_flags (watch->flags), watch->fd, _dbus_decapsulate (watch->fd));
+#endif
+
       dbus_watch_set_data (watch, NULL, NULL); /* call free_data_function */
 
       if (watch->free_handler_data_function)
@@ -417,6 +452,12 @@
   if (enabled == watch->enabled)
     return;
 
+#ifndef TML_STUFF
+  if (watch->enabled != enabled)
+    _dbus_verbose ("_dbus_watch_list_toggle_watch: watch=%p flags=%s fd=%d:%d enabled=%d\n",
+		   watch, tml_watch_flags (watch->flags), watch->fd, _dbus_decapsulate (watch->fd), enabled);
+#endif
+
   watch->enabled = enabled;
   
   if (watch_list->watch_toggled_function != NULL)
@@ -486,7 +527,10 @@
 int
 dbus_watch_get_fd (DBusWatch *watch)
 {
-  return watch->fd;
+  if (watch->fd == -1)
+    return -1;
+  else
+    return _dbus_decapsulate (watch->fd);
 }
 
 /**
Index: dbus/dbus.h
===================================================================
RCS file: /cvs/dbus/dbus/dbus/dbus.h,v
retrieving revision 1.21
diff -u -b -B -r1.21 dbus.h
--- dbus/dbus.h	25 Feb 2006 18:34:12 -0000	1.21
+++ dbus/dbus.h	22 Jun 2006 11:39:21 -0000
@@ -31,6 +31,7 @@
 #endif
 
 #include <dbus/dbus-arch-deps.h>
+#include <dbus/dbus-platform-deps.h>
 #include <dbus/dbus-address.h>
 #include <dbus/dbus-bus.h>
 #include <dbus/dbus-connection.h>
Index: glib/Makefile.am
===================================================================
RCS file: /cvs/dbus/dbus/glib/Makefile.am,v
retrieving revision 1.28
diff -u -b -B -r1.28 Makefile.am
--- glib/Makefile.am	29 Oct 2005 17:02:58 -0000	1.28
+++ glib/Makefile.am	22 Jun 2006 11:39:21 -0000
@@ -1,3 +1,13 @@
+if OS_WIN32
+no_undefined = -no-undefined
+libintl = -lintl
+libsocket = -lws2_32
+else
+no_undefined =
+libintl =
+libsocket =
+endif
+
 SUBDIRS = . examples
 
 INCLUDES=-I$(top_srcdir) $(DBUS_CLIENT_CFLAGS) $(DBUS_GLIB_CFLAGS) $(DBUS_GLIB_TOOL_CFLAGS) -DDBUS_COMPILATION=1 -DDBUS_LOCALEDIR=\"$(prefix)/@DATADIRNAME@/locale\"
@@ -57,7 +67,7 @@
 	dbus-gparser.c				\
 	dbus-gparser.h
 
-libdbus_gtool_la_LIBADD = libdbus-glib-1.la
+libdbus_gtool_la_LIBADD = libdbus-glib-1.la -lexpat
 
 bin_PROGRAMS=dbus-binding-tool
 
Index: glib/dbus-gmain.c
===================================================================
RCS file: /cvs/dbus/dbus/glib/dbus-gmain.c,v
retrieving revision 1.51
diff -u -b -B -r1.51 dbus-gmain.c
--- glib/dbus-gmain.c	15 Feb 2006 23:45:49 -0000	1.51
+++ glib/dbus-gmain.c	22 Jun 2006 11:39:22 -0000
@@ -33,6 +33,13 @@
 #include "dbus-gsignature.h"
 #include <string.h>
 
+#ifdef G_OS_WIN32
+#define STRICT
+#include <windows.h>
+#undef STRICT
+#include <winsock2.h>
+#endif
+
 #include <libintl.h>
 #define _(x) dgettext (GETTEXT_PACKAGE, x)
 #define N_(x) x
Index: test/Makefile.am
===================================================================
RCS file: /cvs/dbus/dbus/test/Makefile.am,v
retrieving revision 1.40
diff -u -b -B -r1.40 Makefile.am
--- test/Makefile.am	22 Nov 2005 20:37:00 -0000	1.40
+++ test/Makefile.am	22 Jun 2006 11:39:22 -0000
@@ -1,3 +1,8 @@
+if OS_WIN32
+break_loader =
+else
+break_loader = break-loader
+endif
 
 if HAVE_GLIB
     GLIB_SUBDIR=glib
Index: test/spawn-test.c
===================================================================
RCS file: /cvs/dbus/dbus/test/spawn-test.c,v
retrieving revision 1.3
diff -u -b -B -r1.3 spawn-test.c
--- test/spawn-test.c	5 Apr 2003 00:37:17 -0000	1.3
+++ test/spawn-test.c	22 Jun 2006 11:39:22 -0000
@@ -31,7 +31,7 @@
     argv_copy [i] = argv[i + 1];
   argv_copy[argc - 1] = NULL;
   
-  if (!_dbus_spawn_async_with_babysitter (NULL, argv_copy, setup_func, NULL, &error))
+  if (!_dbus_spawn_async_with_babysitter (NULL, argv_copy, NULL, setup_func, NULL, &error))
     {
       fprintf (stderr, "Could not launch application: \"%s\"\n",
 	       error.message);
Index: test/test-names.c
===================================================================
RCS file: /cvs/dbus/dbus/test/test-names.c,v
retrieving revision 1.1
diff -u -b -B -r1.1 test-names.c
--- test/test-names.c	12 Sep 2005 08:19:33 -0000	1.1
+++ test/test-names.c	22 Jun 2006 11:39:22 -0000
@@ -68,7 +68,6 @@
 
   TestName(connection, "org.freedesktop.DBus.Test", TRUE);
   TestName(connection, "org.freedesktop.DBus.Test-2", TRUE);
-  TestName(connection, "org.freedesktop.DBus.Test_2", TRUE);
 #if 0
   TestName(connection, "Test_2", TRUE);
 #endif
Index: test/test-segfault.c
===================================================================
RCS file: /cvs/dbus/dbus/test/test-segfault.c,v
retrieving revision 1.4
diff -u -b -B -r1.4 test-segfault.c
--- test/test-segfault.c	30 Nov 2005 19:32:26 -0000	1.4
+++ test/test-segfault.c	22 Jun 2006 11:39:22 -0000
@@ -2,14 +2,19 @@
 #include <stdlib.h>
 #include <signal.h>
 
+#ifndef _WIN32
 #include <sys/time.h>
 #include <sys/resource.h>
+#else
+#include <windows.h>
+#endif
 
 int
 main (int argc, char **argv)
 {
   char *p;  
 
+#ifndef _WIN32
   struct rlimit r = { 0, };
   
   getrlimit (RLIMIT_CORE, &r);
@@ -17,6 +22,12 @@
   setrlimit (RLIMIT_CORE, &r);
   
   raise (SIGSEGV);
+#else
+  /* No message boxes please, annoying to have to click through them
+   * when running bus-test.
+   */
+  SetErrorMode (SEM_NOGPFAULTERRORBOX);
+#endif
 
   p = NULL;
   *p = 'a';
Index: test/data/valid-config-files/many-rules.conf
===================================================================
RCS file: /cvs/dbus/dbus/test/data/valid-config-files/many-rules.conf,v
retrieving revision 1.4
diff -u -b -B -r1.4 many-rules.conf
--- test/data/valid-config-files/many-rules.conf	18 Jan 2005 20:42:15 -0000	1.4
+++ test/data/valid-config-files/many-rules.conf	22 Jun 2006 11:39:22 -0000
@@ -15,8 +15,8 @@
     <deny own="org.freedesktop.System"/>
     <deny send_destination="org.freedesktop.System"/>
     <deny receive_sender="org.freedesktop.System"/>
-    <deny user="root"/>
-    <deny group="root"/>
+    <deny user="administrator"/>
+    <deny group="administrators"/>
     <allow send_type="error"/>
     <allow send_type="method_call"/>
     <allow send_type="method_return"/>
@@ -33,8 +33,8 @@
     <deny own="org.freedesktop.System"/>
     <deny send_destination="org.freedesktop.System"/>
     <deny receive_sender="org.freedesktop.System"/>
-    <deny user="root"/>
-    <deny group="root"/>
+    <deny user="administrator"/>
+    <deny group="administrators"/>
     <allow send_type="error"/>
     <allow send_type="method_call"/>
     <allow send_type="method_return"/>
Index: test/data/valid-config-files/system.d/test.conf
===================================================================
RCS file: /cvs/dbus/dbus/test/data/valid-config-files/system.d/test.conf,v
retrieving revision 1.2
diff -u -b -B -r1.2 test.conf
--- test/data/valid-config-files/system.d/test.conf	30 Sep 2003 02:33:07 -0000	1.2
+++ test/data/valid-config-files/system.d/test.conf	22 Jun 2006 11:39:22 -0000
@@ -7,7 +7,7 @@
 
   <!-- Only root can own the FooService service, and 
        this user can only send the one kind of message -->
-  <policy user="root">
+  <policy user="administrator">
     <allow own="org.foo.FooService"/>
     <allow send_interface="org.foo.FooBroadcastInterface"/>
   </policy>
Index: test/glib/Makefile.am
===================================================================
RCS file: /cvs/dbus/dbus/test/glib/Makefile.am,v
retrieving revision 1.17
diff -u -b -B -r1.17 Makefile.am
--- test/glib/Makefile.am	23 Aug 2005 19:48:30 -0000	1.17
+++ test/glib/Makefile.am	22 Jun 2006 11:39:22 -0000
@@ -1,3 +1,8 @@
+if OS_WIN32
+else
+test_profile = test-profile
+endif
+
 INCLUDES=-I$(top_srcdir) $(DBUS_CLIENT_CFLAGS) $(DBUS_GLIB_CFLAGS) -DDBUS_COMPILATION
 
 ## note that TESTS has special meaning (stuff to use in make check)
@@ -15,7 +20,7 @@
 if DBUS_BUILD_TESTS
 
 if HAVE_GLIB_THREADS
-THREAD_APPS=test-thread-server test-thread-client test-profile
+THREAD_APPS=test-thread-server test-thread-client $(test_profile)
 
 test_thread_server_SOURCES=				\
 	test-thread-server.c				\
@@ -67,8 +72,11 @@
 ### not building tests
 
 if HAVE_GLIB_THREADS
+if OS_WIN32
+else
 noinst_PROGRAMS=test-profile
 endif
+endif
 
 endif
 
Index: tools/Makefile.am
===================================================================
RCS file: /cvs/dbus/dbus/tools/Makefile.am,v
retrieving revision 1.18
diff -u -b -B -r1.18 Makefile.am
--- tools/Makefile.am	14 Jun 2006 14:39:51 -0000	1.18
+++ tools/Makefile.am	22 Jun 2006 11:39:22 -0000
@@ -49,7 +49,11 @@
 	dbus-viewer.c
 
 dbus_send_LDADD= $(top_builddir)/dbus/libdbus-1.la
+<<<<<<< Makefile.am
+dbus_monitor_LDADD= $(top_builddir)/glib/libdbus-1.la
+=======
 dbus_monitor_LDADD= $(top_builddir)/dbus/libdbus-1.la
+>>>>>>> 1.18
 dbus_launch_LDADD= $(DBUS_X_LIBS)
 dbus_viewer_LDADD= $(top_builddir)/glib/libdbus-gtool.la $(DBUS_GTK_THREADS_LIBS) $(DBUS_GLIB_TOOL_LIBS)
 

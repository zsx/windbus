Index: test/spawn-test.c
===================================================================
--- test/spawn-test.c	(revision 279)
+++ test/spawn-test.c	(working copy)
@@ -31,7 +31,7 @@
     argv_copy [i] = argv[i + 1];
   argv_copy[argc - 1] = NULL;
   
-  if (!_dbus_spawn_async_with_babysitter (NULL, argv_copy, setup_func, NULL, &error))
+  if (!_dbus_spawn_async_with_babysitter (NULL, argv_copy, NULL, setup_func, NULL, &error))
     {
       fprintf (stderr, "Could not launch application: \"%s\"\n",
 	       error.message);
Index: test/name-test/test-names.c
===================================================================
--- test/name-test/test-names.c	(revision 279)
+++ test/name-test/test-names.c	(working copy)
@@ -1,9 +1,11 @@
 #include <stdio.h>
 #include <stdlib.h>
-#include <unistd.h>
 #include <string.h>
 #include <dbus/dbus.h>
 #include <dbus/dbus-connection-internal.h>
+#ifndef DBUS_WIN
+#include <unistd.h>
+#endif
 
 #define REMOVE_CONNECTION 0
 #define ADD_CONNECTION 1
Index: test/test-segfault.c
===================================================================
--- test/test-segfault.c	(revision 279)
+++ test/test-segfault.c	(working copy)
@@ -1,10 +1,27 @@
 /* This is simply a process that segfaults */
+#include <config.h>
 #include <stdlib.h>
 #include <signal.h>
 
+#ifdef DBUS_WIN
+#define RLIMIT_CORE	4		/* max core file size */
+typedef unsigned long rlim_t;
+struct rlimit {
+	rlim_t	rlim_cur;
+	rlim_t	rlim_max;
+};
+static int getrlimit (int __resource, struct rlimit *__rlp) {
+  return -1;
+}
+static int setrlimit (int __resource, const struct rlimit *__rlp) {
+  return -1;
+}
+#else
 #include <sys/time.h>
 #include <sys/resource.h>
+#endif
 
+
 int
 main (int argc, char **argv)
 {
Index: test/Makefile.am
===================================================================
--- test/Makefile.am	(revision 279)
+++ test/Makefile.am	(working copy)
@@ -110,7 +110,7 @@
 		test -d $(top_builddir)/test/$$D || mkdir $(top_builddir)/test/$$D || exit 1 ;	\
 	done ;											\
 	if ! (test $(srcdir) = . || test $(srcdir) -ef .) ; then								\
-		FILES=`(cd $(srcdir) && $(FIND_TESTS))` ;					\
+		FILES=`(cd $(srcdir) && $(FIND_TESTS) | grep -Ev "(.svn|CVS)" )` ;		\
 	        for F in $$FILES; do								\
 			SRC=$(srcdir)/$$F ;							\
 			DEST=$(top_builddir)/test/$$F ;						\
Index: test/test-sleep-forever.c
===================================================================
--- test/test-sleep-forever.c	(revision 279)
+++ test/test-sleep-forever.c	(working copy)
@@ -1,6 +1,12 @@
 /* This is a process that just sleeps infinitely. */
 
+
+#include <config.h>
+#ifndef DBUS_WIN
 #include <unistd.h>
+#else
+#include <stdlib.h>
+#endif
 
 int
 main (int argc, char **argv)
Index: bus/dispatch.c
===================================================================
--- bus/dispatch.c	(revision 279)
+++ bus/dispatch.c	(working copy)
@@ -4061,9 +4061,11 @@
       _dbus_warn ("Messages were left over after setting up initial SHA-1 connection\n");
       _dbus_assert_not_reached ("initial connection setup failed");
     }
-  
+
+#ifndef DBUS_WIN_FIXME  
   check1_try_iterations (context, "create_and_hello_sha1",
                          check_hello_connection);
+#endif
 
   kill_client_connection_unchecked (foo);
 
Index: bus/activation.c
===================================================================
--- bus/activation.c	(revision 279)
+++ bus/activation.c	(working copy)
@@ -34,7 +34,6 @@
 #include <dbus/dbus-spawn.h>
 #include <dbus/dbus-timeout.h>
 #include <dbus/dbus-sysdeps.h>
-#include <dirent.h>
 #include <errno.h>
 
 #define DBUS_SERVICE_SECTION "D-BUS Service"
@@ -1304,6 +1303,7 @@
   DBusMessage *message;
   DBusString service_str;
   char **argv;
+  char **envp = NULL;
   int argc;
   dbus_bool_t retval;
   DBusHashIter iter;
@@ -1535,6 +1535,7 @@
 
   _dbus_verbose ("Spawning %s ...\n", argv[0]);
   if (!_dbus_spawn_async_with_babysitter (&pending_activation->babysitter, argv,
+                                          envp,
                                           child_setup, activation, 
                                           error))
     {
Index: bus/desktop-file.c
===================================================================
--- bus/desktop-file.c	(revision 279)
+++ bus/desktop-file.c	(working copy)
@@ -360,15 +360,15 @@
 static void
 parse_comment_or_blank (BusDesktopFileParser *parser)
 {
-  int line_end;
+  int line_end, eol_len;
   
-  if (!_dbus_string_find (&parser->data, parser->pos, "\n", &line_end))
+  if (!_dbus_string_find_eol (&parser->data, parser->pos, &line_end, &eol_len))
     line_end = parser->len;
 
   if (line_end == parser->len)
     parser->pos = parser->len;
   else
-    parser->pos = line_end + 1;
+    parser->pos = line_end + eol_len;
   
   parser->line_num += 1;
 }
@@ -393,12 +393,12 @@
 static dbus_bool_t
 parse_section_start (BusDesktopFileParser *parser, DBusError *error)
 {
-  int line_end;
+  int line_end, eol_len;
   char *section_name;
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
-  
-  if (!_dbus_string_find (&parser->data, parser->pos, "\n", &line_end))
+    
+  if (!_dbus_string_find_eol (&parser->data, parser->pos, &line_end, &eol_len))
     line_end = parser->len;
   
   if (line_end - parser->pos <= 2 ||
@@ -436,7 +436,7 @@
   if (line_end == parser->len)
     parser->pos = parser->len;
   else
-    parser->pos = line_end + 1;
+    parser->pos = line_end + eol_len;
   
   parser->line_num += 1;
 
@@ -448,7 +448,7 @@
 static dbus_bool_t
 parse_key_value (BusDesktopFileParser *parser, DBusError *error)
 {
-  int line_end;
+  int line_end, eol_len;
   int key_start, key_end;
   int value_start;
   int p;
@@ -458,7 +458,7 @@
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
   
-  if (!_dbus_string_find (&parser->data, parser->pos, "\n", &line_end))
+  if (!_dbus_string_find_eol (&parser->data, parser->pos, &line_end, &eol_len))
     line_end = parser->len;
   
   p = parser->pos;
@@ -481,7 +481,7 @@
       if (line_end == parser->len)
 	parser->pos = parser->len;
       else
-	parser->pos = line_end + 1;
+	parser->pos = line_end + eol_len;
 	  
       parser->line_num += 1;
 
@@ -560,7 +560,7 @@
   if (line_end == parser->len)
     parser->pos = parser->len;
   else
-    parser->pos = line_end + 1;
+    parser->pos = line_end + eol_len;
   
   parser->line_num += 1;
 
Index: dbus/dbus-string.c
===================================================================
--- dbus/dbus-string.c	(revision 280)
+++ dbus/dbus-string.c	(working copy)
@@ -1790,6 +1790,72 @@
 }
 
 /**
+ * Finds end of line ("\r\n" or "\n") in the string,
+ * returning #TRUE and filling in the byte index
+ * where the eol string was found, if it was found.
+ * Returns #FALSE if eol wasn't found.
+ *
+ * @param str the string
+ * @param start where to start looking
+ * @param found return location for where it was found, or #NULL
+ * @param found_len return length of found eol string
+ * @returns #TRUE if found
+ */
+dbus_bool_t
+_dbus_string_find_eol (const DBusString *str,
+                   int               start,
+                   int              *found,
+                   int              *found_len)
+{
+  int i;
+
+  DBUS_CONST_STRING_PREAMBLE (str);
+  _dbus_assert (start <= real->len);
+  _dbus_assert (start >= 0);
+  
+  i = start;
+  while (i < real->len)
+    {
+      if (real->str[i] == '\r') 
+        {
+          if ((i+1) < real->len && real->str[i+1] == '\n') /* "\r\n" */
+            {
+              if (found) 
+                *found = i;
+              if (found_len)
+                *found_len = 2;
+              return TRUE;
+            } 
+          else /* only "\r" */
+            {
+              if (found) 
+                *found = i;
+              if (found_len)
+                *found_len = 1;
+              return TRUE;
+            }
+        } 
+      else if (real->str[i] == '\n')  /* only "\n" */
+        {
+          if (found) 
+            *found = i;
+          if (found_len)
+            *found_len = 1;
+          return TRUE;
+        }      
+      ++i;
+    }
+
+  if (found)
+    *found = real->len;
+
+  if (found_len)
+    *found_len = 0;
+  
+  return FALSE;
+}
+
+/**
  * Finds the given substring in the string,
  * up to a certain position,
  * returning #TRUE and filling in the byte index
@@ -1957,52 +2023,18 @@
 _dbus_string_pop_line (DBusString *source,
                        DBusString *dest)
 {
-  int eol;
-  dbus_bool_t have_newline;
+  int eol, eol_len;
   
   _dbus_string_set_length (dest, 0);
   
   eol = 0;
-  if (_dbus_string_find (source, 0, "\n", &eol))
-    {
-      have_newline = TRUE;
-      eol += 1; /* include newline */
-    }
-  else
-    {
+  if (!_dbus_string_find_eol (source, 0, &eol, &eol_len))
       eol = _dbus_string_get_length (source);
-      have_newline = FALSE;
-    }
 
   if (eol == 0)
     return FALSE; /* eof */
   
-  if (!_dbus_string_move_len (source, 0, eol,
-                              dest, 0))
-    {
-      return FALSE;
-    }
-
-  /* dump the newline and the \r if we have one */
-  if (have_newline)
-    {
-      dbus_bool_t have_cr;
-      
-      _dbus_assert (_dbus_string_get_length (dest) > 0);
-
-      if (_dbus_string_get_length (dest) > 1 &&
-          _dbus_string_get_byte (dest,
-                                 _dbus_string_get_length (dest) - 2) == '\r')
-        have_cr = TRUE;
-      else
-        have_cr = FALSE;
-        
-      _dbus_string_set_length (dest,
-                               _dbus_string_get_length (dest) -
-                               (have_cr ? 2 : 1));
-    }
-  
-  return TRUE;
+  return _dbus_string_move_len (source, 0, eol, dest, 0);
 }
 
 #ifdef DBUS_BUILD_TESTS
Index: dbus/dbus-string.h
===================================================================
--- dbus/dbus-string.h	(revision 280)
+++ dbus/dbus-string.h	(working copy)
@@ -215,6 +215,10 @@
                                                   int                start,
                                                   const char        *substr,
                                                   int               *found);
+dbus_bool_t   _dbus_string_find_eol               (const DBusString *str,
+                                                  int               start,
+                                                  int               *found,
+                                                  int               *found_len);
 dbus_bool_t   _dbus_string_find_to               (const DBusString  *str,
                                                   int                start,
                                                   int                end,
Index: dbus/dbus-server-unix.c
===================================================================
--- dbus/dbus-server-unix.c	(revision 280)
+++ dbus/dbus-server-unix.c	(working copy)
@@ -27,12 +27,16 @@
 #include "dbus-connection-internal.h"
 #include "dbus-string.h"
 #include <sys/types.h>
+#ifdef DBUS_WIN
+#include "dbus-sockets-win.h"
+#else
 #include <unistd.h>
+#endif
 
 /**
- * @defgroup DBusServerUnix DBusServer implementations for UNIX
+ * @defgroup DBusServerUnix DBusServer implementations for UNIX and Winsock
  * @ingroup  DBusInternals
- * @brief Implementation details of DBusServer on UNIX
+ * @brief Implementation details of DBusServer on UNIX and Winsock
  *
  * @{
  */
@@ -102,7 +106,7 @@
   transport = _dbus_transport_new_for_fd (client_fd, &server->guid_hex, NULL);
   if (transport == NULL)
     {
-      close (client_fd);
+      _dbus_close (client_fd, NULL);
       SERVER_UNLOCK (server);
       return FALSE;
     }
@@ -219,7 +223,7 @@
       unix_server->watch = NULL;
     }
   
-  close (unix_server->fd);
+  _dbus_close (unix_server->fd, NULL);
   unix_server->fd = -1;
 
   if (unix_server->socket_name != NULL)
@@ -303,6 +307,8 @@
   return (DBusServer*) unix_server;
 }
 
+#ifndef DBUS_WIN
+
 /**
  * Creates a new server listening on the given Unix domain socket.
  *
@@ -382,11 +388,94 @@
   return NULL;
 }
 
+#else /* ifndef DBUS_WIN */
+
 /**
- * Creates a new server listening on the given hostname and port.
- * If the hostname is NULL, listens on localhost.
+ * Creates a new server listening on the given Windows named pipe.
  *
- * @param host the hostname to listen on.
+ * @param path the path for the domain socket.
+ * @param abstract #TRUE to use abstract socket namespace
+ * @param error location to store reason for failure.
+ * @returns the new server, or #NULL on failure.
+ */
+DBusServer*
+_dbus_server_new_for_domain_socket (const char     *path,
+                                    dbus_bool_t     abstract,
+                                    DBusError      *error)
+{
+  DBusServer *server;
+  DBusServerUnix *unix_server;
+  int listen_fd;
+  DBusString address;
+  char *path_copy;
+  
+  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
+
+  if (!_dbus_string_init (&address))
+    {
+      _DBUS_SET_OOM (error);
+      return NULL;
+    }
+
+  if ((abstract &&
+       !_dbus_string_append (&address, "unix:abstract=")) ||
+      (!abstract &&
+       !_dbus_string_append (&address, "unix:path=")) ||
+      !_dbus_string_append (&address, path))
+    {
+      _DBUS_SET_OOM (error);
+      goto failed_0;
+    }
+
+  path_copy = _dbus_strdup (path);
+  if (path_copy == NULL)
+    {
+      _DBUS_SET_OOM (error);
+      goto failed_0;
+    }
+  
+  listen_fd = _dbus_listen_unix_socket (path, abstract, error);
+  
+  if (listen_fd < 0)
+    {
+      _DBUS_ASSERT_ERROR_IS_SET (error);
+      goto failed_1;
+    }
+  
+  _dbus_fd_set_close_on_exec (listen_fd);
+  server = _dbus_server_new_for_fd (listen_fd, &address);
+  if (server == NULL)
+    {
+      _DBUS_SET_OOM (error);
+      goto failed_2;
+    }
+
+  unix_server = (DBusServerUnix*) server;
+  unix_server->socket_name = path_copy;
+  
+  _dbus_string_free (&address);
+  
+  return server;
+
+ failed_2:
+  _dbus_close (listen_fd, NULL);
+ failed_1:
+  dbus_free (path_copy);
+ failed_0:
+  _dbus_string_free (&address);
+
+  return NULL;
+}
+
+#endif /* ifndef DBUS_WIN */
+
+
+/**
+ * Creates a new server listening on the given hostname and port.  If
+ * the hostname is NULL, listens on localhost. If the hostname is an
+ * empty string, listens on any local host address.
+ *
+ * @param host the hostname for the address to listen.
  * @param port the port to listen on.
  * @param error location to store reason for failure.
  * @returns the new server, or #NULL on failure.
@@ -436,7 +525,7 @@
   if (server == NULL)
     {
       dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
-      close (listen_fd);
+      _dbus_close (listen_fd, NULL);
       _dbus_string_free (&address);
       return NULL;
     }
Index: dbus/dbus-test.c
===================================================================
--- dbus/dbus-test.c	(revision 280)
+++ dbus/dbus-test.c	(working copy)
@@ -154,7 +154,9 @@
   
   run_test ("hash", specific_test, _dbus_hash_test);
 
+#ifndef DBUS_WIN
   run_data_test ("spawn", specific_test, _dbus_spawn_test, test_data_dir);
+#endif
   
   run_data_test ("userdb", specific_test, _dbus_userdb_test, test_data_dir);
   
Index: dbus/dbus-spawn.c
===================================================================
--- dbus/dbus-spawn.c	(revision 280)
+++ dbus/dbus-spawn.c	(working copy)
@@ -1021,6 +1021,7 @@
  *
  * @param sitter_p return location for babysitter or #NULL
  * @param argv the executable and arguments
+ * @param env the environment (not used on unix yet)
  * @param child_setup function to call in child pre-exec()
  * @param user_data user data for setup function
  * @param error error object to be filled in if function fails
@@ -1029,6 +1030,7 @@
 dbus_bool_t
 _dbus_spawn_async_with_babysitter (DBusBabysitter          **sitter_p,
                                    char                    **argv,
+                                   char                    **env,
                                    DBusSpawnChildSetupFunc   child_setup,
                                    void                     *user_data,
                                    DBusError                *error)
@@ -1216,7 +1218,7 @@
   
   argv[0] = "/this/does/not/exist/32542sdgafgafdg";
   if (_dbus_spawn_async_with_babysitter (&sitter, argv,
-                                         NULL, NULL,
+                                         NULL, NULL, NULL,
                                          &error))
     {
       _dbus_babysitter_block_for_child_exit (sitter);
@@ -1261,7 +1263,7 @@
   
   argv[0] = TEST_SEGFAULT_BINARY;
   if (_dbus_spawn_async_with_babysitter (&sitter, argv,
-                                         NULL, NULL,
+                                         NULL, NULL, NULL,
                                          &error))
     {
       _dbus_babysitter_block_for_child_exit (sitter);
@@ -1306,7 +1308,7 @@
   
   argv[0] = TEST_EXIT_BINARY;
   if (_dbus_spawn_async_with_babysitter (&sitter, argv,
-                                         NULL, NULL,
+                                         NULL, NULL, NULL,
                                          &error))
     {
       _dbus_babysitter_block_for_child_exit (sitter);
@@ -1351,7 +1353,7 @@
 
   argv[0] = TEST_SLEEP_FOREVER_BINARY;
   if (_dbus_spawn_async_with_babysitter (&sitter, argv,
-                                         NULL, NULL,
+                                         NULL, NULL, NULL,
                                          &error))
     {
       _dbus_babysitter_kill_child (sitter);
Index: dbus/dbus-spawn.h
===================================================================
--- dbus/dbus-spawn.h	(revision 280)
+++ dbus/dbus-spawn.h	(working copy)
@@ -37,6 +37,7 @@
 
 dbus_bool_t _dbus_spawn_async_with_babysitter     (DBusBabysitter           **sitter_p,
                                                    char                     **argv,
+                                                   char                     **env,
                                                    DBusSpawnChildSetupFunc    child_setup,
                                                    void                      *user_data,
                                                    DBusError                 *error);
Index: dbus/dbus-sysdeps-util.c
===================================================================
--- dbus/dbus-sysdeps-util.c	(revision 280)
+++ dbus/dbus-sysdeps-util.c	(working copy)
@@ -81,7 +81,28 @@
   DBusString str;
   double val;
   int pos;
-  
+
+#ifdef DBUS_WIN
+  check_dirname ("foo\\bar", "foo");
+  check_dirname ("foo\\\\bar", "foo");
+  check_dirname ("foo/\\/bar", "foo");
+  check_dirname ("foo\\bar/", "foo");
+  check_dirname ("foo//bar\\", "foo");
+  check_dirname ("foo\\bar/", "foo");
+  check_dirname ("foo/bar\\\\", "foo");
+  check_dirname ("\\foo", "\\");
+  check_dirname ("\\\\foo", "\\");
+  check_dirname ("\\", "\\");
+  check_dirname ("\\\\", "\\");
+  check_dirname ("\\/", "\\");
+  check_dirname ("/\\/", "/");
+  check_dirname ("c:\\foo\\bar", "c:\\foo");
+  check_dirname ("c:\\foo", "c:\\");
+  check_dirname ("c:/foo", "c:/");
+  check_dirname ("c:\\", "c:\\");
+  check_dirname ("c:/", "c:/");
+  check_dirname ("", ".");  
+#else  
   check_dirname ("foo", ".");
   check_dirname ("foo/bar", "foo");
   check_dirname ("foo//bar", "foo");
@@ -100,8 +121,8 @@
   check_dirname ("/", "/");
   check_dirname ("///", "/");
   check_dirname ("", ".");  
+#endif
 
-
   _dbus_string_init_const (&str, "3.5");
   if (!_dbus_string_parse_double (&str,
 				  0, &val, &pos))
@@ -120,6 +141,7 @@
       exit (1);
     }
 
+#ifndef DBUS_WIN_FIXME
   _dbus_string_init_const (&str, "0xff");
   if (!_dbus_string_parse_double (&str,
 				  0, &val, &pos))
@@ -137,12 +159,29 @@
       _dbus_warn ("_dbus_string_parse_double of \"0xff\" returned wrong position %d", pos);
       exit (1);
     }
-  
+#endif
+
+#ifdef DBUS_WIN
+  check_path_absolute ("c:/", TRUE);
+  check_path_absolute ("c:/foo", TRUE);
+  check_path_absolute ("", FALSE);
+  check_path_absolute ("foo", FALSE);
+  check_path_absolute ("foo/bar", FALSE);
+  check_path_absolute ("", FALSE);
+  check_path_absolute ("foo\\bar", FALSE);
+  check_path_absolute ("c:\\", TRUE);
+  check_path_absolute ("c:\\foo", TRUE);
+  check_path_absolute ("c:", TRUE);
+  check_path_absolute ("c:\\foo\\bar", TRUE);
+  check_path_absolute ("\\", TRUE);
   check_path_absolute ("/", TRUE);
+#else  
+  check_path_absolute ("/", TRUE);
   check_path_absolute ("/foo", TRUE);
   check_path_absolute ("", FALSE);
   check_path_absolute ("foo", FALSE);
   check_path_absolute ("foo/bar", FALSE);
+#endif
   
   return TRUE;
 }
Index: dbus/dbus-transport-unix.c
===================================================================
--- dbus/dbus-transport-unix.c	(revision 280)
+++ dbus/dbus-transport-unix.c	(working copy)
@@ -26,6 +26,9 @@
 #include "dbus-transport-unix.h"
 #include "dbus-transport-protected.h"
 #include "dbus-watch.h"
+#ifdef DBUS_WIN
+#include "dbus-sockets-win.h"
+#endif
 
 
 /**
Index: dbus/dbus-sysdeps.c
===================================================================
--- dbus/dbus-sysdeps.c	(revision 280)
+++ dbus/dbus-sysdeps.c	(working copy)
@@ -3,6 +3,7 @@
  * 
  * Copyright (C) 2002, 2003  Red Hat, Inc.
  * Copyright (C) 2003 CodeFactory AB
+ * Copyright (C) 2005 Novell, Inc.
  *
  * Licensed under the Academic Free License version 2.1
  * 
@@ -28,73 +29,40 @@
 #include "dbus-protocol.h"
 #include "dbus-string.h"
 #include <sys/types.h>
+#include <sys/stat.h>
 #include <stdlib.h>
 #include <string.h>
 #include <signal.h>
-#include <unistd.h>
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
-#include <sys/socket.h>
+#include <time.h>
+#include <locale.h>
+
+
+#ifdef DBUS_WIN
+#include <io.h>
+#ifdef _MSC_VER
+#define S_ISREG(mode) (((mode) & S_IFMT) == S_IFREG)
+#endif
+#else
+#include <unistd.h>
 #include <dirent.h>
 #include <sys/un.h>
 #include <pwd.h>
-#include <time.h>
-#include <locale.h>
-#include <sys/time.h>
-#include <sys/stat.h>
-#include <sys/wait.h>
 #include <netinet/in.h>
 #include <netdb.h>
 #include <grp.h>
-
-#ifdef HAVE_WRITEV
-#include <sys/uio.h>
 #endif
-#ifdef HAVE_POLL
-#include <sys/poll.h>
-#endif
-#ifdef HAVE_BACKTRACE
-#include <execinfo.h>
-#endif
-#ifdef HAVE_GETPEERUCRED
-#include <ucred.h>
-#endif
 
 #ifndef O_BINARY
 #define O_BINARY 0
 #endif
 
-#ifndef HAVE_SOCKLEN_T
-#define socklen_t int
-#endif
-
 _DBUS_DEFINE_GLOBAL_LOCK (win_fds);
 _DBUS_DEFINE_GLOBAL_LOCK (sid_atom_cache);
 
 /**
- * @addtogroup DBusInternalsUtils
- * @{
- */
-#ifndef DBUS_DISABLE_ASSERT
-/**
- * Aborts the program with SIGABRT (dumping core).
- */
-void
-_dbus_abort (void)
-{
-#ifdef DBUS_ENABLE_VERBOSE_MODE
-  const char *s;
-  s = _dbus_getenv ("DBUS_PRINT_BACKTRACE");
-  if (s && *s)
-    _dbus_print_backtrace ();
-#endif
-  abort ();
-  _exit (1); /* in case someone manages to ignore SIGABRT */
-}
-#endif
-
-/**
  * Wrapper for setenv(). If the value is #NULL, unsets
  * the environment variable.
  *
@@ -126,11 +94,14 @@
        * will get upset about.
        */
       
-      putenv_value = malloc (len + 1);
+      putenv_value = malloc (len + 2);
       if (putenv_value == NULL)
         return FALSE;
 
       strcpy (putenv_value, varname);
+#ifdef DBUS_WIN
+      strcat (putenv_value, "=");
+#endif
       
       return (putenv (putenv_value) == 0);
 #endif
@@ -179,835 +150,8 @@
   return getenv (varname);
 }
 
-/**
- * Thin wrapper around the read() system call that appends
- * the data it reads to the DBusString buffer. It appends
- * up to the given count, and returns the same value
- * and same errno as read(). The only exception is that
- * _dbus_read() handles EINTR for you. _dbus_read() can
- * return ENOMEM, even though regular UNIX read doesn't.
- *
- * @param fd the file descriptor to read from
- * @param buffer the buffer to append data to
- * @param count the amount of data to read
- * @returns the number of bytes read or -1
- */
-int
-_dbus_read (int               fd,
-            DBusString       *buffer,
-            int               count)
-{
-  int bytes_read;
-  int start;
-  char *data;
 
-  _dbus_assert (count >= 0);
-  
-  start = _dbus_string_get_length (buffer);
-
-  if (!_dbus_string_lengthen (buffer, count))
-    {
-      errno = ENOMEM;
-      return -1;
-    }
-
-  data = _dbus_string_get_data_len (buffer, start, count);
-
- again:
-  
-  bytes_read = read (fd, data, count);
-
-  if (bytes_read < 0)
-    {
-      if (errno == EINTR)
-        goto again;
-      else
-        {
-          /* put length back (note that this doesn't actually realloc anything) */
-          _dbus_string_set_length (buffer, start);
-          return -1;
-        }
-    }
-  else
-    {
-      /* put length back (doesn't actually realloc) */
-      _dbus_string_set_length (buffer, start + bytes_read);
-
-#if 0
-      if (bytes_read > 0)
-        _dbus_verbose_bytes_of_string (buffer, start, bytes_read);
-#endif
-      
-      return bytes_read;
-    }
-}
-
 /**
- * Thin wrapper around the write() system call that writes a part of a
- * DBusString and handles EINTR for you.
- * 
- * @param fd the file descriptor to write
- * @param buffer the buffer to write data from
- * @param start the first byte in the buffer to write
- * @param len the number of bytes to try to write
- * @returns the number of bytes written or -1 on error
- */
-int
-_dbus_write (int               fd,
-             const DBusString *buffer,
-             int               start,
-             int               len)
-{
-  const char *data;
-  int bytes_written;
-  
-  data = _dbus_string_get_const_data_len (buffer, start, len);
-  
- again:
-
-  bytes_written = write (fd, data, len);
-
-  if (bytes_written < 0 && errno == EINTR)
-    goto again;
-
-#if 0
-  if (bytes_written > 0)
-    _dbus_verbose_bytes_of_string (buffer, start, bytes_written);
-#endif
-  
-  return bytes_written;
-}
-
-/**
- * Like _dbus_write() but will use writev() if possible
- * to write both buffers in sequence. The return value
- * is the number of bytes written in the first buffer,
- * plus the number written in the second. If the first
- * buffer is written successfully and an error occurs
- * writing the second, the number of bytes in the first
- * is returned (i.e. the error is ignored), on systems that
- * don't have writev. Handles EINTR for you.
- * The second buffer may be #NULL.
- *
- * @param fd the file descriptor
- * @param buffer1 first buffer
- * @param start1 first byte to write in first buffer
- * @param len1 number of bytes to write from first buffer
- * @param buffer2 second buffer, or #NULL
- * @param start2 first byte to write in second buffer
- * @param len2 number of bytes to write in second buffer
- * @returns total bytes written from both buffers, or -1 on error
- */
-int
-_dbus_write_two (int               fd,
-                 const DBusString *buffer1,
-                 int               start1,
-                 int               len1,
-                 const DBusString *buffer2,
-                 int               start2,
-                 int               len2)
-{
-  _dbus_assert (buffer1 != NULL);
-  _dbus_assert (start1 >= 0);
-  _dbus_assert (start2 >= 0);
-  _dbus_assert (len1 >= 0);
-  _dbus_assert (len2 >= 0);
-  
-#ifdef HAVE_WRITEV
-  {
-    struct iovec vectors[2];
-    const char *data1;
-    const char *data2;
-    int bytes_written;
-
-    data1 = _dbus_string_get_const_data_len (buffer1, start1, len1);
-
-    if (buffer2 != NULL)
-      data2 = _dbus_string_get_const_data_len (buffer2, start2, len2);
-    else
-      {
-        data2 = NULL;
-        start2 = 0;
-        len2 = 0;
-      }
-   
-    vectors[0].iov_base = (char*) data1;
-    vectors[0].iov_len = len1;
-    vectors[1].iov_base = (char*) data2;
-    vectors[1].iov_len = len2;
-
-  again:
-   
-    bytes_written = writev (fd,
-                            vectors,
-                            data2 ? 2 : 1);
-
-    if (bytes_written < 0 && errno == EINTR)
-      goto again;
-   
-    return bytes_written;
-  }
-#else /* HAVE_WRITEV */
-  {
-    int ret1;
-    
-    ret1 = _dbus_write (fd, buffer1, start1, len1);
-    if (ret1 == len1 && buffer2 != NULL)
-      {
-        ret2 = _dbus_write (fd, buffer2, start2, len2);
-        if (ret2 < 0)
-          ret2 = 0; /* we can't report an error as the first write was OK */
-       
-        return ret1 + ret2;
-      }
-    else
-      return ret1;
-  }
-#endif /* !HAVE_WRITEV */   
-}
-
-#define _DBUS_MAX_SUN_PATH_LENGTH 99
-
-/**
- * @def _DBUS_MAX_SUN_PATH_LENGTH
- *
- * Maximum length of the path to a UNIX domain socket,
- * sockaddr_un::sun_path member. POSIX requires that all systems
- * support at least 100 bytes here, including the nul termination.
- * We use 99 for the max value to allow for the nul.
- *
- * We could probably also do sizeof (addr.sun_path)
- * but this way we are the same on all platforms
- * which is probably a good idea.
- */
-
-/**
- * Creates a socket and connects it to the UNIX domain socket at the
- * given path.  The connection fd is returned, and is set up as
- * nonblocking.
- * 
- * Uses abstract sockets instead of filesystem-linked sockets if
- * requested (it's possible only on Linux; see "man 7 unix" on Linux).
- * On non-Linux abstract socket usage always fails.
- *
- * @param path the path to UNIX domain socket
- * @param abstract #TRUE to use abstract namespace
- * @param error return location for error code
- * @returns connection file descriptor or -1 on error
- */
-int
-_dbus_connect_unix_socket (const char     *path,
-                           dbus_bool_t     abstract,
-                           DBusError      *error)
-{
-  int fd;
-  size_t path_len;
-  struct sockaddr_un addr;  
-
-  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
-
-  _dbus_verbose ("connecting to unix socket %s abstract=%d\n",
-                 path, abstract);
-  
-  fd = socket (PF_UNIX, SOCK_STREAM, 0);
-  
-  if (fd < 0)
-    {
-      dbus_set_error (error,
-                      _dbus_error_from_errno (errno),
-                      "Failed to create socket: %s",
-                      _dbus_strerror (errno)); 
-      
-      return -1;
-    }
-
-  _DBUS_ZERO (addr);
-  addr.sun_family = AF_UNIX;
-  path_len = strlen (path);
-
-  if (abstract)
-    {
-#ifdef HAVE_ABSTRACT_SOCKETS
-      addr.sun_path[0] = '\0'; /* this is what says "use abstract" */
-      path_len++; /* Account for the extra nul byte added to the start of sun_path */
-
-      if (path_len > _DBUS_MAX_SUN_PATH_LENGTH)
-        {
-          dbus_set_error (error, DBUS_ERROR_BAD_ADDRESS,
-                      "Abstract socket name too long\n");
-          close (fd);
-          return -1;
-	}
-	
-      strncpy (&addr.sun_path[1], path, path_len);
-      /* _dbus_verbose_bytes (addr.sun_path, sizeof (addr.sun_path)); */
-#else /* HAVE_ABSTRACT_SOCKETS */
-      dbus_set_error (error, DBUS_ERROR_NOT_SUPPORTED,
-                      "Operating system does not support abstract socket namespace\n");
-      close (fd);
-      return -1;
-#endif /* ! HAVE_ABSTRACT_SOCKETS */
-    }
-  else
-    {
-      if (path_len > _DBUS_MAX_SUN_PATH_LENGTH)
-        {
-          dbus_set_error (error, DBUS_ERROR_BAD_ADDRESS,
-                      "Socket name too long\n");
-          close (fd);
-          return -1;
-	}
-
-      strncpy (addr.sun_path, path, path_len);
-    }
-  
-  if (connect (fd, (struct sockaddr*) &addr, _DBUS_STRUCT_OFFSET (struct sockaddr_un, sun_path) + path_len) < 0)
-    {      
-      dbus_set_error (error,
-                      _dbus_error_from_errno (errno),
-                      "Failed to connect to socket %s: %s",
-                      path, _dbus_strerror (errno));
-
-      close (fd);
-      fd = -1;
-      
-      return -1;
-    }
-
-  if (!_dbus_set_fd_nonblocking (fd, error))
-    {
-      _DBUS_ASSERT_ERROR_IS_SET (error);
-      
-      close (fd);
-      fd = -1;
-
-      return -1;
-    }
-
-  return fd;
-}
-
-/**
- * Creates a socket and binds it to the given path,
- * then listens on the socket. The socket is
- * set to be nonblocking.
- *
- * Uses abstract sockets instead of filesystem-linked
- * sockets if requested (it's possible only on Linux;
- * see "man 7 unix" on Linux).
- * On non-Linux abstract socket usage always fails.
- *
- * @param path the socket name
- * @param abstract #TRUE to use abstract namespace
- * @param error return location for errors
- * @returns the listening file descriptor or -1 on error
- */
-int
-_dbus_listen_unix_socket (const char     *path,
-                          dbus_bool_t     abstract,
-                          DBusError      *error)
-{
-  int listen_fd;
-  struct sockaddr_un addr;
-  size_t path_len;
-
-  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
-
-  _dbus_verbose ("listening on unix socket %s abstract=%d\n",
-                 path, abstract);
-  
-  listen_fd = socket (PF_UNIX, SOCK_STREAM, 0);
-  
-  if (listen_fd < 0)
-    {
-      dbus_set_error (error, _dbus_error_from_errno (errno),
-                      "Failed to create socket \"%s\": %s",
-                      path, _dbus_strerror (errno));
-      return -1;
-    }
-
-  _DBUS_ZERO (addr);
-  addr.sun_family = AF_UNIX;
-  path_len = strlen (path);
-  
-  if (abstract)
-    {
-#ifdef HAVE_ABSTRACT_SOCKETS
-      /* remember that abstract names aren't nul-terminated so we rely
-       * on sun_path being filled in with zeroes above.
-       */
-      addr.sun_path[0] = '\0'; /* this is what says "use abstract" */
-      path_len++; /* Account for the extra nul byte added to the start of sun_path */
-
-      if (path_len > _DBUS_MAX_SUN_PATH_LENGTH)
-        {
-          dbus_set_error (error, DBUS_ERROR_BAD_ADDRESS,
-                      "Abstract socket name too long\n");
-          close (listen_fd);
-          return -1;
-	}
-      
-      strncpy (&addr.sun_path[1], path, path_len);
-      /* _dbus_verbose_bytes (addr.sun_path, sizeof (addr.sun_path)); */
-#else /* HAVE_ABSTRACT_SOCKETS */
-      dbus_set_error (error, DBUS_ERROR_NOT_SUPPORTED,
-                      "Operating system does not support abstract socket namespace\n");
-      close (listen_fd);
-      return -1;
-#endif /* ! HAVE_ABSTRACT_SOCKETS */
-    }
-  else
-    {
-      /* FIXME discussed security implications of this with Nalin,
-       * and we couldn't think of where it would kick our ass, but
-       * it still seems a bit sucky. It also has non-security suckage;
-       * really we'd prefer to exit if the socket is already in use.
-       * But there doesn't seem to be a good way to do this.
-       *
-       * Just to be extra careful, I threw in the stat() - clearly
-       * the stat() can't *fix* any security issue, but it at least
-       * avoids inadvertent/accidental data loss.
-       */
-      {
-        struct stat sb;
-
-        if (stat (path, &sb) == 0 &&
-            S_ISSOCK (sb.st_mode))
-          unlink (path);
-      }
-
-      if (path_len > _DBUS_MAX_SUN_PATH_LENGTH)
-        {
-          dbus_set_error (error, DBUS_ERROR_BAD_ADDRESS,
-                      "Abstract socket name too long\n");
-          close (listen_fd);
-          return -1;
-	}
-	
-      strncpy (addr.sun_path, path, path_len);
-    }
-  
-  if (bind (listen_fd, (struct sockaddr*) &addr, _DBUS_STRUCT_OFFSET (struct sockaddr_un, sun_path) + path_len) < 0)
-    {
-      dbus_set_error (error, _dbus_error_from_errno (errno),
-                      "Failed to bind socket \"%s\": %s",
-                      path, _dbus_strerror (errno));
-      close (listen_fd);
-      return -1;
-    }
-
-  if (listen (listen_fd, 30 /* backlog */) < 0)
-    {
-      dbus_set_error (error, _dbus_error_from_errno (errno),
-                      "Failed to listen on socket \"%s\": %s",
-                      path, _dbus_strerror (errno));
-      close (listen_fd);
-      return -1;
-    }
-
-  if (!_dbus_set_fd_nonblocking (listen_fd, error))
-    {
-      _DBUS_ASSERT_ERROR_IS_SET (error);
-      close (listen_fd);
-      return -1;
-    }
-  
-  /* Try opening up the permissions, but if we can't, just go ahead
-   * and continue, maybe it will be good enough.
-   */
-  if (!abstract && chmod (path, 0777) < 0)
-    _dbus_warn ("Could not set mode 0777 on socket %s\n",
-                path);
-  
-  return listen_fd;
-}
-
-/**
- * Creates a socket and connects to a socket at the given host 
- * and port. The connection fd is returned, and is set up as
- * nonblocking.
- *
- * @param host the host name to connect to
- * @param port the prot to connect to
- * @param error return location for error code
- * @returns connection file descriptor or -1 on error
- */
-int
-_dbus_connect_tcp_socket (const char     *host,
-                          dbus_uint32_t   port,
-                          DBusError      *error)
-{
-  int fd;
-  struct sockaddr_in addr;
-  struct hostent *he;
-  struct in_addr *haddr;
-
-  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
-  
-  fd = socket (AF_INET, SOCK_STREAM, 0);
-  
-  if (fd < 0)
-    {
-      dbus_set_error (error,
-                      _dbus_error_from_errno (errno),
-                      "Failed to create socket: %s",
-                      _dbus_strerror (errno)); 
-      
-      return -1;
-    }
-
-  if (host == NULL)
-    host = "localhost";
-
-  he = gethostbyname (host);
-  if (he == NULL) 
-    {
-      dbus_set_error (error,
-                      _dbus_error_from_errno (errno),
-                      "Failed to lookup hostname: %s",
-                      host);
-      close (fd);
-      return -1;
-    }
-  
-  haddr = ((struct in_addr *) (he->h_addr_list)[0]);
-
-  _DBUS_ZERO (addr);
-  memcpy (&addr.sin_addr, haddr, sizeof(struct in_addr));
-  addr.sin_family = AF_INET;
-  addr.sin_port = htons (port);
-  
-  if (connect (fd, (struct sockaddr*) &addr, sizeof (addr)) < 0)
-    {      
-      dbus_set_error (error,
-                       _dbus_error_from_errno (errno),
-                      "Failed to connect to socket %s:%d %s",
-                      host, port, _dbus_strerror (errno));
-
-      close (fd);
-      fd = -1;
-      
-      return -1;
-    }
-
-  if (!_dbus_set_fd_nonblocking (fd, error))
-    {
-      close (fd);
-      fd = -1;
-
-      return -1;
-    }
-
-  return fd;
-}
-
-/**
- * Creates a socket and binds it to the given path,
- * then listens on the socket. The socket is
- * set to be nonblocking. 
- *
- * @param host the host name to listen on
- * @param port the prot to listen on
- * @param error return location for errors
- * @returns the listening file descriptor or -1 on error
- */
-int
-_dbus_listen_tcp_socket (const char     *host,
-                         dbus_uint32_t   port,
-                         DBusError      *error)
-{
-  int listen_fd;
-  struct sockaddr_in addr;
-  struct hostent *he;
-  struct in_addr *haddr;
-
-  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
-  
-  listen_fd = socket (AF_INET, SOCK_STREAM, 0);
-  
-  if (listen_fd < 0)
-    {
-      dbus_set_error (error, _dbus_error_from_errno (errno),
-                      "Failed to create socket \"%s:%d\": %s",
-                      host, port, _dbus_strerror (errno));
-      return -1;
-    }
-
-  he = gethostbyname (host);
-  if (he == NULL) 
-    {
-      dbus_set_error (error,
-                      _dbus_error_from_errno (errno),
-                      "Failed to lookup hostname: %s",
-                      host);
-      close (listen_fd);
-      return -1;
-    }
-  
-  haddr = ((struct in_addr *) (he->h_addr_list)[0]);
-
-  _DBUS_ZERO (addr);
-  memcpy (&addr.sin_addr, haddr, sizeof (struct in_addr));
-  addr.sin_family = AF_INET;
-  addr.sin_port = htons (port);
-
-  if (bind (listen_fd, (struct sockaddr*) &addr, sizeof (struct sockaddr)))
-    {
-      dbus_set_error (error, _dbus_error_from_errno (errno),
-                      "Failed to bind socket \"%s:%d\": %s",
-                      host, port, _dbus_strerror (errno));
-      close (listen_fd);
-      return -1;
-    }
-
-  if (listen (listen_fd, 30 /* backlog */) < 0)
-    {
-      dbus_set_error (error, _dbus_error_from_errno (errno),  
-                      "Failed to listen on socket \"%s:%d\": %s",
-                      host, port, _dbus_strerror (errno));
-      close (listen_fd);
-      return -1;
-    }
-
-  if (!_dbus_set_fd_nonblocking (listen_fd, error))
-    {
-      close (listen_fd);
-      return -1;
-    }
-  
-  return listen_fd;
-}
-
-static dbus_bool_t
-write_credentials_byte (int             server_fd,
-                        DBusError      *error)
-{
-  int bytes_written;
-  char buf[1] = { '\0' };
-#if defined(HAVE_CMSGCRED) && !defined(LOCAL_CREDS)
-  struct {
-	  struct cmsghdr hdr;
-	  struct cmsgcred cred;
-  } cmsg;
-  struct iovec iov;
-  struct msghdr msg;
-#endif
-
-#if defined(HAVE_CMSGCRED) && !defined(LOCAL_CREDS)
-  iov.iov_base = buf;
-  iov.iov_len = 1;
-
-  memset (&msg, 0, sizeof (msg));
-  msg.msg_iov = &iov;
-  msg.msg_iovlen = 1;
-
-  msg.msg_control = &cmsg;
-  msg.msg_controllen = sizeof (cmsg);
-  memset (&cmsg, 0, sizeof (cmsg));
-  cmsg.hdr.cmsg_len = sizeof (cmsg);
-  cmsg.hdr.cmsg_level = SOL_SOCKET;
-  cmsg.hdr.cmsg_type = SCM_CREDS;
-#endif
-
-  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
-  
- again:
-
-#if defined(HAVE_CMSGCRED) && !defined(LOCAL_CREDS)
-  bytes_written = sendmsg (server_fd, &msg, 0);
-#else
-  bytes_written = write (server_fd, buf, 1);
-#endif
-
-  if (bytes_written < 0 && errno == EINTR)
-    goto again;
-
-  if (bytes_written < 0)
-    {
-      dbus_set_error (error, _dbus_error_from_errno (errno),
-                      "Failed to write credentials byte: %s",
-                     _dbus_strerror (errno));
-      return FALSE;
-    }
-  else if (bytes_written == 0)
-    {
-      dbus_set_error (error, DBUS_ERROR_IO_ERROR,
-                      "wrote zero bytes writing credentials byte");
-      return FALSE;
-    }
-  else
-    {
-      _dbus_assert (bytes_written == 1);
-      _dbus_verbose ("wrote credentials byte\n");
-      return TRUE;
-    }
-}
-
-/**
- * Reads a single byte which must be nul (an error occurs otherwise),
- * and reads unix credentials if available. Fills in pid/uid/gid with
- * -1 if no credentials are available. Return value indicates whether
- * a byte was read, not whether we got valid credentials. On some
- * systems, such as Linux, reading/writing the byte isn't actually
- * required, but we do it anyway just to avoid multiple codepaths.
- * 
- * Fails if no byte is available, so you must select() first.
- *
- * The point of the byte is that on some systems we have to
- * use sendmsg()/recvmsg() to transmit credentials.
- *
- * @param client_fd the client file descriptor
- * @param credentials struct to fill with credentials of client
- * @param error location to store error code
- * @returns #TRUE on success
- */
-dbus_bool_t
-_dbus_read_credentials_unix_socket  (int              client_fd,
-                                     DBusCredentials *credentials,
-                                     DBusError       *error)
-{
-  struct msghdr msg;
-  struct iovec iov;
-  char buf;
-
-#ifdef HAVE_CMSGCRED 
-  struct {
-	  struct cmsghdr hdr;
-	  struct cmsgcred cred;
-  } cmsg;
-#endif
-
-  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
-  
-  /* The POSIX spec certainly doesn't promise this, but
-   * we need these assertions to fail as soon as we're wrong about
-   * it so we can do the porting fixups
-   */
-  _dbus_assert (sizeof (pid_t) <= sizeof (credentials->pid));
-  _dbus_assert (sizeof (uid_t) <= sizeof (credentials->uid));
-  _dbus_assert (sizeof (gid_t) <= sizeof (credentials->gid));
-
-  _dbus_credentials_clear (credentials);
-
-#if defined(LOCAL_CREDS) && defined(HAVE_CMSGCRED)
-  /* Set the socket to receive credentials on the next message */
-  {
-    int on = 1;
-    if (setsockopt (client_fd, 0, LOCAL_CREDS, &on, sizeof (on)) < 0)
-      {
-	_dbus_verbose ("Unable to set LOCAL_CREDS socket option\n");
-	return FALSE;
-      }
-  }
-#endif
-
-  iov.iov_base = &buf;
-  iov.iov_len = 1;
-
-  memset (&msg, 0, sizeof (msg));
-  msg.msg_iov = &iov;
-  msg.msg_iovlen = 1;
-
-#ifdef HAVE_CMSGCRED
-  memset (&cmsg, 0, sizeof (cmsg));
-  msg.msg_control = &cmsg;
-  msg.msg_controllen = sizeof (cmsg);
-#endif
-
- again:
-  if (recvmsg (client_fd, &msg, 0) < 0)
-    {
-      if (errno == EINTR)
-	goto again;
-
-      dbus_set_error (error, _dbus_error_from_errno (errno),
-                      "Failed to read credentials byte: %s",
-                      _dbus_strerror (errno));
-      return FALSE;
-    }
-
-  if (buf != '\0')
-    {
-      dbus_set_error (error, DBUS_ERROR_FAILED,
-                      "Credentials byte was not nul");
-      return FALSE;
-    }
-
-#ifdef HAVE_CMSGCRED
-  if (cmsg.hdr.cmsg_len < sizeof (cmsg) || cmsg.hdr.cmsg_type != SCM_CREDS)
-    {
-      dbus_set_error (error, DBUS_ERROR_FAILED,
-                      "Message from recvmsg() was not SCM_CREDS");
-      return FALSE;
-    }
-#endif
-
-  _dbus_verbose ("read credentials byte\n");
-
-  {
-#ifdef SO_PEERCRED
-    struct ucred cr;   
-    int cr_len = sizeof (cr);
-   
-    if (getsockopt (client_fd, SOL_SOCKET, SO_PEERCRED, &cr, &cr_len) == 0 &&
-	cr_len == sizeof (cr))
-      {
-	credentials->pid = cr.pid;
-	credentials->uid = cr.uid;
-	credentials->gid = cr.gid;
-      }
-    else
-      {
-	_dbus_verbose ("Failed to getsockopt() credentials, returned len %d/%d: %s\n",
-		       cr_len, (int) sizeof (cr), _dbus_strerror (errno));
-      }
-#elif defined(HAVE_CMSGCRED)
-    credentials->pid = cmsg.cred.cmcred_pid;
-    credentials->uid = cmsg.cred.cmcred_euid;
-    credentials->gid = cmsg.cred.cmcred_groups[0];
-#elif defined(HAVE_GETPEEREID)
-    uid_t euid;
-    gid_t egid;
-    if (getpeereid (client_fd, &euid, &egid) == 0)
-      {
-        credentials->uid = euid;
-        credentials->gid = egid;
-      }
-    else
-      {
-        _dbus_verbose ("Failed to getpeereid() credentials: %s\n", _dbus_strerror (errno));
-      }
-#elif defined(HAVE_GETPEERUCRED)
-    ucred_t * ucred = NULL;
-    if (getpeerucred (client_fd, &ucred) == 0)
-      {
-        credentials->pid = ucred_getpid (ucred);
-        credentials->uid = ucred_geteuid (ucred);
-        credentials->gid = ucred_getegid (ucred);
-      }
-    else
-      {
-        _dbus_verbose ("Failed to getpeerucred() credentials: %s\n", _dbus_strerror (errno));
-      }
-    if (ucred != NULL)
-      ucred_free (ucred);
-#else /* !SO_PEERCRED && !HAVE_CMSGCRED && !HAVE_GETPEEREID && !HAVE_GETPEERUCRED */
-    _dbus_verbose ("Socket credentials not supported on this OS\n");
-#endif
-  }
-
-  _dbus_verbose ("Credentials:"
-                 "  pid "DBUS_PID_FORMAT
-                 "  uid "DBUS_UID_FORMAT
-                 "  gid "DBUS_GID_FORMAT"\n",
-		 credentials->pid,
-		 credentials->uid,
-		 credentials->gid);
-    
-  return TRUE;
-}
-
-/**
  * Sends a single nul byte with our UNIX credentials as ancillary
  * data.  Returns #TRUE if the data was successfully written.  On
  * systems that don't support sending credentials, just writes a byte,
@@ -1036,34 +180,7 @@
     return FALSE;
 }
 
-/**
- * Accepts a connection on a listening socket.
- * Handles EINTR for you.
- *
- * @param listen_fd the listen file descriptor
- * @returns the connection fd of the client, or -1 on error
- */
-int
-_dbus_accept  (int listen_fd)
-{
-  int client_fd;
-  struct sockaddr addr;
-  socklen_t addrlen;
 
-  addrlen = sizeof (addr);
-  
- retry:
-  client_fd = accept (listen_fd, &addr, &addrlen);
-  
-  if (client_fd < 0)
-    {
-      if (errno == EINTR)
-        goto retry;
-    }
-  
-  return client_fd;
-}
-
 /** @} */
 
 /**
@@ -1225,42 +342,6 @@
   return TRUE;
 }
 
-/**
-* Checks to make sure the given directory is 
-* private to the user 
-*
-* @param dir the name of the directory
-* @param error error return
-* @returns #FALSE on failure
-**/
-dbus_bool_t
-_dbus_check_dir_is_private_to_user (DBusString *dir, DBusError *error)
-{
-  const char *directory;
-  struct stat sb;
-	
-  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
-    
-  directory = _dbus_string_get_const_data (dir);
-	
-  if (stat (directory, &sb) < 0)
-    {
-      dbus_set_error (error, _dbus_error_from_errno (errno),
-                      "%s", _dbus_strerror (errno));
-   
-      return FALSE;
-    }
-    
-  if ((S_IROTH & sb.st_mode) || (S_IWOTH & sb.st_mode) ||
-      (S_IRGRP & sb.st_mode) || (S_IWGRP & sb.st_mode))
-    {
-      dbus_set_error (error, DBUS_ERROR_FAILED,
-                     "%s directory is not private to the user", directory);
-      return FALSE;
-    }
-    
-  return TRUE;
-}
 
 /**
  * Parses an unsigned integer contained in a DBusString. Either return
@@ -1342,6 +423,10 @@
 ascii_strtod (const char *nptr,
 	      char      **endptr)
 {
+  /* FIXME: The Win32 C library's strtod() doesn't handle hex.
+   * Presumably many Unixes don't either.
+   */
+
   char *fail_pos;
   double val;
   struct lconv *locale_data;
@@ -1507,209 +592,6 @@
 /** @} */ /* DBusString group */
 
 /**
- * @addtogroup DBusInternalsUtils
- * @{
- */
-static dbus_bool_t
-fill_user_info_from_passwd (struct passwd *p,
-                            DBusUserInfo  *info,
-                            DBusError     *error)
-{
-  _dbus_assert (p->pw_name != NULL);
-  _dbus_assert (p->pw_dir != NULL);
-  
-  info->uid = p->pw_uid;
-  info->primary_gid = p->pw_gid;
-  info->username = _dbus_strdup (p->pw_name);
-  info->homedir = _dbus_strdup (p->pw_dir);
-  
-  if (info->username == NULL ||
-      info->homedir == NULL)
-    {
-      dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
-      return FALSE;
-    }
-
-  return TRUE;
-}
-
-static dbus_bool_t
-fill_user_info (DBusUserInfo       *info,
-                dbus_uid_t          uid,
-                const DBusString   *username,
-                DBusError          *error)
-{
-  const char *username_c;
-  
-  /* exactly one of username/uid provided */
-  _dbus_assert (username != NULL || uid != DBUS_UID_UNSET);
-  _dbus_assert (username == NULL || uid == DBUS_UID_UNSET);
-
-  info->uid = DBUS_UID_UNSET;
-  info->primary_gid = DBUS_GID_UNSET;
-  info->group_ids = NULL;
-  info->n_group_ids = 0;
-  info->username = NULL;
-  info->homedir = NULL;
-  
-  if (username != NULL)
-    username_c = _dbus_string_get_const_data (username);
-  else
-    username_c = NULL;
-
-  /* For now assuming that the getpwnam() and getpwuid() flavors
-   * are always symmetrical, if not we have to add more configure
-   * checks
-   */
-  
-#if defined (HAVE_POSIX_GETPWNAM_R) || defined (HAVE_NONPOSIX_GETPWNAM_R)
-  {
-    struct passwd *p;
-    int result;
-    char buf[1024];
-    struct passwd p_str;
-
-    p = NULL;
-#ifdef HAVE_POSIX_GETPWNAM_R
-    if (uid != DBUS_UID_UNSET)
-      result = getpwuid_r (uid, &p_str, buf, sizeof (buf),
-                           &p);
-    else
-      result = getpwnam_r (username_c, &p_str, buf, sizeof (buf),
-                           &p);
-#else
-    if (uid != DBUS_UID_UNSET)
-      p = getpwuid_r (uid, &p_str, buf, sizeof (buf));
-    else
-      p = getpwnam_r (username_c, &p_str, buf, sizeof (buf));
-    result = 0;
-#endif /* !HAVE_POSIX_GETPWNAM_R */
-    if (result == 0 && p == &p_str)
-      {
-        if (!fill_user_info_from_passwd (p, info, error))
-          return FALSE;
-      }
-    else
-      {
-        dbus_set_error (error, _dbus_error_from_errno (errno),
-                        "User \"%s\" unknown or no memory to allocate password entry\n",
-                        username_c ? username_c : "???");
-        _dbus_verbose ("User %s unknown\n", username_c ? username_c : "???");
-        return FALSE;
-      }
-  }
-#else /* ! HAVE_GETPWNAM_R */
-  {
-    /* I guess we're screwed on thread safety here */
-    struct passwd *p;
-
-    if (uid != DBUS_UID_UNSET)
-      p = getpwuid (uid);
-    else
-      p = getpwnam (username_c);
-
-    if (p != NULL)
-      {
-        if (!fill_user_info_from_passwd (p, info, error))
-          return FALSE;
-      }
-    else
-      {
-        dbus_set_error (error, _dbus_error_from_errno (errno),
-                        "User \"%s\" unknown or no memory to allocate password entry\n",
-                        username_c ? username_c : "???");
-        _dbus_verbose ("User %s unknown\n", username_c ? username_c : "???");
-        return FALSE;
-      }
-  }
-#endif  /* ! HAVE_GETPWNAM_R */
-
-  /* Fill this in so we can use it to get groups */
-  username_c = info->username;
-  
-#ifdef HAVE_GETGROUPLIST
-  {
-    gid_t *buf;
-    int buf_count;
-    int i;
-    
-    buf_count = 17;
-    buf = dbus_new (gid_t, buf_count);
-    if (buf == NULL)
-      {
-        dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
-        goto failed;
-      }
-    
-    if (getgrouplist (username_c,
-                      info->primary_gid,
-                      buf, &buf_count) < 0)
-      {
-        gid_t *new = dbus_realloc (buf, buf_count * sizeof (buf[0]));
-        if (new == NULL)
-          {
-            dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
-            dbus_free (buf);
-            goto failed;
-          }
-        
-        buf = new;
-
-        errno = 0;
-        if (getgrouplist (username_c, info->primary_gid, buf, &buf_count) < 0)
-          {
-            dbus_set_error (error,
-                            _dbus_error_from_errno (errno),
-                            "Failed to get groups for username \"%s\" primary GID "
-                            DBUS_GID_FORMAT ": %s\n",
-                            username_c, info->primary_gid,
-                            _dbus_strerror (errno));
-            dbus_free (buf);
-            goto failed;
-          }
-      }
-
-    info->group_ids = dbus_new (dbus_gid_t, buf_count);
-    if (info->group_ids == NULL)
-      {
-        dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
-        dbus_free (buf);
-        goto failed;
-      }
-    
-    for (i = 0; i < buf_count; ++i)
-      info->group_ids[i] = buf[i];
-
-    info->n_group_ids = buf_count;
-    
-    dbus_free (buf);
-  }
-#else  /* HAVE_GETGROUPLIST */
-  {
-    /* We just get the one group ID */
-    info->group_ids = dbus_new (dbus_gid_t, 1);
-    if (info->group_ids == NULL)
-      {
-        dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
-        goto failed;
-      }
-
-    info->n_group_ids = 1;
-
-    (info->group_ids)[0] = info->primary_gid;
-  }
-#endif /* HAVE_GETGROUPLIST */
-
-  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
-  
-  return TRUE;
-  
- failed:
-  _DBUS_ASSERT_ERROR_IS_SET (error);
-  return FALSE;
-}
-
-/**
  * Gets user info for the given username.
  *
  * @param info user info object to initialize
@@ -1756,7 +638,7 @@
   dbus_free (info->homedir);
 }
 
-/**
+ /**
  * Frees the members of info (but not info itself).
  *
  * @param info the group info
@@ -1789,6 +671,7 @@
 void
 _dbus_credentials_from_current_process (DBusCredentials *credentials)
 {
+#ifndef DBUS_WIN
   /* The POSIX spec certainly doesn't promise this, but
    * we need these assertions to fail as soon as we're wrong about
    * it so we can do the porting fixups
@@ -1796,10 +679,11 @@
   _dbus_assert (sizeof (pid_t) <= sizeof (credentials->pid));
   _dbus_assert (sizeof (uid_t) <= sizeof (credentials->uid));
   _dbus_assert (sizeof (gid_t) <= sizeof (credentials->gid));
+#endif
   
-  credentials->pid = getpid ();
-  credentials->uid = getuid ();
-  credentials->gid = getgid ();
+  credentials->pid = _dbus_getpid ();
+  credentials->uid = _dbus_getuid ();
+  credentials->gid = _dbus_getgid ();
 }
 
 /**
@@ -1826,36 +710,7 @@
     return FALSE;
 }
 
-/**
- * Gets our process ID
- * @returns process ID
- */
-unsigned long
-_dbus_getpid (void)
-{
-  return getpid ();
-}
 
-/** Gets our UID
- * @returns process UID
- */
-dbus_uid_t
-_dbus_getuid (void)
-{
-  return getuid ();
-}
-
-#ifdef DBUS_BUILD_TESTS
-/** Gets our GID
- * @returns process GID
- */
-dbus_gid_t
-_dbus_getgid (void)
-{
-  return getgid ();
-}
-#endif
-
 _DBUS_DEFINE_GLOBAL_LOCK (atomic);
 
 #ifdef DBUS_USE_ATOMIC_INT_486
@@ -1921,163 +776,11 @@
 #endif
 }
 
-/**
- * Wrapper for poll().
- *
- * @param fds the file descriptors to poll
- * @param n_fds number of descriptors in the array
- * @param timeout_milliseconds timeout or -1 for infinite
- * @returns numbers of fds with revents, or <0 on error
- */
-int
-_dbus_poll (DBusPollFD *fds,
-            int         n_fds,
-            int         timeout_milliseconds)
-{
-#ifdef HAVE_POLL
-  /* This big thing is a constant expression and should get optimized
-   * out of existence. So it's more robust than a configure check at
-   * no cost.
-   */
-  if (_DBUS_POLLIN == POLLIN &&
-      _DBUS_POLLPRI == POLLPRI &&
-      _DBUS_POLLOUT == POLLOUT &&
-      _DBUS_POLLERR == POLLERR &&
-      _DBUS_POLLHUP == POLLHUP &&
-      _DBUS_POLLNVAL == POLLNVAL &&
-      sizeof (DBusPollFD) == sizeof (struct pollfd) &&
-      _DBUS_STRUCT_OFFSET (DBusPollFD, fd) ==
-      _DBUS_STRUCT_OFFSET (struct pollfd, fd) &&
-      _DBUS_STRUCT_OFFSET (DBusPollFD, events) ==
-      _DBUS_STRUCT_OFFSET (struct pollfd, events) &&
-      _DBUS_STRUCT_OFFSET (DBusPollFD, revents) ==
-      _DBUS_STRUCT_OFFSET (struct pollfd, revents))
-    {
-      return poll ((struct pollfd*) fds,
-                   n_fds, 
-                   timeout_milliseconds);
-    }
-  else
-    {
-      /* We have to convert the DBusPollFD to an array of
-       * struct pollfd, poll, and convert back.
-       */
-      _dbus_warn ("didn't implement poll() properly for this system yet\n");
-      return -1;
-    }
-#else /* ! HAVE_POLL */
 
-  fd_set read_set, write_set, err_set;
-  int max_fd = 0;
-  int i;
-  struct timeval tv;
-  int ready;
-  
-  FD_ZERO (&read_set);
-  FD_ZERO (&write_set);
-  FD_ZERO (&err_set);
 
-  for (i = 0; i < n_fds; i++)
-    {
-      DBusPollFD *fdp = &fds[i];
 
-      if (fdp->events & _DBUS_POLLIN)
-	FD_SET (fdp->fd, &read_set);
 
-      if (fdp->events & _DBUS_POLLOUT)
-	FD_SET (fdp->fd, &write_set);
-
-      FD_SET (fdp->fd, &err_set);
-
-      max_fd = MAX (max_fd, fdp->fd);
-    }
-    
-  tv.tv_sec = timeout_milliseconds / 1000;
-  tv.tv_usec = (timeout_milliseconds % 1000) * 1000;
-
-  ready = select (max_fd + 1, &read_set, &write_set, &err_set,
-                  timeout_milliseconds < 0 ? NULL : &tv);
-
-  if (ready > 0)
-    {
-      for (i = 0; i < n_fds; i++)
-	{
-	  DBusPollFD *fdp = &fds[i];
-
-	  fdp->revents = 0;
-
-	  if (FD_ISSET (fdp->fd, &read_set))
-	    fdp->revents |= _DBUS_POLLIN;
-
-	  if (FD_ISSET (fdp->fd, &write_set))
-	    fdp->revents |= _DBUS_POLLOUT;
-
-	  if (FD_ISSET (fdp->fd, &err_set))
-	    fdp->revents |= _DBUS_POLLERR;
-	}
-    }
-
-  return ready;
-#endif
-}
-
-/** nanoseconds in a second */
-#define NANOSECONDS_PER_SECOND       1000000000
-/** microseconds in a second */
-#define MICROSECONDS_PER_SECOND      1000000
-/** milliseconds in a second */
-#define MILLISECONDS_PER_SECOND      1000
-/** nanoseconds in a millisecond */
-#define NANOSECONDS_PER_MILLISECOND  1000000
-/** microseconds in a millisecond */
-#define MICROSECONDS_PER_MILLISECOND 1000
-
 /**
- * Sleeps the given number of milliseconds.
- * @param milliseconds number of milliseconds
- */
-void
-_dbus_sleep_milliseconds (int milliseconds)
-{
-#ifdef HAVE_NANOSLEEP
-  struct timespec req;
-  struct timespec rem;
-
-  req.tv_sec = milliseconds / MILLISECONDS_PER_SECOND;
-  req.tv_nsec = (milliseconds % MILLISECONDS_PER_SECOND) * NANOSECONDS_PER_MILLISECOND;
-  rem.tv_sec = 0;
-  rem.tv_nsec = 0;
-
-  while (nanosleep (&req, &rem) < 0 && errno == EINTR)
-    req = rem;
-#elif defined (HAVE_USLEEP)
-  usleep (milliseconds * MICROSECONDS_PER_MILLISECOND);
-#else /* ! HAVE_USLEEP */
-  sleep (MAX (milliseconds / 1000, 1));
-#endif
-}
-
-/**
- * Get current time, as in gettimeofday().
- *
- * @param tv_sec return location for number of seconds
- * @param tv_usec return location for number of microseconds (thousandths)
- */
-void
-_dbus_get_current_time (long *tv_sec,
-                        long *tv_usec)
-{
-  struct timeval t;
-
-  gettimeofday (&t, NULL);
-
-  if (tv_sec)
-    *tv_sec = t.tv_sec;
-  if (tv_usec)
-    *tv_usec = t.tv_usec;
-}
-
-/**
  * Appends the contents of the given file to the string,
  * returning error code. At the moment, won't open a file
  * more than a megabyte in size.
@@ -2102,7 +805,7 @@
   
   filename_c = _dbus_string_get_const_data (filename);
   
-  /* O_BINARY useful on Cygwin */
+  /* O_BINARY useful on Cygwin and Win32 */
   fd = open (filename_c, O_RDONLY | O_BINARY);
   if (fd < 0)
     {
@@ -2142,10 +845,11 @@
   if (sb.st_size > 0 && S_ISREG (sb.st_mode))
     {
       int bytes_read;
+      const int encapsulated_fd = _dbus_fd_to_handle (fd);
 
       while (total < (int) sb.st_size)
         {
-          bytes_read = _dbus_read (fd, str,
+          bytes_read = _dbus_read (encapsulated_fd, str,
                                    sb.st_size - total);
           if (bytes_read <= 0)
             {
@@ -2157,7 +861,7 @@
               _dbus_verbose ("read() failed: %s",
                              _dbus_strerror (errno));
               
-              close (fd);
+              _dbus_close (encapsulated_fd, NULL);
               _dbus_string_set_length (str, orig_len);
               return FALSE;
             }
@@ -2165,7 +869,7 @@
             total += bytes_read;
         }
 
-      close (fd);
+      _dbus_close (encapsulated_fd, NULL);
       return TRUE;
     }
   else if (sb.st_size != 0)
@@ -2254,6 +958,8 @@
       goto out;
     }
 
+  fd = _dbus_fd_to_handle (fd);
+
   need_unlink = TRUE;
   
   total = 0;
@@ -2278,7 +984,7 @@
       total += bytes_written;
     }
 
-  if (close (fd) < 0)
+  if (_dbus_close (fd, NULL) < 0)
     {
       dbus_set_error (error, _dbus_error_from_errno (errno),
                       "Could not close file %s: %s",
@@ -2289,7 +995,11 @@
 
   fd = -1;
   
-  if (rename (tmp_filename_c, filename_c) < 0)
+  if (
+#ifdef DBUS_WIN
+      (unlink (filename_c) == -1 && errno != ENOENT) ||
+#endif
+      rename (tmp_filename_c, filename_c) < 0)
     {
       dbus_set_error (error, _dbus_error_from_errno (errno),
                       "Could not rename %s to %s: %s",
@@ -2309,7 +1019,7 @@
    */
 
   if (fd >= 0)
-    close (fd);
+    _dbus_close (fd, NULL);
         
   if (need_unlink && unlink (tmp_filename_c) < 0)
     _dbus_verbose ("Failed to unlink temp file %s: %s\n",
@@ -2412,7 +1122,7 @@
   
   filename_c = _dbus_string_get_const_data (filename);
 
-  if (mkdir (filename_c, 0700) < 0)
+  if (_dbus_mkdir (filename_c, 0700) < 0)
     {
       if (errno == EEXIST)
         return TRUE;
@@ -2426,46 +1136,7 @@
     return TRUE;
 }
 
-/**
- * Appends the given filename to the given directory.
- *
- * @todo it might be cute to collapse multiple '/' such as "foo//"
- * concat "//bar"
- *
- * @param dir the directory name
- * @param next_component the filename
- * @returns #TRUE on success
- */
-dbus_bool_t
-_dbus_concat_dir_and_file (DBusString       *dir,
-                           const DBusString *next_component)
-{
-  dbus_bool_t dir_ends_in_slash;
-  dbus_bool_t file_starts_with_slash;
 
-  if (_dbus_string_get_length (dir) == 0 ||
-      _dbus_string_get_length (next_component) == 0)
-    return TRUE;
-  
-  dir_ends_in_slash = '/' == _dbus_string_get_byte (dir,
-                                                    _dbus_string_get_length (dir) - 1);
-
-  file_starts_with_slash = '/' == _dbus_string_get_byte (next_component, 0);
-
-  if (dir_ends_in_slash && file_starts_with_slash)
-    {
-      _dbus_string_shorten (dir, 1);
-    }
-  else if (!(dir_ends_in_slash || file_starts_with_slash))
-    {
-      if (!_dbus_string_append_byte (dir, '/'))
-        return FALSE;
-    }
-
-  return _dbus_string_copy (next_component, 0, dir,
-                            _dbus_string_get_length (dir));
-}
-
 static void
 pseudorandom_generate_random_bytes_buffer (char *buffer,
                                            int   n_bytes)
@@ -2568,14 +1239,18 @@
   old_len = _dbus_string_get_length (str);
   fd = -1;
 
+#ifndef DBUS_WIN
   /* note, urandom on linux will fall back to pseudorandom */
   fd = open ("/dev/urandom", O_RDONLY);
+#endif
+
   if (fd < 0)
     return pseudorandom_generate_random_bytes (str, n_bytes);
 
+#ifndef DBUS_WIN
   if (_dbus_read (fd, str, n_bytes) != n_bytes)
     {
-      close (fd);
+      _dbus_close (fd, NULL);
       _dbus_string_set_length (str, old_len);
       return pseudorandom_generate_random_bytes (str, n_bytes);
     }
@@ -2586,6 +1261,10 @@
   close (fd);
   
   return TRUE;
+#else
+  _dbus_assert_not_reached ("_dbus_generate_random_bytes fails");
+  return FALSE;
+#endif
 }
 
 /**
@@ -2625,63 +1304,17 @@
   return TRUE;
 }
 
-/**
- * A wrapper around strerror() because some platforms
- * may be lame and not have strerror().
- *
- * @param error_number errno.
- * @returns error description.
- */
-const char*
-_dbus_strerror (int error_number)
-{
-  const char *msg;
-  
-  msg = strerror (error_number);
-  if (msg == NULL)
-    msg = "unknown";
 
-  return msg;
-}
 
-/**
- * signal (SIGPIPE, SIG_IGN);
- */
-void
-_dbus_disable_sigpipe (void)
-{
-  signal (SIGPIPE, SIG_IGN);
-}
 
-/**
- * Sets the file descriptor to be close
- * on exec. Should be called for all file
- * descriptors in D-Bus code.
- *
- * @param fd the file descriptor
- */
-void
-_dbus_fd_set_close_on_exec (int fd)
-{
-  int val;
-  
-  val = fcntl (fd, F_GETFD, 0);
-  
-  if (val < 0)
-    return;
 
-  val |= FD_CLOEXEC;
-  
-  fcntl (fd, F_SETFD, val);
-}
-
 /**
- * Converts a UNIX errno into a #DBusError name.
+ * Converts a UNIX errno or a Winsock error code into a #DBusError name.
  *
  * @todo should cover more errnos, specifically those
  * from open().
  * 
- * @param error_number the errno.
+ * @param error_number the errno or Winsock error code.
  * @returns an error name
  */
 const char*
@@ -2784,73 +1417,7 @@
   _exit (code);
 }
 
-/**
- * Closes a file descriptor.
- *
- * @param fd the file descriptor
- * @param error error object
- * @returns #FALSE if error set
- */
-dbus_bool_t
-_dbus_close (int        fd,
-             DBusError *error)
-{
-  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
-  
- again:
-  if (close (fd) < 0)
-    {
-      if (errno == EINTR)
-        goto again;
 
-      dbus_set_error (error, _dbus_error_from_errno (errno),
-                      "Could not close fd %d", fd);
-      return FALSE;
-    }
-
-  return TRUE;
-}
-
-/**
- * Sets a file descriptor to be nonblocking.
- *
- * @param fd the file descriptor.
- * @param error address of error location.
- * @returns #TRUE on success.
- */
-dbus_bool_t
-_dbus_set_fd_nonblocking (int             fd,
-                          DBusError      *error)
-{
-  int val;
-
-  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
-  
-  val = fcntl (fd, F_GETFL, 0);
-  if (val < 0)
-    {
-      dbus_set_error (error, _dbus_error_from_errno (errno),
-                      "Failed to get flags from file descriptor %d: %s",
-                      fd, _dbus_strerror (errno));
-      _dbus_verbose ("Failed to get flags for fd %d: %s\n", fd,
-                     _dbus_strerror (errno));
-      return FALSE;
-    }
-
-  if (fcntl (fd, F_SETFL, val | O_NONBLOCK) < 0)
-    {
-      dbus_set_error (error, _dbus_error_from_errno (errno),
-                      "Failed to set nonblocking flag of file descriptor %d: %s",
-                      fd, _dbus_strerror (errno));
-      _dbus_verbose ("Failed to set fd %d nonblocking: %s\n",
-                     fd, _dbus_strerror (errno));
-
-      return FALSE;
-    }
-
-  return TRUE;
-}
-
 #if !defined (DBUS_DISABLE_ASSERT) || defined(DBUS_BUILD_TESTS)
 /**
  * On GNU libc systems, print a crude backtrace to the verbose log.
@@ -2896,8 +1463,8 @@
 _dbus_parse_uid (const DBusString      *uid_str,
                  dbus_uid_t            *uid)
 {
+  dbus_uid_t val;
   int end;
-  long val;
   
   if (_dbus_string_get_length (uid_str) == 0)
     {
@@ -2907,8 +1474,7 @@
 
   val = -1;
   end = 0;
-  if (!_dbus_string_parse_int (uid_str, 0, &val,
-                               &end))
+  if (!_dbus_string_parse_int (uid_str, 0, &val, &end))
     {
       _dbus_verbose ("could not parse string as a UID\n");
       return FALSE;
@@ -2925,85 +1491,9 @@
   return TRUE;
 }
 
-/**
- * Creates a full-duplex pipe (as in socketpair()).
- * Sets both ends of the pipe nonblocking.
- *
- * @todo libdbus only uses this for the debug-pipe server, so in
- * principle it could be in dbus-sysdeps-util.c, except that
- * dbus-sysdeps-util.c isn't in libdbus when tests are enabled and the
- * debug-pipe server is used.
- * 
- * @param fd1 return location for one end
- * @param fd2 return location for the other end
- * @param blocking #TRUE if pipe should be blocking
- * @param error error return
- * @returns #FALSE on failure (if error is set)
- */
-dbus_bool_t
-_dbus_full_duplex_pipe (int        *fd1,
-                        int        *fd2,
-                        dbus_bool_t blocking,
-                        DBusError  *error)
-{
-#ifdef HAVE_SOCKETPAIR
-  int fds[2];
 
-  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
-  
-  if (socketpair (AF_UNIX, SOCK_STREAM, 0, fds) < 0)
-    {
-      dbus_set_error (error, _dbus_error_from_errno (errno),
-                      "Could not create full-duplex pipe");
-      return FALSE;
-    }
 
-  if (!blocking &&
-      (!_dbus_set_fd_nonblocking (fds[0], NULL) ||
-       !_dbus_set_fd_nonblocking (fds[1], NULL)))
-    {
-      dbus_set_error (error, _dbus_error_from_errno (errno),
-                      "Could not set full-duplex pipe nonblocking");
-      
-      close (fds[0]);
-      close (fds[1]);
-      
-      return FALSE;
-    }
-  
-  *fd1 = fds[0];
-  *fd2 = fds[1];
-
-  _dbus_verbose ("full-duplex pipe %d <-> %d\n",
-                 *fd1, *fd2);
-  
-  return TRUE;  
-#else
-  _dbus_warn ("_dbus_full_duplex_pipe() not implemented on this OS\n");
-  dbus_set_error (error, DBUS_ERROR_FAILED,
-                  "_dbus_full_duplex_pipe() not implemented on this OS");
-  return FALSE;
-#endif
-}
-
-
 /**
- * Measure the length of the given format string and arguments,
- * not including the terminating nul.
- *
- * @param format a printf-style format string
- * @param args arguments for the format string
- * @returns length of the given format string and args
- */
-int
-_dbus_printf_string_upper_bound (const char *format,
-                                 va_list     args)
-{
-  char c;
-  return vsnprintf (&c, 1, format, args);
-}
-
-/**
  * Gets the temporary files directory by inspecting the environment variables 
  * TMPDIR, TMP, and TEMP in that order. If none of those are set "/tmp" is returned
  *
Index: dbus/dbus-sysdeps.h
===================================================================
--- dbus/dbus-sysdeps.h	(revision 280)
+++ dbus/dbus-sysdeps.h	(working copy)
@@ -39,6 +39,14 @@
 
 #include <stdarg.h>
 
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+
+#ifdef HAVE_STDIO_H
+#include <stdio.h>
+#endif
+
 DBUS_BEGIN_DECLS
 
 /* The idea of this file is to encapsulate everywhere that we're
@@ -89,6 +97,9 @@
                      int               start2,
                      int               len2);
 
+ int _dbus_mkdir    (const char *path, 
+	                 mode_t mode); 
+
 typedef unsigned long dbus_pid_t;
 typedef unsigned long dbus_uid_t;
 typedef unsigned long dbus_gid_t;
@@ -101,6 +112,12 @@
 #define DBUS_UID_FORMAT "%lu"
 #define DBUS_GID_FORMAT "%lu"
 
+int _dbus_handle_to_socket (int handle);
+int _dbus_handle_to_fd     (int handle);
+int _dbus_socket_to_handle (int socket);
+int _dbus_fd_to_handle     (int fd);
+
+
 /**
  * Struct representing socket credentials
  */
@@ -136,8 +153,8 @@
 void        _dbus_credentials_from_current_process (DBusCredentials       *credentials);
 dbus_bool_t _dbus_credentials_match                (const DBusCredentials *expected_credentials,
                                                     const DBusCredentials *provided_credentials);
+dbus_bool_t  write_credentials_byte (int server_fd, DBusError      *error);
 
-
 typedef struct DBusUserInfo  DBusUserInfo;
 typedef struct DBusGroupInfo DBusGroupInfo;
 
@@ -169,6 +186,11 @@
 dbus_bool_t _dbus_user_info_fill_uid (DBusUserInfo     *info,
                                       dbus_uid_t        uid,
                                       DBusError        *error);
+dbus_bool_t fill_user_info     (DBusUserInfo     *info,
+                                      dbus_uid_t        uid,
+                                      const DBusString *username,
+                                      DBusError        *error);
+
 void        _dbus_user_info_free     (DBusUserInfo     *info);
 
 dbus_bool_t _dbus_group_info_fill     (DBusGroupInfo    *info,
Index: dbus/dbus-string-util.c
===================================================================
--- dbus/dbus-string-util.c	(revision 280)
+++ dbus/dbus-string-util.c	(working copy)
@@ -739,7 +739,27 @@
   test_roundtrips (test_hex_roundtrip);
   
   _dbus_string_free (&str);
-  
+
+  {
+  int found,found_len;
+  _dbus_string_init_const (&str, "012\r\n567\n90");
+
+  if (!_dbus_string_find_eol(&str, 0, &found, &found_len) || found != 3 || found_len != 2)
+    _dbus_assert_not_reached ("Did not find '\\r\\n'");
+  if (found != 3 || found_len != 2)
+    _dbus_assert_not_reached ("invalid return values");
+
+  if (!_dbus_string_find_eol(&str, 5, &found, &found_len))
+    _dbus_assert_not_reached ("Did not find '\\n'");
+  if (found != 8 || found_len != 1)
+    _dbus_assert_not_reached ("invalid return values");
+  	
+  if (_dbus_string_find_eol(&str, 9, NULL, NULL))
+    _dbus_assert_not_reached ("Found not expected '\\n'");
+
+  _dbus_string_free (&str);
+  }
+
   return TRUE;
 }
 
Index: dbus/Makefile.am
===================================================================
--- dbus/Makefile.am	(revision 280)
+++ dbus/Makefile.am	(working copy)
@@ -104,6 +104,7 @@
 	dbus-string.h				\
 	dbus-string-private.h			\
 	dbus-sysdeps.c				\
+	dbus-sysdeps-unix.c		    \
 	dbus-sysdeps.h				\
 	dbus-userdb.c				\
 	dbus-userdb.h
Index: tools/dbus-monitor.c
===================================================================
--- tools/dbus-monitor.c	(revision 279)
+++ tools/dbus-monitor.c	(working copy)
@@ -19,6 +19,7 @@
  *
  */
 
+#include <config.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
Index: tools/dbus-send.c
===================================================================
--- tools/dbus-send.c	(revision 279)
+++ tools/dbus-send.c	(working copy)
@@ -19,6 +19,7 @@
  *
  */
 
+#include <config.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

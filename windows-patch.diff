Index: test/spawn-test.c
===================================================================
--- test/spawn-test.c	(revision 298)
+++ test/spawn-test.c	(working copy)
@@ -31,7 +31,7 @@
     argv_copy [i] = argv[i + 1];
   argv_copy[argc - 1] = NULL;
   
-  if (!_dbus_spawn_async_with_babysitter (NULL, argv_copy, setup_func, NULL, &error))
+  if (!_dbus_spawn_async_with_babysitter (NULL, argv_copy, NULL, setup_func, NULL, &error))
     {
       fprintf (stderr, "Could not launch application: \"%s\"\n",
 	       error.message);
Index: test/name-test/test-names.c
===================================================================
--- test/name-test/test-names.c	(revision 298)
+++ test/name-test/test-names.c	(working copy)
@@ -1,9 +1,11 @@
 #include <stdio.h>
 #include <stdlib.h>
-#include <unistd.h>
 #include <string.h>
 #include <dbus/dbus.h>
 #include <dbus/dbus-connection-internal.h>
+#ifndef DBUS_WIN
+#include <unistd.h>
+#endif
 
 #define REMOVE_CONNECTION 0
 #define ADD_CONNECTION 1
Index: test/name-test/test-threads-init.c
===================================================================
--- test/name-test/test-threads-init.c	(revision 298)
+++ test/name-test/test-threads-init.c	(working copy)
@@ -8,7 +8,9 @@
 #include <stdlib.h>
 
 #include <dbus/dbus-internals.h>
+#include <dbus/dbus-connection-internal.h>
 
+
 static void
 _run_iteration (DBusConnection *conn)
 {
Index: test/test-utils.c
===================================================================
--- test/test-utils.c	(revision 298)
+++ test/test-utils.c	(working copy)
@@ -1,5 +1,7 @@
 #include "test-utils.h"
 
+void _dbus_connection_close_internal (DBusConnection *connection);
+
 typedef struct
 {
   DBusLoop *loop;
Index: test/test-segfault.c
===================================================================
--- test/test-segfault.c	(revision 298)
+++ test/test-segfault.c	(working copy)
@@ -1,10 +1,27 @@
 /* This is simply a process that segfaults */
+#include <config.h>
 #include <stdlib.h>
 #include <signal.h>
 
+#ifdef DBUS_WIN
+#define RLIMIT_CORE	4		/* max core file size */
+typedef unsigned long rlim_t;
+struct rlimit {
+	rlim_t	rlim_cur;
+	rlim_t	rlim_max;
+};
+static int getrlimit (int __resource, struct rlimit *__rlp) {
+  return -1;
+}
+static int setrlimit (int __resource, const struct rlimit *__rlp) {
+  return -1;
+}
+#else
 #include <sys/time.h>
 #include <sys/resource.h>
+#endif
 
+
 int
 main (int argc, char **argv)
 {
Index: test/Makefile.am
===================================================================
--- test/Makefile.am	(revision 298)
+++ test/Makefile.am	(working copy)
@@ -110,7 +110,7 @@
 		test -d $(top_builddir)/test/$$D || mkdir $(top_builddir)/test/$$D || exit 1 ;	\
 	done ;											\
 	if ! (test $(srcdir) = . || test $(srcdir) -ef .) ; then								\
-		FILES=`(cd $(srcdir) && $(FIND_TESTS))` ;					\
+		FILES=`(cd $(srcdir) && $(FIND_TESTS) | grep -Ev "(.svn|CVS)" )` ;		\
 	        for F in $$FILES; do								\
 			SRC=$(srcdir)/$$F ;							\
 			DEST=$(top_builddir)/test/$$F ;						\
Index: test/test-sleep-forever.c
===================================================================
--- test/test-sleep-forever.c	(revision 298)
+++ test/test-sleep-forever.c	(working copy)
@@ -1,6 +1,12 @@
 /* This is a process that just sleeps infinitely. */
 
+
+#include <config.h>
+#ifndef DBUS_WIN
 #include <unistd.h>
+#else
+#include <stdlib.h>
+#endif
 
 int
 main (int argc, char **argv)
Index: bus/dispatch.c
===================================================================
--- bus/dispatch.c	(revision 298)
+++ bus/dispatch.c	(working copy)
@@ -4061,9 +4061,11 @@
       _dbus_warn ("Messages were left over after setting up initial SHA-1 connection\n");
       _dbus_assert_not_reached ("initial connection setup failed");
     }
-  
+
+#ifndef DBUS_WIN_FIXME  
   check1_try_iterations (context, "create_and_hello_sha1",
                          check_hello_connection);
+#endif
 
   kill_client_connection_unchecked (foo);
 
Index: bus/activation.c
===================================================================
--- bus/activation.c	(revision 298)
+++ bus/activation.c	(working copy)
@@ -34,7 +34,6 @@
 #include <dbus/dbus-spawn.h>
 #include <dbus/dbus-timeout.h>
 #include <dbus/dbus-sysdeps.h>
-#include <dirent.h>
 #include <errno.h>
 
 #define DBUS_SERVICE_SECTION "D-BUS Service"
@@ -1304,6 +1303,7 @@
   DBusMessage *message;
   DBusString service_str;
   char **argv;
+  char **envp = NULL;
   int argc;
   dbus_bool_t retval;
   DBusHashIter iter;
@@ -1535,6 +1535,7 @@
 
   _dbus_verbose ("Spawning %s ...\n", argv[0]);
   if (!_dbus_spawn_async_with_babysitter (&pending_activation->babysitter, argv,
+                                          envp,
                                           child_setup, activation, 
                                           error))
     {
Index: bus/main.c
===================================================================
--- bus/main.c	(revision 298)
+++ bus/main.c	(working copy)
@@ -51,7 +51,7 @@
 #endif /* DBUS_BUS_ENABLE_DNOTIFY_ON_LINUX  */
     case SIGHUP:
       _dbus_string_init_const (&str, "foo");
-      if (!_dbus_write (reload_pipe[RELOAD_WRITE_END], &str, 0, 1))
+      if (!_dbus_write_socket (reload_pipe[RELOAD_WRITE_END], &str, 0, 1))
 	{
 	  _dbus_warn ("Unable to write to reload pipe.\n");
 	  exit (1);
@@ -150,7 +150,7 @@
   DBusError error;
   DBusString str;
   _dbus_string_init (&str);
-  if (_dbus_read (reload_pipe[RELOAD_READ_END], &str, 1) != 1)
+  if (_dbus_read_socket (reload_pipe[RELOAD_READ_END], &str, 1) != 1)
     {
       _dbus_warn ("Couldn't read from reload pipe.\n");
       exit (1);
Index: bus/desktop-file.c
===================================================================
--- bus/desktop-file.c	(revision 298)
+++ bus/desktop-file.c	(working copy)
@@ -360,15 +360,15 @@
 static void
 parse_comment_or_blank (BusDesktopFileParser *parser)
 {
-  int line_end;
+  int line_end, eol_len;
   
-  if (!_dbus_string_find (&parser->data, parser->pos, "\n", &line_end))
+  if (!_dbus_string_find_eol (&parser->data, parser->pos, &line_end, &eol_len))
     line_end = parser->len;
 
   if (line_end == parser->len)
     parser->pos = parser->len;
   else
-    parser->pos = line_end + 1;
+    parser->pos = line_end + eol_len;
   
   parser->line_num += 1;
 }
@@ -393,12 +393,12 @@
 static dbus_bool_t
 parse_section_start (BusDesktopFileParser *parser, DBusError *error)
 {
-  int line_end;
+  int line_end, eol_len;
   char *section_name;
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
-  
-  if (!_dbus_string_find (&parser->data, parser->pos, "\n", &line_end))
+    
+  if (!_dbus_string_find_eol (&parser->data, parser->pos, &line_end, &eol_len))
     line_end = parser->len;
   
   if (line_end - parser->pos <= 2 ||
@@ -436,7 +436,7 @@
   if (line_end == parser->len)
     parser->pos = parser->len;
   else
-    parser->pos = line_end + 1;
+    parser->pos = line_end + eol_len;
   
   parser->line_num += 1;
 
@@ -448,7 +448,7 @@
 static dbus_bool_t
 parse_key_value (BusDesktopFileParser *parser, DBusError *error)
 {
-  int line_end;
+  int line_end, eol_len;
   int key_start, key_end;
   int value_start;
   int p;
@@ -458,7 +458,7 @@
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
   
-  if (!_dbus_string_find (&parser->data, parser->pos, "\n", &line_end))
+  if (!_dbus_string_find_eol (&parser->data, parser->pos, &line_end, &eol_len))
     line_end = parser->len;
   
   p = parser->pos;
@@ -481,7 +481,7 @@
       if (line_end == parser->len)
 	parser->pos = parser->len;
       else
-	parser->pos = line_end + 1;
+	parser->pos = line_end + eol_len;
 	  
       parser->line_num += 1;
 
@@ -560,7 +560,7 @@
   if (line_end == parser->len)
     parser->pos = parser->len;
   else
-    parser->pos = line_end + 1;
+    parser->pos = line_end + eol_len;
   
   parser->line_num += 1;
 
Index: bus/bus.c
===================================================================
--- bus/bus.c	(revision 298)
+++ bus/bus.c	(working copy)
@@ -630,7 +630,7 @@
         }
 
       bytes = _dbus_string_get_length (&addr);
-      if (_dbus_write (print_addr_fd, &addr, 0, bytes) != bytes)
+      if (_dbus_write_socket (print_addr_fd, &addr, 0, bytes) != bytes)
         {
           dbus_set_error (error, DBUS_ERROR_FAILED,
                           "Printing message bus address: %s\n",
@@ -640,7 +640,7 @@
         }
 
       if (print_addr_fd > 2)
-        _dbus_close (print_addr_fd, NULL);
+        _dbus_close_socket (print_addr_fd, NULL);
 
       _dbus_string_free (&addr);
     }
@@ -731,7 +731,7 @@
         }
 
       bytes = _dbus_string_get_length (&pid);
-      if (_dbus_write (print_pid_fd, &pid, 0, bytes) != bytes)
+      if (_dbus_write_socket (print_pid_fd, &pid, 0, bytes) != bytes)
         {
           dbus_set_error (error, DBUS_ERROR_FAILED,
                           "Printing message bus PID: %s\n",
@@ -741,7 +741,7 @@
         }
 
       if (print_pid_fd > 2)
-        _dbus_close (print_pid_fd, NULL);
+        _dbus_close_socket (print_pid_fd, NULL);
       
       _dbus_string_free (&pid);
     }
Index: dbus/dbus-string.c
===================================================================
--- dbus/dbus-string.c	(revision 298)
+++ dbus/dbus-string.c	(working copy)
@@ -1790,6 +1790,72 @@
 }
 
 /**
+ * Finds end of line ("\r\n" or "\n") in the string,
+ * returning #TRUE and filling in the byte index
+ * where the eol string was found, if it was found.
+ * Returns #FALSE if eol wasn't found.
+ *
+ * @param str the string
+ * @param start where to start looking
+ * @param found return location for where it was found, or #NULL
+ * @param found_len return length of found eol string
+ * @returns #TRUE if found
+ */
+dbus_bool_t
+_dbus_string_find_eol (const DBusString *str,
+                   int               start,
+                   int              *found,
+                   int              *found_len)
+{
+  int i;
+
+  DBUS_CONST_STRING_PREAMBLE (str);
+  _dbus_assert (start <= real->len);
+  _dbus_assert (start >= 0);
+  
+  i = start;
+  while (i < real->len)
+    {
+      if (real->str[i] == '\r') 
+        {
+          if ((i+1) < real->len && real->str[i+1] == '\n') /* "\r\n" */
+            {
+              if (found) 
+                *found = i;
+              if (found_len)
+                *found_len = 2;
+              return TRUE;
+            } 
+          else /* only "\r" */
+            {
+              if (found) 
+                *found = i;
+              if (found_len)
+                *found_len = 1;
+              return TRUE;
+            }
+        } 
+      else if (real->str[i] == '\n')  /* only "\n" */
+        {
+          if (found) 
+            *found = i;
+          if (found_len)
+            *found_len = 1;
+          return TRUE;
+        }      
+      ++i;
+    }
+
+  if (found)
+    *found = real->len;
+
+  if (found_len)
+    *found_len = 0;
+  
+  return FALSE;
+}
+
+/**
  * Finds the given substring in the string,
  * up to a certain position,
  * returning #TRUE and filling in the byte index
@@ -1957,52 +2023,18 @@
 _dbus_string_pop_line (DBusString *source,
                        DBusString *dest)
 {
-  int eol;
-  dbus_bool_t have_newline;
+  int eol, eol_len;
   
   _dbus_string_set_length (dest, 0);
   
   eol = 0;
-  if (_dbus_string_find (source, 0, "\n", &eol))
-    {
-      have_newline = TRUE;
-      eol += 1; /* include newline */
-    }
-  else
-    {
+  if (!_dbus_string_find_eol (source, 0, &eol, &eol_len))
       eol = _dbus_string_get_length (source);
-      have_newline = FALSE;
-    }
 
   if (eol == 0)
     return FALSE; /* eof */
   
-  if (!_dbus_string_move_len (source, 0, eol,
-                              dest, 0))
-    {
-      return FALSE;
-    }
-
-  /* dump the newline and the \r if we have one */
-  if (have_newline)
-    {
-      dbus_bool_t have_cr;
-      
-      _dbus_assert (_dbus_string_get_length (dest) > 0);
-
-      if (_dbus_string_get_length (dest) > 1 &&
-          _dbus_string_get_byte (dest,
-                                 _dbus_string_get_length (dest) - 2) == '\r')
-        have_cr = TRUE;
-      else
-        have_cr = FALSE;
-        
-      _dbus_string_set_length (dest,
-                               _dbus_string_get_length (dest) -
-                               (have_cr ? 2 : 1));
-    }
-  
-  return TRUE;
+  return _dbus_string_move_len (source, 0, eol, dest, 0);
 }
 
 #ifdef DBUS_BUILD_TESTS
Index: dbus/dbus-string.h
===================================================================
--- dbus/dbus-string.h	(revision 298)
+++ dbus/dbus-string.h	(working copy)
@@ -215,6 +215,10 @@
                                                   int                start,
                                                   const char        *substr,
                                                   int               *found);
+dbus_bool_t   _dbus_string_find_eol               (const DBusString *str,
+                                                  int               start,
+                                                  int               *found,
+                                                  int               *found_len);
 dbus_bool_t   _dbus_string_find_to               (const DBusString  *str,
                                                   int                start,
                                                   int                end,
Index: dbus/dbus-server-debug-pipe.c
===================================================================
--- dbus/dbus-server-debug-pipe.c	(revision 298)
+++ dbus/dbus-server-debug-pipe.c	(working copy)
@@ -260,8 +260,8 @@
                                                  NULL, &address);
   if (client_transport == NULL)
     {
-      _dbus_close (client_fd, NULL);
-      _dbus_close (server_fd, NULL);
+      _dbus_close_socket (client_fd, NULL);
+      _dbus_close_socket (server_fd, NULL);
       dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
       _dbus_string_free (&address);
       return NULL;
@@ -276,7 +276,7 @@
   if (server_transport == NULL)
     {
       _dbus_transport_unref (client_transport);
-      _dbus_close (server_fd, NULL);
+      _dbus_close_socket (server_fd, NULL);
       dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
       return NULL;
     }
Index: dbus/dbus-sysdeps-util-unix.c
===================================================================
--- dbus/dbus-sysdeps-util-unix.c	(revision 298)
+++ dbus/dbus-sysdeps-util-unix.c	(working copy)
@@ -152,7 +152,7 @@
 	    }
 	  
 	  bytes = _dbus_string_get_length (&pid);
-	  if (_dbus_write (print_pid_fd, &pid, 0, bytes) != bytes)
+	  if (_dbus_write_socket (print_pid_fd, &pid, 0, bytes) != bytes)
 	    {
 	      dbus_set_error (error, DBUS_ERROR_FAILED,
 			      "Printing message bus PID: %s\n",
Index: dbus/dbus-server-unix.c
===================================================================
--- dbus/dbus-server-unix.c	(revision 298)
+++ dbus/dbus-server-unix.c	(working copy)
@@ -27,12 +27,16 @@
 #include "dbus-connection-internal.h"
 #include "dbus-string.h"
 #include <sys/types.h>
+#ifdef DBUS_WIN
+#include "dbus-sockets-win.h"
+#else
 #include <unistd.h>
+#endif
 
 /**
- * @defgroup DBusServerUnix DBusServer implementations for UNIX
+ * @defgroup DBusServerUnix DBusServer implementations for UNIX and Winsock
  * @ingroup  DBusInternals
- * @brief Implementation details of DBusServer on UNIX
+ * @brief Implementation details of DBusServer on UNIX and Winsock
  *
  * @{
  */
@@ -102,7 +106,7 @@
   transport = _dbus_transport_new_for_fd (client_fd, &server->guid_hex, NULL);
   if (transport == NULL)
     {
-      _dbus_close (client_fd, NULL);
+      _dbus_close_socket (client_fd, NULL);
       SERVER_UNLOCK (server);
       return FALSE;
     }
@@ -219,7 +223,7 @@
       unix_server->watch = NULL;
     }
   
-  _dbus_close (unix_server->fd, NULL);
+  _dbus_close_socket (unix_server->fd, NULL);
   unix_server->fd = -1;
 
   if (unix_server->socket_name != NULL)
@@ -303,6 +307,8 @@
   return (DBusServer*) unix_server;
 }
 
+#ifndef DBUS_WIN
+
 /**
  * Creates a new server listening on the given Unix domain socket.
  *
@@ -373,7 +379,7 @@
   return server;
 
  failed_2:
-  _dbus_close (listen_fd, NULL);
+  _dbus_close_socket (listen_fd, NULL);
  failed_1:
   dbus_free (path_copy);
  failed_0:
@@ -382,11 +388,94 @@
   return NULL;
 }
 
+#else /* ifndef DBUS_WIN */
+
 /**
- * Creates a new server listening on the given hostname and port.
- * If the hostname is NULL, listens on localhost.
+ * Creates a new server listening on the given Windows named pipe.
  *
- * @param host the hostname to listen on.
+ * @param path the path for the domain socket.
+ * @param abstract #TRUE to use abstract socket namespace
+ * @param error location to store reason for failure.
+ * @returns the new server, or #NULL on failure.
+ */
+DBusServer*
+_dbus_server_new_for_domain_socket (const char     *path,
+                                    dbus_bool_t     abstract,
+                                    DBusError      *error)
+{
+  DBusServer *server;
+  DBusServerUnix *unix_server;
+  int listen_fd;
+  DBusString address;
+  char *path_copy;
+  
+  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
+
+  if (!_dbus_string_init (&address))
+    {
+      _DBUS_SET_OOM (error);
+      return NULL;
+    }
+
+  if ((abstract &&
+       !_dbus_string_append (&address, "unix:abstract=")) ||
+      (!abstract &&
+       !_dbus_string_append (&address, "unix:path=")) ||
+      !_dbus_string_append (&address, path))
+    {
+      _DBUS_SET_OOM (error);
+      goto failed_0;
+    }
+
+  path_copy = _dbus_strdup (path);
+  if (path_copy == NULL)
+    {
+      _DBUS_SET_OOM (error);
+      goto failed_0;
+    }
+  
+  listen_fd = _dbus_listen_unix_socket (path, abstract, error);
+  
+  if (listen_fd < 0)
+    {
+      _DBUS_ASSERT_ERROR_IS_SET (error);
+      goto failed_1;
+    }
+  
+  _dbus_fd_set_close_on_exec (listen_fd);
+  server = _dbus_server_new_for_fd (listen_fd, &address);
+  if (server == NULL)
+    {
+      _DBUS_SET_OOM (error);
+      goto failed_2;
+    }
+
+  unix_server = (DBusServerUnix*) server;
+  unix_server->socket_name = path_copy;
+  
+  _dbus_string_free (&address);
+  
+  return server;
+
+ failed_2:
+  _dbus_close_socket (listen_fd, NULL);
+ failed_1:
+  dbus_free (path_copy);
+ failed_0:
+  _dbus_string_free (&address);
+
+  return NULL;
+}
+
+#endif /* ifndef DBUS_WIN */
+
+
+/**
+ * Creates a new server listening on the given hostname and port.  If
+ * the hostname is NULL, listens on localhost. If the hostname is an
+ * empty string, listens on any local host address.
+ *
+ * @param host the hostname for the address to listen.
  * @param port the port to listen on.
  * @param error location to store reason for failure.
  * @returns the new server, or #NULL on failure.
@@ -436,7 +525,7 @@
   if (server == NULL)
     {
       dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
-      _dbus_close (listen_fd, NULL);
+      _dbus_close_socket (listen_fd, NULL);
       _dbus_string_free (&address);
       return NULL;
     }
Index: dbus/dbus-test.c
===================================================================
--- dbus/dbus-test.c	(revision 298)
+++ dbus/dbus-test.c	(working copy)
@@ -154,7 +154,9 @@
   
   run_test ("hash", specific_test, _dbus_hash_test);
 
+#ifndef DBUS_WIN
   run_data_test ("spawn", specific_test, _dbus_spawn_test, test_data_dir);
+#endif
   
   run_data_test ("userdb", specific_test, _dbus_userdb_test, test_data_dir);
   
Index: dbus/dbus-spawn.c
===================================================================
--- dbus/dbus-spawn.c	(revision 298)
+++ dbus/dbus-spawn.c	(working copy)
@@ -276,13 +276,13 @@
            * a hangup and then the babysitter will
            * quit itself.
            */
-          _dbus_close (sitter->socket_to_babysitter, NULL);
+          _dbus_close_socket (sitter->socket_to_babysitter, NULL);
           sitter->socket_to_babysitter = -1;
         }
 
       if (sitter->error_pipe_from_child >= 0)
         {
-          _dbus_close (sitter->error_pipe_from_child, NULL);
+          _dbus_close_socket (sitter->error_pipe_from_child, NULL);
           sitter->error_pipe_from_child = -1;
         }
 
@@ -470,7 +470,7 @@
 close_socket_to_babysitter (DBusBabysitter *sitter)
 {
   _dbus_verbose ("Closing babysitter\n");
-  _dbus_close (sitter->socket_to_babysitter, NULL);
+  _dbus_close_socket (sitter->socket_to_babysitter, NULL);
   sitter->socket_to_babysitter = -1;
 }
 
@@ -478,7 +478,7 @@
 close_error_pipe_from_child (DBusBabysitter *sitter)
 {
   _dbus_verbose ("Closing child error\n");
-  _dbus_close (sitter->error_pipe_from_child, NULL);
+  _dbus_close_socket (sitter->error_pipe_from_child, NULL);
   sitter->error_pipe_from_child = -1;
 }
 
@@ -753,7 +753,7 @@
     return -1;
   else
     {
-      ret = _dbus_close (*fd, NULL);
+      ret = _dbus_close_socket (*fd, NULL);
       *fd = -1;
     }
 
@@ -1021,6 +1021,7 @@
  *
  * @param sitter_p return location for babysitter or #NULL
  * @param argv the executable and arguments
+ * @param env the environment (not used on unix yet)
  * @param child_setup function to call in child pre-exec()
  * @param user_data user data for setup function
  * @param error error object to be filled in if function fails
@@ -1029,6 +1030,7 @@
 dbus_bool_t
 _dbus_spawn_async_with_babysitter (DBusBabysitter          **sitter_p,
                                    char                    **argv,
+                                   char                    **env,
                                    DBusSpawnChildSetupFunc   child_setup,
                                    void                     *user_data,
                                    DBusError                *error)
@@ -1217,7 +1219,7 @@
   
   argv[0] = "/this/does/not/exist/32542sdgafgafdg";
   if (_dbus_spawn_async_with_babysitter (&sitter, argv,
-                                         NULL, NULL,
+                                         NULL, NULL, NULL,
                                          &error))
     {
       _dbus_babysitter_block_for_child_exit (sitter);
@@ -1262,7 +1264,7 @@
   
   argv[0] = TEST_SEGFAULT_BINARY;
   if (_dbus_spawn_async_with_babysitter (&sitter, argv,
-                                         NULL, NULL,
+                                         NULL, NULL, NULL,
                                          &error))
     {
       _dbus_babysitter_block_for_child_exit (sitter);
@@ -1307,7 +1309,7 @@
   
   argv[0] = TEST_EXIT_BINARY;
   if (_dbus_spawn_async_with_babysitter (&sitter, argv,
-                                         NULL, NULL,
+                                         NULL, NULL, NULL,
                                          &error))
     {
       _dbus_babysitter_block_for_child_exit (sitter);
@@ -1352,7 +1354,7 @@
 
   argv[0] = TEST_SLEEP_FOREVER_BINARY;
   if (_dbus_spawn_async_with_babysitter (&sitter, argv,
-                                         NULL, NULL,
+                                         NULL, NULL, NULL,
                                          &error))
     {
       _dbus_babysitter_kill_child (sitter);
Index: dbus/dbus-spawn.h
===================================================================
--- dbus/dbus-spawn.h	(revision 298)
+++ dbus/dbus-spawn.h	(working copy)
@@ -37,6 +37,7 @@
 
 dbus_bool_t _dbus_spawn_async_with_babysitter     (DBusBabysitter           **sitter_p,
                                                    char                     **argv,
+                                                   char                     **env,
                                                    DBusSpawnChildSetupFunc    child_setup,
                                                    void                      *user_data,
                                                    DBusError                 *error);
Index: dbus/dbus-sysdeps-util.c
===================================================================
--- dbus/dbus-sysdeps-util.c	(revision 298)
+++ dbus/dbus-sysdeps-util.c	(working copy)
@@ -81,7 +81,28 @@
   DBusString str;
   double val;
   int pos;
-  
+
+#ifdef DBUS_WIN
+  check_dirname ("foo\\bar", "foo");
+  check_dirname ("foo\\\\bar", "foo");
+  check_dirname ("foo/\\/bar", "foo");
+  check_dirname ("foo\\bar/", "foo");
+  check_dirname ("foo//bar\\", "foo");
+  check_dirname ("foo\\bar/", "foo");
+  check_dirname ("foo/bar\\\\", "foo");
+  check_dirname ("\\foo", "\\");
+  check_dirname ("\\\\foo", "\\");
+  check_dirname ("\\", "\\");
+  check_dirname ("\\\\", "\\");
+  check_dirname ("\\/", "\\");
+  check_dirname ("/\\/", "/");
+  check_dirname ("c:\\foo\\bar", "c:\\foo");
+  check_dirname ("c:\\foo", "c:\\");
+  check_dirname ("c:/foo", "c:/");
+  check_dirname ("c:\\", "c:\\");
+  check_dirname ("c:/", "c:/");
+  check_dirname ("", ".");  
+#else  
   check_dirname ("foo", ".");
   check_dirname ("foo/bar", "foo");
   check_dirname ("foo//bar", "foo");
@@ -100,8 +121,8 @@
   check_dirname ("/", "/");
   check_dirname ("///", "/");
   check_dirname ("", ".");  
+#endif
 
-
   _dbus_string_init_const (&str, "3.5");
   if (!_dbus_string_parse_double (&str,
 				  0, &val, &pos))
@@ -120,6 +141,7 @@
       exit (1);
     }
 
+#ifndef DBUS_WIN_FIXME
   _dbus_string_init_const (&str, "0xff");
   if (!_dbus_string_parse_double (&str,
 				  0, &val, &pos))
@@ -137,12 +159,29 @@
       _dbus_warn ("_dbus_string_parse_double of \"0xff\" returned wrong position %d", pos);
       exit (1);
     }
-  
+#endif
+
+#ifdef DBUS_WIN
+  check_path_absolute ("c:/", TRUE);
+  check_path_absolute ("c:/foo", TRUE);
+  check_path_absolute ("", FALSE);
+  check_path_absolute ("foo", FALSE);
+  check_path_absolute ("foo/bar", FALSE);
+  check_path_absolute ("", FALSE);
+  check_path_absolute ("foo\\bar", FALSE);
+  check_path_absolute ("c:\\", TRUE);
+  check_path_absolute ("c:\\foo", TRUE);
+  check_path_absolute ("c:", TRUE);
+  check_path_absolute ("c:\\foo\\bar", TRUE);
+  check_path_absolute ("\\", TRUE);
   check_path_absolute ("/", TRUE);
+#else  
+  check_path_absolute ("/", TRUE);
   check_path_absolute ("/foo", TRUE);
   check_path_absolute ("", FALSE);
   check_path_absolute ("foo", FALSE);
   check_path_absolute ("foo/bar", FALSE);
+#endif
   
   return TRUE;
 }
Index: dbus/dbus-sysdeps-unix.c
===================================================================
--- dbus/dbus-sysdeps-unix.c	(revision 298)
+++ dbus/dbus-sysdeps-unix.c	(working copy)
@@ -75,8 +75,88 @@
  * @addtogroup DBusInternalsUtils
  * @{
  */
+ 
+/**
+ * Generic IO functions
+ * 
+ */
 
+static dbus_bool_t 
+_dbus_close     (int              fd,
+                 DBusError        *error);
+static int 
+_dbus_read      (int               fd,
+                 DBusString       *buffer,
+                 int               count);
+static int 
+_dbus_write     (int               fd,
+                 const DBusString *buffer,
+                 int               start,
+                 int               len);
+static int 
+_dbus_write_two (int               fd,
+                 const DBusString *buffer1,
+                 int               start1,
+                 int               len1,
+                 const DBusString *buffer2,
+                 int               start2,
+                 int               len2);
+
+
 /**
+ * Socket interface
+ *
+ */
+
+dbus_bool_t
+_dbus_open_socket (int              *fd,
+                   int               domain,
+                   int               type,
+                   int               protocol)
+{
+  *fd = socket (domain, type, protocol);
+  return fd >= 0;
+}
+
+dbus_bool_t 
+_dbus_close_socket (int               fd,
+                    DBusError        *error)
+{
+  return _dbus_close (fd, error);
+}
+
+int
+_dbus_read_socket (int               fd,
+                   DBusString       *buffer,
+                   int               count)
+{
+  return _dbus_read (fd, buffer, count);
+}
+
+int
+_dbus_write_socket (int               fd,
+                    const DBusString *buffer,
+                    int               start,
+                    int               len)
+{
+  return _dbus_write (fd, buffer, start, len);
+}
+
+int
+_dbus_write_socket_two (int               fd,
+                        const DBusString *buffer1,
+                        int               start1,
+                        int               len1,
+                        const DBusString *buffer2,
+                        int               start2,
+                        int               len2)
+{
+	return _dbus_write_two (fd, buffer1, start1, len1,
+	                            buffer2, start2, len2);
+}
+
+
+/**
  * Thin wrapper around the read() system call that appends
  * the data it reads to the DBusString buffer. It appends
  * up to the given count, and returns the same value
@@ -89,7 +169,7 @@
  * @param count the amount of data to read
  * @returns the number of bytes read or -1
  */
-int
+static int
 _dbus_read (int               fd,
             DBusString       *buffer,
             int               count)
@@ -149,7 +229,7 @@
  * @param len the number of bytes to try to write
  * @returns the number of bytes written or -1 on error
  */
-int
+static int
 _dbus_write (int               fd,
              const DBusString *buffer,
              int               start,
@@ -195,7 +275,7 @@
  * @param len2 number of bytes to write in second buffer
  * @returns total bytes written from both buffers, or -1 on error
  */
-int
+static int
 _dbus_write_two (int               fd,
                  const DBusString *buffer1,
                  int               start1,
@@ -306,9 +386,8 @@
   _dbus_verbose ("connecting to unix socket %s abstract=%d\n",
                  path, abstract);
   
-  fd = socket (PF_UNIX, SOCK_STREAM, 0);
   
-  if (fd < 0)
+  if (!_dbus_open_socket (&fd, PF_UNIX, SOCK_STREAM, 0))
     {
       dbus_set_error (error,
                       _dbus_error_from_errno (errno),
@@ -413,9 +492,7 @@
   _dbus_verbose ("listening on unix socket %s abstract=%d\n",
                  path, abstract);
   
-  listen_fd = socket (PF_UNIX, SOCK_STREAM, 0);
-  
-  if (listen_fd < 0)
+  if (!_dbus_open_socket (&listen_fd, PF_UNIX, SOCK_STREAM, 0))
     {
       dbus_set_error (error, _dbus_error_from_errno (errno),
                       "Failed to create socket \"%s\": %s",
@@ -540,10 +617,9 @@
   struct in_addr *haddr;
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
+ 
   
-  fd = socket (AF_INET, SOCK_STREAM, 0);
-  
-  if (fd < 0)
+  if (!_dbus_open_socket (&fd, AF_INET, SOCK_STREAM, 0))
     {
       dbus_set_error (error,
                       _dbus_error_from_errno (errno),
@@ -620,9 +696,8 @@
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
   
-  listen_fd = socket (AF_INET, SOCK_STREAM, 0);
   
-  if (listen_fd < 0)
+  if (!_dbus_open_socket (&listen_fd, AF_INET, SOCK_STREAM, 0))
     {
       dbus_set_error (error, _dbus_error_from_errno (errno),
                       "Failed to create socket \"%s:%d\": %s",
@@ -1958,7 +2033,7 @@
  * @param error error object
  * @returns #FALSE if error set
  */
-dbus_bool_t
+static dbus_bool_t
 _dbus_close (int        fd,
              DBusError *error)
 {
Index: dbus/dbus-transport-unix.c
===================================================================
--- dbus/dbus-transport-unix.c	(revision 298)
+++ dbus/dbus-transport-unix.c	(working copy)
@@ -26,6 +26,9 @@
 #include "dbus-transport-unix.h"
 #include "dbus-transport-protected.h"
 #include "dbus-watch.h"
+#ifdef DBUS_WIN
+#include "dbus-sockets-win.h"
+#endif
 
 
 /**
@@ -250,8 +253,8 @@
 
   _dbus_auth_get_buffer (transport->auth, &buffer);
   
-  bytes_read = _dbus_read (unix_transport->fd,
-                           buffer, unix_transport->max_bytes_read_per_iteration);
+  bytes_read = _dbus_read_socket (unix_transport->fd,
+                                  buffer, unix_transport->max_bytes_read_per_iteration);
 
   _dbus_auth_return_buffer (transport->auth, buffer,
                             bytes_read > 0 ? bytes_read : 0);
@@ -305,9 +308,9 @@
                                      &buffer))
     return FALSE;
   
-  bytes_written = _dbus_write (unix_transport->fd,
-                               buffer,
-                               0, _dbus_string_get_length (buffer));
+  bytes_written = _dbus_write_socket (unix_transport->fd,
+                                      buffer,
+                                      0, _dbus_string_get_length (buffer));
 
   if (bytes_written > 0)
     {
@@ -556,10 +559,10 @@
 #endif
           
           bytes_written =
-            _dbus_write (unix_transport->fd,
-                         &unix_transport->encoded_outgoing,
-                         unix_transport->message_bytes_written,
-                         total_bytes_to_write - unix_transport->message_bytes_written);
+            _dbus_write_socket (unix_transport->fd,
+                                &unix_transport->encoded_outgoing,
+                                unix_transport->message_bytes_written,
+                                total_bytes_to_write - unix_transport->message_bytes_written);
         }
       else
         {
@@ -573,21 +576,21 @@
           if (unix_transport->message_bytes_written < header_len)
             {
               bytes_written =
-                _dbus_write_two (unix_transport->fd,
-                                 header,
-                                 unix_transport->message_bytes_written,
-                                 header_len - unix_transport->message_bytes_written,
-                                 body,
-                                 0, body_len);
+                _dbus_write_socket_two (unix_transport->fd,
+                                        header,
+                                        unix_transport->message_bytes_written,
+                                        header_len - unix_transport->message_bytes_written,
+                                        body,
+                                        0, body_len);
             }
           else
             {
               bytes_written =
-                _dbus_write (unix_transport->fd,
-                             body,
-                             (unix_transport->message_bytes_written - header_len),
-                             body_len -
-                             (unix_transport->message_bytes_written - header_len));
+                _dbus_write_socket (unix_transport->fd,
+                                    body,
+                                    (unix_transport->message_bytes_written - header_len),
+                                    body_len -
+                                    (unix_transport->message_bytes_written - header_len));
             }
         }
 
@@ -682,9 +685,9 @@
       if (_dbus_string_get_length (&unix_transport->encoded_incoming) > 0)
         bytes_read = _dbus_string_get_length (&unix_transport->encoded_incoming);
       else
-        bytes_read = _dbus_read (unix_transport->fd,
-                                 &unix_transport->encoded_incoming,
-                                 unix_transport->max_bytes_read_per_iteration);
+        bytes_read = _dbus_read_socket (unix_transport->fd,
+                                        &unix_transport->encoded_incoming,
+                                        unix_transport->max_bytes_read_per_iteration);
 
       _dbus_assert (_dbus_string_get_length (&unix_transport->encoded_incoming) ==
                     bytes_read);
@@ -719,8 +722,8 @@
       _dbus_message_loader_get_buffer (transport->loader,
                                        &buffer);
       
-      bytes_read = _dbus_read (unix_transport->fd,
-                               buffer, unix_transport->max_bytes_read_per_iteration);
+      bytes_read = _dbus_read_socket (unix_transport->fd,
+                                      buffer, unix_transport->max_bytes_read_per_iteration);
       
       _dbus_message_loader_return_buffer (transport->loader,
                                           buffer,
@@ -882,7 +885,7 @@
   
   free_watches (transport);
   
-  _dbus_close (unix_transport->fd, NULL);
+  _dbus_close_socket (unix_transport->fd, NULL);
   unix_transport->fd = -1;
 }
 
@@ -1241,7 +1244,7 @@
   return transport;
 
  failed_1:
-  _dbus_close (fd, NULL);
+  _dbus_close_socket (fd, NULL);
  failed_0:
   _dbus_string_free (&address);
   return NULL;
@@ -1301,7 +1304,7 @@
   if (transport == NULL)
     {
       dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
-      _dbus_close (fd, NULL);
+      _dbus_close_socket (fd, NULL);
       _dbus_string_free (&address);
       fd = -1;
     }
Index: dbus/dbus-sysdeps.c
===================================================================
--- dbus/dbus-sysdeps.c	(revision 298)
+++ dbus/dbus-sysdeps.c	(working copy)
@@ -105,11 +105,14 @@
        * will get upset about.
        */
       
-      putenv_value = malloc (len + 1);
+      putenv_value = malloc (len + 2);
       if (putenv_value == NULL)
         return FALSE;
 
       strcpy (putenv_value, varname);
+#ifdef DBUS_WIN
+      strcat (putenv_value, "=");
+#endif
       
       return (putenv (putenv_value) == 0);
 #endif
@@ -399,6 +402,10 @@
 ascii_strtod (const char *nptr,
 	      char      **endptr)
 {
+  /* FIXME: The Win32 C library's strtod() doesn't handle hex.
+   * Presumably many Unixes don't either.
+   */
+
   char *fail_pos;
   double val;
   struct lconv *locale_data;
Index: dbus/dbus-internals.c
===================================================================
--- dbus/dbus-internals.c	(revision 298)
+++ dbus/dbus-internals.c	(working copy)
@@ -220,7 +220,7 @@
 #include <pthread.h>
 #endif
 
-static inline void
+static void
 _dbus_verbose_init (void)
 {
   if (!verbose_initted)
Index: dbus/dbus-sysdeps.h
===================================================================
--- dbus/dbus-sysdeps.h	(revision 298)
+++ dbus/dbus-sysdeps.h	(working copy)
@@ -74,21 +74,10 @@
 dbus_bool_t _dbus_setenv (const char *varname,
 			  const char *value);
 
-int _dbus_read      (int               fd,
-                     DBusString       *buffer,
-                     int               count);
-int _dbus_write     (int               fd,
-                     const DBusString *buffer,
-                     int               start,
-                     int               len);
-int _dbus_write_two (int               fd,
-                     const DBusString *buffer1,
-                     int               start1,
-                     int               len1,
-                     const DBusString *buffer2,
-                     int               start2,
-                     int               len2);
 
+ int _dbus_mkdir    (const char *path, 
+	                 mode_t mode); 
+
 typedef unsigned long dbus_pid_t;
 typedef unsigned long dbus_uid_t;
 typedef unsigned long dbus_gid_t;
@@ -101,7 +90,46 @@
 #define DBUS_UID_FORMAT "%lu"
 #define DBUS_GID_FORMAT "%lu"
 
+int _dbus_handle_to_socket (int handle);
+int _dbus_handle_to_fd     (int handle);
+int _dbus_socket_to_handle (int socket);
+int _dbus_fd_to_handle     (int fd);
+
+
+
 /**
+ * Socket interface
+ *
+ *  @todo Use for the file descriptors a struct
+ *           - struct DBusSocket{ int d; }; -
+ *        instead of int to get type-safety which 
+ *        will be checked by the compiler.
+ * 
+ */
+
+dbus_bool_t _dbus_open_socket      (int              *fd,
+                                    int               domain, 
+                                    int               type, 
+                                    int               protocol);
+dbus_bool_t _dbus_close_socket     (int               fd,
+                                    DBusError        *error);
+int         _dbus_read_socket      (int               fd,
+                                    DBusString       *buffer,
+                                    int               count);
+int         _dbus_write_socket     (int               fd,
+                                    const DBusString *buffer,
+                                    int               start,
+                                    int               len);
+int         _dbus_write_socket_two (int               fd,
+                                    const DBusString *buffer1,
+                                    int               start1,
+                                    int               len1,
+                                    const DBusString *buffer2,
+                                    int               start2,
+                                    int               len2);
+
+
+/**
  * Struct representing socket credentials
  */
 typedef struct
@@ -136,8 +164,8 @@
 void        _dbus_credentials_from_current_process (DBusCredentials       *credentials);
 dbus_bool_t _dbus_credentials_match                (const DBusCredentials *expected_credentials,
                                                     const DBusCredentials *provided_credentials);
+dbus_bool_t  write_credentials_byte (int server_fd, DBusError      *error);
 
-
 typedef struct DBusUserInfo  DBusUserInfo;
 typedef struct DBusGroupInfo DBusGroupInfo;
 
@@ -169,6 +197,11 @@
 dbus_bool_t _dbus_user_info_fill_uid (DBusUserInfo     *info,
                                       dbus_uid_t        uid,
                                       DBusError        *error);
+dbus_bool_t fill_user_info     (DBusUserInfo     *info,
+                                      dbus_uid_t        uid,
+                                      const DBusString *username,
+                                      DBusError        *error);
+
 void        _dbus_user_info_free     (DBusUserInfo     *info);
 
 dbus_bool_t _dbus_group_info_fill     (DBusGroupInfo    *info,
@@ -223,7 +256,10 @@
 void _dbus_get_current_time (long *tv_sec,
                              long *tv_usec);
 
-
+/**
+ * File/directory interface
+ */
+dbus_bool_t _dbus_file_exists         (const char       *file);
 dbus_bool_t _dbus_file_get_contents   (DBusString       *str,
                                        const DBusString *filename,
                                        DBusError        *error);
@@ -258,6 +294,13 @@
 dbus_bool_t  _dbus_check_dir_is_private_to_user    (DBusString *dir,
                                                     DBusError *error);
 
+void _dbus_fd_set_close_on_exec (int fd);
+
+const char* _dbus_get_tmpdir      (void);
+
+/**
+ * Random numbers 
+ */
 void        _dbus_generate_pseudorandom_bytes_buffer (char *buffer,
                                                       int   n_bytes);
 void        _dbus_generate_random_bytes_buffer (char       *buffer,
@@ -272,7 +315,6 @@
 
 void _dbus_disable_sigpipe (void);
 
-void _dbus_fd_set_close_on_exec (int fd);
 
 void _dbus_exit (int code) _DBUS_GNUC_NORETURN;
 
@@ -302,8 +344,6 @@
                                     int              *fd2,
                                     dbus_bool_t       blocking,
                                     DBusError        *error);
-dbus_bool_t _dbus_close            (int               fd,
-                                    DBusError        *error);
 
 void        _dbus_print_backtrace  (void);
 
@@ -322,10 +362,8 @@
 void _dbus_set_signal_handler (int               sig,
                                DBusSignalHandler handler);
 
-dbus_bool_t _dbus_file_exists     (const char *file);
 dbus_bool_t _dbus_user_at_console (const char *username,
                                    DBusError  *error);
-const char* _dbus_get_tmpdir      (void);
 
 /* Define DBUS_VA_COPY() to do the right thing for copying va_list variables. 
  * config.h may have already defined DBUS_VA_COPY as va_copy or __va_copy. 
Index: dbus/dbus-string-util.c
===================================================================
--- dbus/dbus-string-util.c	(revision 298)
+++ dbus/dbus-string-util.c	(working copy)
@@ -739,7 +739,27 @@
   test_roundtrips (test_hex_roundtrip);
   
   _dbus_string_free (&str);
-  
+
+  {
+  int found,found_len;
+  _dbus_string_init_const (&str, "012\r\n567\n90");
+
+  if (!_dbus_string_find_eol(&str, 0, &found, &found_len) || found != 3 || found_len != 2)
+    _dbus_assert_not_reached ("Did not find '\\r\\n'");
+  if (found != 3 || found_len != 2)
+    _dbus_assert_not_reached ("invalid return values");
+
+  if (!_dbus_string_find_eol(&str, 5, &found, &found_len))
+    _dbus_assert_not_reached ("Did not find '\\n'");
+  if (found != 8 || found_len != 1)
+    _dbus_assert_not_reached ("invalid return values");
+  	
+  if (_dbus_string_find_eol(&str, 9, NULL, NULL))
+    _dbus_assert_not_reached ("Found not expected '\\n'");
+
+  _dbus_string_free (&str);
+  }
+
   return TRUE;
 }
 
Index: tools/dbus-monitor.c
===================================================================
--- tools/dbus-monitor.c	(revision 298)
+++ tools/dbus-monitor.c	(working copy)
@@ -19,6 +19,7 @@
  *
  */
 
+#include <config.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
Index: tools/dbus-send.c
===================================================================
--- tools/dbus-send.c	(revision 298)
+++ tools/dbus-send.c	(working copy)
@@ -19,6 +19,7 @@
  *
  */
 
+#include <config.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

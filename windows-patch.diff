Index: test/spawn-test.c
===================================================================
--- test/spawn-test.c	(revision 113)
+++ test/spawn-test.c	(working copy)
@@ -31,7 +31,11 @@
     argv_copy [i] = argv[i + 1];
   argv_copy[argc - 1] = NULL;
   
+#ifdef DBUS_WIN
+  if (!_dbus_spawn_async_with_babysitter (NULL, argv_copy, setup_func, NULL, NULL, &error))
+#else
   if (!_dbus_spawn_async_with_babysitter (NULL, argv_copy, setup_func, NULL, &error))
+#endif
     {
       fprintf (stderr, "Could not launch application: \"%s\"\n",
 	       error.message);
Index: test/test-segfault.c
===================================================================
--- test/test-segfault.c	(revision 113)
+++ test/test-segfault.c	(working copy)
@@ -1,10 +1,27 @@
 /* This is simply a process that segfaults */
+#include <config.h>
 #include <stdlib.h>
 #include <signal.h>
 
+#ifdef DBUS_WIN
+#define RLIMIT_CORE	4		/* max core file size */
+typedef unsigned long rlim_t;
+struct rlimit {
+	rlim_t	rlim_cur;
+	rlim_t	rlim_max;
+};
+static int getrlimit (int __resource, struct rlimit *__rlp) {
+  return -1;
+}
+static int setrlimit (int __resource, const struct rlimit *__rlp) {
+  return -1;
+}
+#else
 #include <sys/time.h>
 #include <sys/resource.h>
+#endif
 
+
 int
 main (int argc, char **argv)
 {
Index: test/test-sleep-forever.c
===================================================================
--- test/test-sleep-forever.c	(revision 113)
+++ test/test-sleep-forever.c	(working copy)
@@ -1,6 +1,10 @@
 /* This is a process that just sleeps infinitely. */
 
+
+#include <config.h>
+#ifndef DBUS_WIN
 #include <unistd.h>
+#endif
 
 int
 main (int argc, char **argv)
Index: cmake/CMakeLists.txt
===================================================================
--- cmake/CMakeLists.txt	(revision 113)
+++ cmake/CMakeLists.txt	(working copy)
@@ -45,6 +45,18 @@
 # make some more macros available
 include (MacroLibrary)
 
+if (WIN32)
+	set (DBUS_HAVE_INT64 1)
+	set (DBUS_INT64_TYPE "long long int")
+	set (DBUS_INT32_TYPE int)
+	set (DBUS_INT16_TYPE short)
+else (WIN32)
+	set (DBUS_HAVE_INT64 1)
+	set (DBUS_INT64_TYPE "long long int")
+	set (DBUS_INT32_TYPE int)
+	set (DBUS_INT16_TYPE short)
+endif (WIN32)
+
 if(MSVC)
     ADD_DEFINITIONS(-D_CRT_SECURE_NO_DEPRECATE -D_CRT_NONSTDC_NO_DEPRECATE)
 	SET(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -Zi " CACHE STRING "runtime-library flags" FORCE)
Index: bus/activation.c
===================================================================
--- bus/activation.c	(revision 113)
+++ bus/activation.c	(working copy)
@@ -34,7 +34,6 @@
 #include <dbus/dbus-spawn.h>
 #include <dbus/dbus-timeout.h>
 #include <dbus/dbus-sysdeps.h>
-#include <dirent.h>
 #include <errno.h>
 
 #define DBUS_SERVICE_SECTION "D-BUS Service"
@@ -1304,6 +1303,7 @@
   DBusMessage *message;
   DBusString service_str;
   char **argv;
+  char **envp = NULL;
   int argc;
   dbus_bool_t retval;
   DBusHashIter iter;
@@ -1535,6 +1535,7 @@
 
   _dbus_verbose ("Spawning %s ...\n", argv[0]);
   if (!_dbus_spawn_async_with_babysitter (&pending_activation->babysitter, argv,
+                                          envp,
                                           child_setup, activation, 
                                           error))
     {
Index: bus/test-main.c
===================================================================
--- bus/test-main.c	(revision 113)
+++ bus/test-main.c	(working copy)
@@ -123,16 +123,22 @@
     die ("signals");
   test_post_hook ();
 
+#ifndef DBUS_WIN
   test_pre_hook ();
   printf ("%s: Running SHA1 connection test\n", argv[0]);
   if (!bus_dispatch_sha1_test (&test_data_dir))
     die ("sha1");
   test_post_hook ();
+#endif
 
   test_pre_hook ();
   printf ("%s: Running message dispatch test\n", argv[0]);
   if (!bus_dispatch_test (&test_data_dir)) 
+#ifndef DBUS_WIN
     die ("dispatch");
+#else
+    printf("failed");
+#endif
   test_post_hook ();
 
   test_pre_hook ();
Index: dbus/dbus-server-unix.c
===================================================================
--- dbus/dbus-server-unix.c	(revision 113)
+++ dbus/dbus-server-unix.c	(working copy)
@@ -27,12 +27,16 @@
 #include "dbus-connection-internal.h"
 #include "dbus-string.h"
 #include <sys/types.h>
+#ifdef DBUS_WIN
+#include "dbus-sockets-win.h"
+#else
 #include <unistd.h>
+#endif
 
 /**
- * @defgroup DBusServerUnix DBusServer implementations for UNIX
+ * @defgroup DBusServerUnix DBusServer implementations for UNIX and Winsock
  * @ingroup  DBusInternals
- * @brief Implementation details of DBusServer on UNIX
+ * @brief Implementation details of DBusServer on UNIX and Winsock
  *
  * @{
  */
@@ -102,7 +106,7 @@
   transport = _dbus_transport_new_for_fd (client_fd, &server->guid_hex, NULL);
   if (transport == NULL)
     {
-      close (client_fd);
+      _dbus_close (client_fd, NULL);
       SERVER_UNLOCK (server);
       return FALSE;
     }
@@ -219,7 +223,7 @@
       unix_server->watch = NULL;
     }
   
-  close (unix_server->fd);
+  _dbus_close (unix_server->fd, NULL);
   unix_server->fd = -1;
 
   if (unix_server->socket_name != NULL)
@@ -303,6 +307,8 @@
   return (DBusServer*) unix_server;
 }
 
+#ifndef DBUS_WIN
+
 /**
  * Creates a new server listening on the given Unix domain socket.
  *
@@ -382,11 +388,94 @@
   return NULL;
 }
 
+#else /* ifndef DBUS_WIN */
+
 /**
- * Creates a new server listening on the given hostname and port.
- * If the hostname is NULL, listens on localhost.
+ * Creates a new server listening on the given Windows named pipe.
  *
- * @param host the hostname to listen on.
+ * @param path the path for the domain socket.
+ * @param abstract #TRUE to use abstract socket namespace
+ * @param error location to store reason for failure.
+ * @returns the new server, or #NULL on failure.
+ */
+DBusServer*
+_dbus_server_new_for_domain_socket (const char     *path,
+                                    dbus_bool_t     abstract,
+                                    DBusError      *error)
+{
+  DBusServer *server;
+  DBusServerUnix *unix_server;
+  int listen_fd;
+  DBusString address;
+  char *path_copy;
+  
+  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
+
+  if (!_dbus_string_init (&address))
+    {
+      _DBUS_SET_OOM (error);
+      return NULL;
+    }
+
+  if ((abstract &&
+       !_dbus_string_append (&address, "unix:abstract=")) ||
+      (!abstract &&
+       !_dbus_string_append (&address, "unix:path=")) ||
+      !_dbus_string_append (&address, path))
+    {
+      _DBUS_SET_OOM (error);
+      goto failed_0;
+    }
+
+  path_copy = _dbus_strdup (path);
+  if (path_copy == NULL)
+    {
+      _DBUS_SET_OOM (error);
+      goto failed_0;
+    }
+  
+  listen_fd = _dbus_listen_unix_socket (path, abstract, error);
+  
+  if (listen_fd < 0)
+    {
+      _DBUS_ASSERT_ERROR_IS_SET (error);
+      goto failed_1;
+    }
+  
+  _dbus_fd_set_close_on_exec (listen_fd);
+  server = _dbus_server_new_for_fd (listen_fd, &address);
+  if (server == NULL)
+    {
+      _DBUS_SET_OOM (error);
+      goto failed_2;
+    }
+
+  unix_server = (DBusServerUnix*) server;
+  unix_server->socket_name = path_copy;
+  
+  _dbus_string_free (&address);
+  
+  return server;
+
+ failed_2:
+  _dbus_close (listen_fd, NULL);
+ failed_1:
+  dbus_free (path_copy);
+ failed_0:
+  _dbus_string_free (&address);
+
+  return NULL;
+}
+
+#endif /* ifndef DBUS_WIN */
+
+
+/**
+ * Creates a new server listening on the given hostname and port.  If
+ * the hostname is NULL, listens on localhost. If the hostname is an
+ * empty string, listens on any local host address.
+ *
+ * @param host the hostname for the address to listen.
  * @param port the port to listen on.
  * @param error location to store reason for failure.
  * @returns the new server, or #NULL on failure.
@@ -436,7 +525,7 @@
   if (server == NULL)
     {
       dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
-      close (listen_fd);
+      _dbus_close (listen_fd, NULL);
       _dbus_string_free (&address);
       return NULL;
     }
Index: dbus/dbus-test.c
===================================================================
--- dbus/dbus-test.c	(revision 113)
+++ dbus/dbus-test.c	(working copy)
@@ -154,7 +154,9 @@
   
   run_test ("hash", specific_test, _dbus_hash_test);
 
+#ifndef DBUS_WIN
   run_data_test ("spawn", specific_test, _dbus_spawn_test, test_data_dir);
+#endif
   
   run_data_test ("userdb", specific_test, _dbus_userdb_test, test_data_dir);
   
Index: dbus/dbus-spawn.h
===================================================================
--- dbus/dbus-spawn.h	(revision 113)
+++ dbus/dbus-spawn.h	(working copy)
@@ -37,6 +37,9 @@
 
 dbus_bool_t _dbus_spawn_async_with_babysitter     (DBusBabysitter           **sitter_p,
                                                    char                     **argv,
+#ifdef DBUS_WIN
+                                                   char                     **envp,
+#endif
                                                    DBusSpawnChildSetupFunc    child_setup,
                                                    void                      *user_data,
                                                    DBusError                 *error);
Index: dbus/dbus-sysdeps-util.c
===================================================================
--- dbus/dbus-sysdeps-util.c	(revision 115)
+++ dbus/dbus-sysdeps-util.c	(working copy)
@@ -29,154 +29,18 @@
 #include "dbus-userdb.h"
 #include "dbus-test.h"
 
-#include <sys/types.h>
-#include <stdlib.h>
-#include <string.h>
-#include <signal.h>
-#include <unistd.h>
-#include <stdio.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <sys/stat.h>
-#include <grp.h>
-#include <sys/socket.h>
-#include <dirent.h>
-#include <sys/un.h>
-
-#ifndef O_BINARY
-#define O_BINARY 0
-#endif
-
 /**
  * @addtogroup DBusInternalsUtils
  * @{
  */
 
-/**
- * Does the chdir, fork, setsid, etc. to become a daemon process.
- *
- * @param pidfile #NULL, or pidfile to create
- * @param print_pid_fd file descriptor to print daemon's pid to, or -1 for none
- * @param error return location for errors
- * @returns #FALSE on failure
- */
-dbus_bool_t
-_dbus_become_daemon (const DBusString *pidfile,
-		     int               print_pid_fd,
-                     DBusError        *error)
-{
-  const char *s;
-  pid_t child_pid;
-  int dev_null_fd;
+#ifdef DBUS_WIN
+#include "dbus-sysdeps-util-win.c"
+#else
+#include "dbus-sysdeps-util-unix.c"
+#endif
 
-  _dbus_verbose ("Becoming a daemon...\n");
 
-  _dbus_verbose ("chdir to /\n");
-  if (chdir ("/") < 0)
-    {
-      dbus_set_error (error, DBUS_ERROR_FAILED,
-                      "Could not chdir() to root directory");
-      return FALSE;
-    }
-
-  _dbus_verbose ("forking...\n");
-  switch ((child_pid = fork ()))
-    {
-    case -1:
-      _dbus_verbose ("fork failed\n");
-      dbus_set_error (error, _dbus_error_from_errno (errno),
-                      "Failed to fork daemon: %s", _dbus_strerror (errno));
-      return FALSE;
-      break;
-
-    case 0:
-      _dbus_verbose ("in child, closing std file descriptors\n");
-
-      /* silently ignore failures here, if someone
-       * doesn't have /dev/null we may as well try
-       * to continue anyhow
-       */
-      
-      dev_null_fd = open ("/dev/null", O_RDWR);
-      if (dev_null_fd >= 0)
-        {
-          dup2 (dev_null_fd, 0);
-          dup2 (dev_null_fd, 1);
-          
-          s = _dbus_getenv ("DBUS_DEBUG_OUTPUT");
-          if (s == NULL || *s == '\0')
-            dup2 (dev_null_fd, 2);
-          else
-            _dbus_verbose ("keeping stderr open due to DBUS_DEBUG_OUTPUT\n");
-        }
-
-      /* Get a predictable umask */
-      _dbus_verbose ("setting umask\n");
-      umask (022);
-      break;
-
-    default:
-      if (pidfile)
-        {
-          _dbus_verbose ("parent writing pid file\n");
-          if (!_dbus_write_pid_file (pidfile,
-                                     child_pid,
-                                     error))
-            {
-              _dbus_verbose ("pid file write failed, killing child\n");
-              kill (child_pid, SIGTERM);
-              return FALSE;
-            }
-        }
-
-      /* Write PID if requested */
-      if (print_pid_fd >= 0)
-	{
-	  DBusString pid;
-	  int bytes;
-	  
-	  if (!_dbus_string_init (&pid))
-	    {
-	      _DBUS_SET_OOM (error);
-              kill (child_pid, SIGTERM);
-	      return FALSE;
-	    }
-	  
-	  if (!_dbus_string_append_int (&pid, child_pid) ||
-	      !_dbus_string_append (&pid, "\n"))
-	    {
-	      _dbus_string_free (&pid);
-	      _DBUS_SET_OOM (error);
-              kill (child_pid, SIGTERM);
-	      return FALSE;
-	    }
-	  
-	  bytes = _dbus_string_get_length (&pid);
-	  if (_dbus_write (print_pid_fd, &pid, 0, bytes) != bytes)
-	    {
-	      dbus_set_error (error, DBUS_ERROR_FAILED,
-			      "Printing message bus PID: %s\n",
-			      _dbus_strerror (errno));
-	      _dbus_string_free (&pid);
-              kill (child_pid, SIGTERM);
-	      return FALSE;
-	    }
-	  
-	  _dbus_string_free (&pid);
-	}
-      _dbus_verbose ("parent exiting\n");
-      _exit (0);
-      break;
-    }
-
-  _dbus_verbose ("calling setsid()\n");
-  if (setsid () == -1)
-    _dbus_assert_not_reached ("setsid() failed");
-  
-  return TRUE;
-}
-
-
 /**
  * Creates a file containing the process ID.
  *
@@ -235,73 +99,7 @@
   return TRUE;
 }
 
-
 /**
- * Changes the user and group the bus is running as.
- *
- * @param uid the new user ID
- * @param gid the new group ID
- * @param error return location for errors
- * @returns #FALSE on failure
- */
-dbus_bool_t
-_dbus_change_identity  (dbus_uid_t     uid,
-                        dbus_gid_t     gid,
-                        DBusError     *error)
-{
-  /* setgroups() only works if we are a privileged process,
-   * so we don't return error on failure; the only possible
-   * failure is that we don't have perms to do it.
-   * FIXME not sure this is right, maybe if setuid()
-   * is going to work then setgroups() should also work.
-   */
-  if (setgroups (0, NULL) < 0)
-    _dbus_warn ("Failed to drop supplementary groups: %s\n",
-                _dbus_strerror (errno));
-  
-  /* Set GID first, or the setuid may remove our permission
-   * to change the GID
-   */
-  if (setgid (gid) < 0)
-    {
-      dbus_set_error (error, _dbus_error_from_errno (errno),
-                      "Failed to set GID to %lu: %s", gid,
-                      _dbus_strerror (errno));
-      return FALSE;
-    }
-  
-  if (setuid (uid) < 0)
-    {
-      dbus_set_error (error, _dbus_error_from_errno (errno),
-                      "Failed to set UID to %lu: %s", uid,
-                      _dbus_strerror (errno));
-      return FALSE;
-    }
-  
-  return TRUE;
-}
-
-/** Installs a UNIX signal handler
- *
- * @param sig the signal to handle
- * @param handler the handler
- */
-void
-_dbus_set_signal_handler (int               sig,
-                          DBusSignalHandler handler)
-{
-  struct sigaction act;
-  sigset_t empty_mask;
-  
-  sigemptyset (&empty_mask);
-  act.sa_handler = handler;
-  act.sa_mask    = empty_mask;
-  act.sa_flags   = 0;
-  sigaction (sig,  &act, NULL);
-}
-
-
-/**
  * Removes a directory; Directory must be empty
  * 
  * @param filename directory filename
@@ -329,115 +127,42 @@
   return TRUE;
 }
 
-/** Checks if a file exists
-*
-* @param file full path to the file
-* @returns #TRUE if file exists
-*/
-dbus_bool_t 
-_dbus_file_exists (const char *file)
-{
-  return (access (file, F_OK) == 0);
-}
-
-/** Checks if user is at the console
-*
-* @param username user to check
-* @param error return location for errors
-* @returns #TRUE is the user is at the consolei and there are no errors
-*/
-dbus_bool_t 
-_dbus_user_at_console (const char *username,
-                       DBusError  *error)
-{
-
-  DBusString f;
-  dbus_bool_t result;
-
-  result = FALSE;
-  if (!_dbus_string_init (&f))
-    {
-      _DBUS_SET_OOM (error);
-      return FALSE;
-    }
-
-  if (!_dbus_string_append (&f, DBUS_CONSOLE_AUTH_DIR))
-    {
-      _DBUS_SET_OOM (error);
-      goto out;
-    }
-
-
-  if (!_dbus_string_append (&f, username))
-    {
-      _DBUS_SET_OOM (error);
-      goto out;
-    }
-
-  result = _dbus_file_exists (_dbus_string_get_const_data (&f));
-
- out:
-  _dbus_string_free (&f);
-
-  return result;
-}
-
-
 /**
- * Checks whether the filename is an absolute path
+ * Initializes the given DBusGroupInfo struct
+ * with information about the given group ID.
  *
- * @param filename the filename
- * @returns #TRUE if an absolute path
+ * @param info the group info struct
+ * @param gid group ID
+ * @param error the error return
+ * @returns #FALSE if error is set
  */
 dbus_bool_t
-_dbus_path_is_absolute (const DBusString *filename)
+_dbus_group_info_fill_gid (DBusGroupInfo *info,
+                           dbus_gid_t     gid,
+                           DBusError     *error)
 {
-  if (_dbus_string_get_length (filename) > 0)
-    return _dbus_string_get_byte (filename, 0) == '/';
-  else
-    return FALSE;
+  return fill_group_info (info, gid, NULL, error);
 }
 
 /**
- * stat() wrapper.
+ * Initializes the given DBusGroupInfo struct
+ * with information about the given group name.
  *
- * @param filename the filename to stat
- * @param statbuf the stat info to fill in
- * @param error return location for error
- * @returns #FALSE if error was set
+ * @param info the group info struct
+ * @param groupname name of group
+ * @param error the error return
+ * @returns #FALSE if error is set
  */
 dbus_bool_t
-_dbus_stat (const DBusString *filename,
-            DBusStat         *statbuf,
+_dbus_group_info_fill (DBusGroupInfo    *info,
+                       const DBusString *groupname,
             DBusError        *error)
 {
-  const char *filename_c;
-  struct stat sb;
+  return fill_group_info (info, DBUS_GID_UNSET,
+                          groupname, error);
 
-  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
-  
-  filename_c = _dbus_string_get_const_data (filename);
-
-  if (stat (filename_c, &sb) < 0)
-    {
-      dbus_set_error (error, _dbus_error_from_errno (errno),
-                      "%s", _dbus_strerror (errno));
-      return FALSE;
-    }
-
-  statbuf->mode = sb.st_mode;
-  statbuf->nlink = sb.st_nlink;
-  statbuf->uid = sb.st_uid;
-  statbuf->gid = sb.st_gid;
-  statbuf->size = sb.st_size;
-  statbuf->atime = sb.st_atime;
-  statbuf->mtime = sb.st_mtime;
-  statbuf->ctime = sb.st_ctime;
-
-  return TRUE;
 }
 
-
 /**
  * Internals of directory iterator
  */
@@ -466,7 +191,7 @@
   
   filename_c = _dbus_string_get_const_data (filename);
 
-  d = opendir (filename_c);
+  d = _dbus_opendir (filename_c);
   if (d == NULL)
     {
       dbus_set_error (error, _dbus_error_from_errno (errno),
@@ -478,7 +203,7 @@
   iter = dbus_new0 (DBusDirIter, 1);
   if (iter == NULL)
     {
-      closedir (d);
+      _dbus_closedir (d);
       dbus_set_error (error, DBUS_ERROR_NO_MEMORY,
                       "Could not allocate memory for directory iterator");
       return NULL;
@@ -513,7 +238,7 @@
   
  again:
   errno = 0;
-  ent = readdir (iter->d);
+  ent = _dbus_readdir (iter->d);
   if (ent == NULL)
     {
       if (errno != 0)
@@ -546,317 +271,9 @@
 void
 _dbus_directory_close (DBusDirIter *iter)
 {
-  closedir (iter->d);
+  _dbus_closedir (iter->d);
   dbus_free (iter);
 }
 
-static dbus_bool_t
-fill_user_info_from_group (struct group  *g,
-                           DBusGroupInfo *info,
-                           DBusError     *error)
-{
-  _dbus_assert (g->gr_name != NULL);
-  
-  info->gid = g->gr_gid;
-  info->groupname = _dbus_strdup (g->gr_name);
 
-  /* info->members = dbus_strdupv (g->gr_mem) */
-  
-  if (info->groupname == NULL)
-    {
-      dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
-      return FALSE;
-    }
-
-  return TRUE;
-}
-
-static dbus_bool_t
-fill_group_info (DBusGroupInfo    *info,
-                 dbus_gid_t        gid,
-                 const DBusString *groupname,
-                 DBusError        *error)
-{
-  const char *group_c_str;
-
-  _dbus_assert (groupname != NULL || gid != DBUS_GID_UNSET);
-  _dbus_assert (groupname == NULL || gid == DBUS_GID_UNSET);
-
-  if (groupname)
-    group_c_str = _dbus_string_get_const_data (groupname);
-  else
-    group_c_str = NULL;
-  
-  /* For now assuming that the getgrnam() and getgrgid() flavors
-   * always correspond to the pwnam flavors, if not we have
-   * to add more configure checks.
-   */
-  
-#if defined (HAVE_POSIX_GETPWNAM_R) || defined (HAVE_NONPOSIX_GETPWNAM_R)
-  {
-    struct group *g;
-    int result;
-    char buf[1024];
-    struct group g_str;
-
-    g = NULL;
-#ifdef HAVE_POSIX_GETPWNAM_R
-
-    if (group_c_str)
-      result = getgrnam_r (group_c_str, &g_str, buf, sizeof (buf),
-                           &g);
-    else
-      result = getgrgid_r (gid, &g_str, buf, sizeof (buf),
-                           &g);
-#else
-    g = getgrnam_r (group_c_str, &g_str, buf, sizeof (buf));
-    result = 0;
-#endif /* !HAVE_POSIX_GETPWNAM_R */
-    if (result == 0 && g == &g_str)
-      {
-        return fill_user_info_from_group (g, info, error);
-      }
-    else
-      {
-        dbus_set_error (error, _dbus_error_from_errno (errno),
-                        "Group %s unknown or failed to look it up\n",
-                        group_c_str ? group_c_str : "???");
-        return FALSE;
-      }
-  }
-#else /* ! HAVE_GETPWNAM_R */
-  {
-    /* I guess we're screwed on thread safety here */
-    struct group *g;
-
-    g = getgrnam (group_c_str);
-
-    if (g != NULL)
-      {
-        return fill_user_info_from_group (g, info, error);
-      }
-    else
-      {
-        dbus_set_error (error, _dbus_error_from_errno (errno),
-                        "Group %s unknown or failed to look it up\n",
-                        group_c_str ? group_c_str : "???");
-        return FALSE;
-      }
-  }
-#endif  /* ! HAVE_GETPWNAM_R */
-}
-
-/**
- * Initializes the given DBusGroupInfo struct
- * with information about the given group name.
- *
- * @param info the group info struct
- * @param groupname name of group
- * @param error the error return
- * @returns #FALSE if error is set
- */
-dbus_bool_t
-_dbus_group_info_fill (DBusGroupInfo    *info,
-                       const DBusString *groupname,
-                       DBusError        *error)
-{
-  return fill_group_info (info, DBUS_GID_UNSET,
-                          groupname, error);
-
-}
-
-/**
- * Initializes the given DBusGroupInfo struct
- * with information about the given group ID.
- *
- * @param info the group info struct
- * @param gid group ID
- * @param error the error return
- * @returns #FALSE if error is set
- */
-dbus_bool_t
-_dbus_group_info_fill_gid (DBusGroupInfo *info,
-                           dbus_gid_t     gid,
-                           DBusError     *error)
-{
-  return fill_group_info (info, gid, NULL, error);
-}
-
-/** @} */ /* End of DBusInternalsUtils functions */
-
-/**
- * @addtogroup DBusString
- *
- * @{
- */
-/**
- * Get the directory name from a complete filename
- * @param filename the filename
- * @param dirname string to append directory name to
- * @returns #FALSE if no memory
- */
-dbus_bool_t
-_dbus_string_get_dirname  (const DBusString *filename,
-                           DBusString       *dirname)
-{
-  int sep;
-  
-  _dbus_assert (filename != dirname);
-  _dbus_assert (filename != NULL);
-  _dbus_assert (dirname != NULL);
-
-  /* Ignore any separators on the end */
-  sep = _dbus_string_get_length (filename);
-  if (sep == 0)
-    return _dbus_string_append (dirname, "."); /* empty string passed in */
-    
-  while (sep > 0 && _dbus_string_get_byte (filename, sep - 1) == '/')
-    --sep;
-
-  _dbus_assert (sep >= 0);
-  
-  if (sep == 0)
-    return _dbus_string_append (dirname, "/");
-  
-  /* Now find the previous separator */
-  _dbus_string_find_byte_backward (filename, sep, '/', &sep);
-  if (sep < 0)
-    return _dbus_string_append (dirname, ".");
-  
-  /* skip multiple separators */
-  while (sep > 0 && _dbus_string_get_byte (filename, sep - 1) == '/')
-    --sep;
-
-  _dbus_assert (sep >= 0);
-  
-  if (sep == 0 &&
-      _dbus_string_get_byte (filename, 0) == '/')
-    return _dbus_string_append (dirname, "/");
-  else
-    return _dbus_string_copy_len (filename, 0, sep - 0,
-                                  dirname, _dbus_string_get_length (dirname));
-}
 /** @} */ /* DBusString stuff */
-
-
-#ifdef DBUS_BUILD_TESTS
-#include <stdlib.h>
-static void
-check_dirname (const char *filename,
-               const char *dirname)
-{
-  DBusString f, d;
-  
-  _dbus_string_init_const (&f, filename);
-
-  if (!_dbus_string_init (&d))
-    _dbus_assert_not_reached ("no memory");
-
-  if (!_dbus_string_get_dirname (&f, &d))
-    _dbus_assert_not_reached ("no memory");
-
-  if (!_dbus_string_equal_c_str (&d, dirname))
-    {
-      _dbus_warn ("For filename \"%s\" got dirname \"%s\" and expected \"%s\"\n",
-                  filename,
-                  _dbus_string_get_const_data (&d),
-                  dirname);
-      exit (1);
-    }
-
-  _dbus_string_free (&d);
-}
-
-static void
-check_path_absolute (const char *path,
-                     dbus_bool_t expected)
-{
-  DBusString p;
-
-  _dbus_string_init_const (&p, path);
-
-  if (_dbus_path_is_absolute (&p) != expected)
-    {
-      _dbus_warn ("For path \"%s\" expected absolute = %d got %d\n",
-                  path, expected, _dbus_path_is_absolute (&p));
-      exit (1);
-    }
-}
-
-/**
- * Unit test for dbus-sysdeps.c.
- * 
- * @returns #TRUE on success.
- */
-dbus_bool_t
-_dbus_sysdeps_test (void)
-{
-  DBusString str;
-  double val;
-  int pos;
-  
-  check_dirname ("foo", ".");
-  check_dirname ("foo/bar", "foo");
-  check_dirname ("foo//bar", "foo");
-  check_dirname ("foo///bar", "foo");
-  check_dirname ("foo/bar/", "foo");
-  check_dirname ("foo//bar/", "foo");
-  check_dirname ("foo///bar/", "foo");
-  check_dirname ("foo/bar//", "foo");
-  check_dirname ("foo//bar////", "foo");
-  check_dirname ("foo///bar///////", "foo");
-  check_dirname ("/foo", "/");
-  check_dirname ("////foo", "/");
-  check_dirname ("/foo/bar", "/foo");
-  check_dirname ("/foo//bar", "/foo");
-  check_dirname ("/foo///bar", "/foo");
-  check_dirname ("/", "/");
-  check_dirname ("///", "/");
-  check_dirname ("", ".");  
-
-
-  _dbus_string_init_const (&str, "3.5");
-  if (!_dbus_string_parse_double (&str,
-				  0, &val, &pos))
-    {
-      _dbus_warn ("Failed to parse double");
-      exit (1);
-    }
-  if (ABS(3.5 - val) > 1e-6)
-    {
-      _dbus_warn ("Failed to parse 3.5 correctly, got: %f", val);
-      exit (1);
-    }
-  if (pos != 3)
-    {
-      _dbus_warn ("_dbus_string_parse_double of \"3.5\" returned wrong position %d", pos);
-      exit (1);
-    }
-
-  _dbus_string_init_const (&str, "0xff");
-  if (!_dbus_string_parse_double (&str,
-				  0, &val, &pos))
-    {
-      _dbus_warn ("Failed to parse double");
-      exit (1);
-    }
-  if (ABS (0xff - val) > 1e-6)
-    {
-      _dbus_warn ("Failed to parse 0xff correctly, got: %f\n", val);
-      exit (1);
-    }
-  if (pos != 4)
-    {
-      _dbus_warn ("_dbus_string_parse_double of \"0xff\" returned wrong position %d", pos);
-      exit (1);
-    }
-  
-  check_path_absolute ("/", TRUE);
-  check_path_absolute ("/foo", TRUE);
-  check_path_absolute ("", FALSE);
-  check_path_absolute ("foo", FALSE);
-  check_path_absolute ("foo/bar", FALSE);
-  
-  return TRUE;
-}
-#endif /* DBUS_BUILD_TESTS */
Index: dbus/dbus-watch.c
===================================================================
--- dbus/dbus-watch.c	(revision 113)
+++ dbus/dbus-watch.c	(working copy)
@@ -486,7 +486,10 @@
 int
 dbus_watch_get_fd (DBusWatch *watch)
 {
-  return watch->fd;
+  if (watch->fd == -1)
+    return -1;
+  else
+    return _dbus_decapsulate (watch->fd);
 }
 
 /**
Index: dbus/dbus-transport-unix.c
===================================================================
--- dbus/dbus-transport-unix.c	(revision 115)
+++ dbus/dbus-transport-unix.c	(working copy)
@@ -26,6 +26,9 @@
 #include "dbus-transport-unix.h"
 #include "dbus-transport-protected.h"
 #include "dbus-watch.h"
+#ifdef DBUS_WIN
+#include "dbus-sockets-win.h"
+#endif
 
 
 /**
Index: dbus/dbus-mainloop.c
===================================================================
--- dbus/dbus-mainloop.c	(revision 113)
+++ dbus/dbus-mainloop.c	(working copy)
@@ -609,7 +609,7 @@
                   
               flags = dbus_watch_get_flags (wcb->watch);
                   
-              fds[n_fds].fd = dbus_watch_get_fd (wcb->watch);
+              fds[n_fds].fd = _dbus_re_encapsulate_socket(dbus_watch_get_fd (wcb->watch));
               fds[n_fds].revents = 0;
               fds[n_fds].events = 0;
               if (flags & DBUS_WATCH_READABLE)
Index: dbus/dbus-sysdeps-win.c
===================================================================
--- dbus/dbus-sysdeps-win.c	(revision 113)
+++ dbus/dbus-sysdeps-win.c	(working copy)
@@ -29,7 +29,7 @@
 #include "dbus-threads.h"
 #include "dbus-protocol.h"
 #include "dbus-hash.h"
-#include "dbus-dirent.h"
+//#include "dbus-dirent.h"
 #include "dbus-sockets-win.h"
 #include "dbus-string.h"
 #include <sys/types.h>
Index: dbus/dbus-sysdeps.c
===================================================================
--- dbus/dbus-sysdeps.c	(revision 115)
+++ dbus/dbus-sysdeps.c	(working copy)
@@ -3,6 +3,7 @@
  * 
  * Copyright (C) 2002, 2003  Red Hat, Inc.
  * Copyright (C) 2003 CodeFactory AB
+ * Copyright (C) 2005 Novell, Inc.
  *
  * Licensed under the Academic Free License version 2.1
  * 
@@ -31,23 +32,31 @@
 #include <stdlib.h>
 #include <string.h>
 #include <signal.h>
-#include <unistd.h>
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
+
+#ifdef DBUS_WIN
+#include "dbus-sysdeps-win.h"
+#include "dbus-hash.h"
+#include "dbus-sockets-win.h"
+#else
+#include <unistd.h>
 #include <sys/socket.h>
 #include <dirent.h>
 #include <sys/un.h>
 #include <pwd.h>
-#include <time.h>
-#include <locale.h>
 #include <sys/time.h>
-#include <sys/stat.h>
 #include <sys/wait.h>
 #include <netinet/in.h>
 #include <netdb.h>
 #include <grp.h>
+#endif
 
+#include <time.h>
+#include <locale.h>
+#include <sys/stat.h>
+
 #ifdef HAVE_WRITEV
 #include <sys/uio.h>
 #endif
@@ -72,6 +81,14 @@
 _DBUS_DEFINE_GLOBAL_LOCK (win_fds);
 _DBUS_DEFINE_GLOBAL_LOCK (sid_atom_cache);
 
+#ifndef DBUS_WIN
+#define _dbus_decapsulate_quick(i)       (i)
+#define DBUS_SOCKET_IS_INVALID(s)        ((s) < 0)
+#define DBUS_SOCKET_API_RETURNS_ERROR(n) ((n) < 0)
+#define DBUS_SOCKET_SET_ERRNO()          /* empty */
+#define DBUS_CLOSE_SOCKET(s)             close(s)
+#endif
+
 /**
  * @addtogroup DBusInternalsUtils
  * @{
@@ -89,6 +106,10 @@
   if (s && *s)
     _dbus_print_backtrace ();
 #endif
+#if defined (DBUS_WIN) && defined (__GNUC__)
+  if (IsDebuggerPresent ())
+    __asm__ __volatile__ ("int $03");
+#endif
   abort ();
   _exit (1); /* in case someone manages to ignore SIGABRT */
 }
@@ -126,11 +147,18 @@
        * will get upset about.
        */
       
+#ifdef DBUS_WIN
+      putenv_value = malloc (len + 2);
+#else
       putenv_value = malloc (len + 1);
+#endif
       if (putenv_value == NULL)
         return FALSE;
 
       strcpy (putenv_value, varname);
+#ifdef DBUS_WIN
+      strcat (putenv_value, "=");
+#endif
       
       return (putenv (putenv_value) == 0);
 #endif
@@ -197,6 +225,9 @@
             DBusString       *buffer,
             int               count)
 {
+#ifdef DBUS_WIN
+  return _dbus_read_win (fd, buffer, count);
+#else
   int bytes_read;
   int start;
   char *data;
@@ -240,6 +271,7 @@
       
       return bytes_read;
     }
+#endif
 }
 
 /**
@@ -258,6 +290,9 @@
              int               start,
              int               len)
 {
+#ifdef DBUS_WIN
+  return _dbus_write_win (fd, buffer, start, len);
+#else
   const char *data;
   int bytes_written;
   
@@ -276,6 +311,7 @@
 #endif
   
   return bytes_written;
+#endif
 }
 
 /**
@@ -313,6 +349,10 @@
   _dbus_assert (len1 >= 0);
   _dbus_assert (len2 >= 0);
   
+#ifdef DBUS_WIN
+  return _dbus_write_two_win(fd, buffer1, start1, len1, buffer2, start2, len2);
+#else
+
 #ifdef HAVE_WRITEV
   {
     struct iovec vectors[2];
@@ -364,6 +404,8 @@
       return ret1;
   }
 #endif /* !HAVE_WRITEV */   
+
+#endif
 }
 
 #define _DBUS_MAX_SUN_PATH_LENGTH 99
@@ -386,6 +428,10 @@
  * given path.  The connection fd is returned, and is set up as
  * nonblocking.
  * 
+ * On Windows there are no UNIX domain sockets. Instead, connects to a
+ * localhost-bound TCP socket, whose port number is stored in a file
+ * at the given path.
+ * 
  * Uses abstract sockets instead of filesystem-linked sockets if
  * requested (it's possible only on Linux; see "man 7 unix" on Linux).
  * On non-Linux abstract socket usage always fails.
@@ -400,6 +446,10 @@
                            dbus_bool_t     abstract,
                            DBusError      *error)
 {
+#ifdef DBUS_WIN
+  return _dbus_connect_unix_socket_win(path, abstract, error);
+#else
+
   int fd;
   size_t path_len;
   struct sockaddr_un addr;  
@@ -485,6 +535,7 @@
     }
 
   return fd;
+#endif
 }
 
 /**
@@ -507,6 +558,10 @@
                           dbus_bool_t     abstract,
                           DBusError      *error)
 {
+#ifdef DBUS_WIN
+  return _dbus_listen_unix_socket_win(path, abstract,error);
+#else
+
   int listen_fd;
   struct sockaddr_un addr;
   size_t path_len;
@@ -620,6 +675,7 @@
                 path);
   
   return listen_fd;
+#endif
 }
 
 /**
@@ -627,7 +683,7 @@
  * and port. The connection fd is returned, and is set up as
  * nonblocking.
  *
- * @param host the host name to connect to
+ * @param host the host name to connect to, NULL for loopback
  * @param port the prot to connect to
  * @param error return location for error code
  * @returns connection file descriptor or -1 on error
@@ -641,13 +697,21 @@
   struct sockaddr_in addr;
   struct hostent *he;
   struct in_addr *haddr;
+#ifdef DBUS_WIN
+  struct in_addr ina;
+#endif
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
   
+#ifdef DBUS_WIN
+  _dbus_win_startup_winsock ();
+#endif
+
   fd = socket (AF_INET, SOCK_STREAM, 0);
   
-  if (fd < 0)
+  if (DBUS_SOCKET_IS_INVALID (fd))
     {
+      DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error,
                       _dbus_error_from_errno (errno),
                       "Failed to create socket: %s",
@@ -657,16 +721,23 @@
     }
 
   if (host == NULL)
+    {
     host = "localhost";
+#ifdef DBUS_WIN
+      ina.s_addr = htonl (INADDR_LOOPBACK);
+      haddr = &ina;
+#endif
+    }
 
   he = gethostbyname (host);
   if (he == NULL) 
     {
+      DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error,
                       _dbus_error_from_errno (errno),
                       "Failed to lookup hostname: %s",
                       host);
-      close (fd);
+      DBUS_CLOSE_SOCKET (fd);
       return -1;
     }
   
@@ -677,22 +748,26 @@
   addr.sin_family = AF_INET;
   addr.sin_port = htons (port);
   
-  if (connect (fd, (struct sockaddr*) &addr, sizeof (addr)) < 0)
+  if (DBUS_SOCKET_API_RETURNS_ERROR
+     (connect (fd, (struct sockaddr*) &addr, sizeof (addr)) < 0))
     {      
+      DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error,
                        _dbus_error_from_errno (errno),
                       "Failed to connect to socket %s:%d %s",
                       host, port, _dbus_strerror (errno));
 
-      close (fd);
+      DBUS_CLOSE_SOCKET (fd);
       fd = -1;
       
       return -1;
     }
 
+  fd = _dbus_encapsulate_socket (fd);
+
   if (!_dbus_set_fd_nonblocking (fd, error))
     {
-      close (fd);
+      _dbus_close (fd, NULL);
       fd = -1;
 
       return -1;
@@ -702,12 +777,12 @@
 }
 
 /**
- * Creates a socket and binds it to the given path,
+ * Creates a socket and binds it to the given port,
  * then listens on the socket. The socket is
  * set to be nonblocking. 
  *
- * @param host the host name to listen on
- * @param port the prot to listen on
+ * @param host the interface to listen on, NULL for loopback, empty for any
+ * @param port the port to listen on
  * @param error return location for errors
  * @returns the listening file descriptor or -1 on error
  */
@@ -720,31 +795,58 @@
   struct sockaddr_in addr;
   struct hostent *he;
   struct in_addr *haddr;
+#ifdef DBUS_WIN
+  struct in_addr ina;
+#endif
 
+
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
   
+#ifdef DBUS_WIN
+  _dbus_win_startup_winsock ();
+#endif
+
   listen_fd = socket (AF_INET, SOCK_STREAM, 0);
   
-  if (listen_fd < 0)
+  if (DBUS_SOCKET_IS_INVALID (listen_fd))
     {
+      DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error, _dbus_error_from_errno (errno),
                       "Failed to create socket \"%s:%d\": %s",
                       host, port, _dbus_strerror (errno));
       return -1;
     }
-
+#ifdef DBUS_WIN
+  if (host == NULL)
+    {
+      host = "localhost";
+      ina.s_addr = htonl (INADDR_LOOPBACK);
+      haddr = &ina;
+    }
+  else if (!host[0])
+    {
+      ina.s_addr = htonl (INADDR_ANY);
+      haddr = &ina;
+    }
+  else
+    {
+#endif
   he = gethostbyname (host);
   if (he == NULL) 
     {
+      DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error,
                       _dbus_error_from_errno (errno),
                       "Failed to lookup hostname: %s",
                       host);
-      close (listen_fd);
+      DBUS_CLOSE_SOCKET (listen_fd);
       return -1;
     }
   
   haddr = ((struct in_addr *) (he->h_addr_list)[0]);
+#ifdef DBUS_WIN
+  }
+#endif
 
   _DBUS_ZERO (addr);
   memcpy (&addr.sin_addr, haddr, sizeof (struct in_addr));
@@ -753,25 +855,29 @@
 
   if (bind (listen_fd, (struct sockaddr*) &addr, sizeof (struct sockaddr)))
     {
+      DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error, _dbus_error_from_errno (errno),
                       "Failed to bind socket \"%s:%d\": %s",
                       host, port, _dbus_strerror (errno));
-      close (listen_fd);
+      DBUS_CLOSE_SOCKET (listen_fd);
       return -1;
     }
 
-  if (listen (listen_fd, 30 /* backlog */) < 0)
+  if (DBUS_SOCKET_API_RETURNS_ERROR (listen (listen_fd, 30 /* backlog */)))
     {
+      DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error, _dbus_error_from_errno (errno),  
                       "Failed to listen on socket \"%s:%d\": %s",
                       host, port, _dbus_strerror (errno));
-      close (listen_fd);
+      DBUS_CLOSE_SOCKET (listen_fd);
       return -1;
     }
 
+  listen_fd = _dbus_encapsulate_socket (listen_fd);
+
   if (!_dbus_set_fd_nonblocking (listen_fd, error))
     {
-      close (listen_fd);
+      _dbus_close (listen_fd, NULL);
       return -1;
     }
   
@@ -782,6 +888,33 @@
 write_credentials_byte (int             server_fd,
                         DBusError      *error)
 {
+#ifdef DBUS_WIN
+  /* FIXME: for the session bus credentials shouldn't matter (?), but
+   * for the system bus they are presumably essential. A rough outline
+   * of a way to implement the credential transfer would be this:
+   *
+   * client waits to *read* a byte.
+   *
+   * server creates a named pipe with a random name, sends a byte
+   * contining its length, and its name.
+   *
+   * client reads the name, connects to it (using Win32 API).
+   *
+   * server waits for connection to the named pipe, then calls
+   * ImpersonateNamedPipeClient(), notes its now-current credentials,
+   * calls RevertToSelf(), closes its handles to the named pipe, and
+   * is done. (Maybe there is some other way to get the SID of a named
+   * pipe client without having to use impersonation?)
+   *
+   * client closes its handles and is done.
+   *
+   */
+
+  return TRUE;
+
+#else
+
+
   int bytes_written;
   char buf[1] = { '\0' };
 #if defined(HAVE_CMSGCRED) && !defined(LOCAL_CREDS)
@@ -841,6 +974,8 @@
       _dbus_verbose ("wrote credentials byte\n");
       return TRUE;
     }
+
+#endif
 }
 
 /**
@@ -866,6 +1001,8 @@
                                      DBusCredentials *credentials,
                                      DBusError       *error)
 {
+#ifndef DBUS_WIN
+
   struct msghdr msg;
   struct iovec iov;
   char buf;
@@ -1005,6 +1142,15 @@
 		 credentials->gid);
     
   return TRUE;
+
+#else
+
+  /* FIXME bogus testing credentials */
+  _dbus_credentials_from_current_process (credentials);
+
+  return TRUE;
+
+#endif
 }
 
 /**
@@ -1052,16 +1198,23 @@
 
   addrlen = sizeof (addr);
   
+#ifndef DBUS_WIN
  retry:
+#endif
   client_fd = accept (listen_fd, &addr, &addrlen);
   
-  if (client_fd < 0)
+  if (DBUS_SOCKET_IS_INVALID (client_fd))
     {
+      DBUS_SOCKET_SET_ERRNO ();
+#ifndef DBUS_WIN
       if (errno == EINTR)
         goto retry;
+#else
+      client_fd = -1;
+#endif
     }
   
-  return client_fd;
+  return _dbus_encapsulate_socket (client_fd);
 }
 
 /** @} */
@@ -1241,6 +1394,7 @@
 	
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
     
+#ifndef DBUS_WIN    
   directory = _dbus_string_get_const_data (dir);
 	
   if (stat (directory, &sb) < 0)
@@ -1258,7 +1412,7 @@
                      "%s directory is not private to the user", directory);
       return FALSE;
     }
-    
+#endif    
   return TRUE;
 }
 
@@ -1342,6 +1496,10 @@
 ascii_strtod (const char *nptr,
 	      char      **endptr)
 {
+  /* FIXME: The Win32 C library's strtod() doesn't handle hex.
+   * Presumably many Unixes don't either.
+   */
+
   char *fail_pos;
   double val;
   struct lconv *locale_data;
@@ -1510,6 +1668,9 @@
  * @addtogroup DBusInternalsUtils
  * @{
  */
+
+#ifndef DBUS_WIN
+
 static dbus_bool_t
 fill_user_info_from_passwd (struct passwd *p,
                             DBusUserInfo  *info,
@@ -1532,6 +1693,7 @@
 
   return TRUE;
 }
+#endif
 
 static dbus_bool_t
 fill_user_info (DBusUserInfo       *info,
@@ -1557,6 +1719,7 @@
   else
     username_c = NULL;
 
+#ifndef DBUS_WIN
   /* For now assuming that the getpwnam() and getpwuid() flavors
    * are always symmetrical, if not we have to add more configure
    * checks
@@ -1707,8 +1870,36 @@
  failed:
   _DBUS_ASSERT_ERROR_IS_SET (error);
   return FALSE;
+
+#else  /* DBUS_WIN */
+
+  if (uid != DBUS_UID_UNSET)
+    {
+      if (!fill_win_user_info_from_uid (uid, info, error)) {
+      	_dbus_verbose("%s after fill_win_user_info_from_uid\n",__FUNCTION__);
+      return FALSE;
+    }
+    }
+  else
+    {
+      wchar_t *wname = _dbus_win_utf8_to_utf16 (username_c, error);
+      
+      if (!wname)
+	return FALSE;
+      
+    if (!fill_win_user_info_from_name (wname, info, error))
+	  {
+	    dbus_free (wname);
+	    return FALSE;
+	  }
+    dbus_free (wname);
+    }
+
+  return TRUE;
+#endif  /* DBUS_WIN */
 }
 
+
 /**
  * Gets user info for the given username.
  *
@@ -1756,7 +1947,7 @@
   dbus_free (info->homedir);
 }
 
-/**
+ /**
  * Frees the members of info (but not info itself).
  *
  * @param info the group info
@@ -1789,6 +1980,7 @@
 void
 _dbus_credentials_from_current_process (DBusCredentials *credentials)
 {
+#ifndef DBUS_WIN
   /* The POSIX spec certainly doesn't promise this, but
    * we need these assertions to fail as soon as we're wrong about
    * it so we can do the porting fixups
@@ -1796,10 +1988,11 @@
   _dbus_assert (sizeof (pid_t) <= sizeof (credentials->pid));
   _dbus_assert (sizeof (uid_t) <= sizeof (credentials->uid));
   _dbus_assert (sizeof (gid_t) <= sizeof (credentials->gid));
+#endif
   
-  credentials->pid = getpid ();
-  credentials->uid = getuid ();
-  credentials->gid = getgid ();
+  credentials->pid = _dbus_getpid ();
+  credentials->uid = _dbus_getuid ();
+  credentials->gid = _dbus_getgid ();
 }
 
 /**
@@ -1833,7 +2026,11 @@
 unsigned long
 _dbus_getpid (void)
 {
+#ifndef DBUS_WIN
   return getpid ();
+#else
+  return GetCurrentProcessId ();
+#endif
 }
 
 /** Gets our UID
@@ -1842,7 +2039,11 @@
 dbus_uid_t
 _dbus_getuid (void)
 {
+#ifdef DBUS_WIN
+  return _dbus_getuid_win ();
+#else
   return getuid ();
+#endif
 }
 
 #ifdef DBUS_BUILD_TESTS
@@ -1852,7 +2053,11 @@
 dbus_gid_t
 _dbus_getgid (void)
 {
+#ifdef DBUS_WIN
+  return _dbus_getgid_win ();
+#else
   return getgid ();
+#endif 
 }
 #endif
 
@@ -1934,6 +2139,9 @@
             int         n_fds,
             int         timeout_milliseconds)
 {
+#ifdef DBUS_WIN
+	return _dbus_poll_win (fds, n_fds, timeout_milliseconds);
+#else
 #ifdef HAVE_POLL
   /* This big thing is a constant expression and should get optimized
    * out of existence. So it's more robust than a configure check at
@@ -2019,8 +2227,10 @@
 
   return ready;
 #endif
+#endif /* DBUS_WIN */
 }
 
+
 /** nanoseconds in a second */
 #define NANOSECONDS_PER_SECOND       1000000000
 /** microseconds in a second */
@@ -2039,6 +2249,7 @@
 void
 _dbus_sleep_milliseconds (int milliseconds)
 {
+#ifndef DBUS_WIN
 #ifdef HAVE_NANOSLEEP
   struct timespec req;
   struct timespec rem;
@@ -2055,18 +2266,22 @@
 #else /* ! HAVE_USLEEP */
   sleep (MAX (milliseconds / 1000, 1));
 #endif
+#else  /* DBUS_WIN */
+  Sleep (milliseconds);
+#endif /* !DBUS_WIN */
 }
 
 /**
  * Get current time, as in gettimeofday().
  *
  * @param tv_sec return location for number of seconds
- * @param tv_usec return location for number of microseconds (thousandths)
+ * @param tv_usec return location for number of microseconds
  */
 void
 _dbus_get_current_time (long *tv_sec,
                         long *tv_usec)
 {
+#ifndef DBUS_WIN
   struct timeval t;
 
   gettimeofday (&t, NULL);
@@ -2075,6 +2290,24 @@
     *tv_sec = t.tv_sec;
   if (tv_usec)
     *tv_usec = t.tv_usec;
+#else
+  FILETIME ft;
+  dbus_uint64_t *time64 = (dbus_uint64_t *) &ft;
+
+  GetSystemTimeAsFileTime (&ft);
+
+  /* Convert from 100s of nanoseconds since 1601-01-01
+   * to Unix epoch. Yes, this is Y2038 unsafe.
+   */
+  *time64 -= DBUS_INT64_CONSTANT (116444736000000000);
+  *time64 /= 10;
+
+  if (tv_sec)
+    *tv_sec = *time64 / 1000000;
+
+  if (tv_usec)
+    *tv_usec = *time64 % 1000000;
+#endif
 }
 
 /**
@@ -2102,7 +2335,7 @@
   
   filename_c = _dbus_string_get_const_data (filename);
   
-  /* O_BINARY useful on Cygwin */
+  /* O_BINARY useful on Cygwin and Win32 */
   fd = open (filename_c, O_RDONLY | O_BINARY);
   if (fd < 0)
     {
@@ -2142,10 +2375,11 @@
   if (sb.st_size > 0 && S_ISREG (sb.st_mode))
     {
       int bytes_read;
+      const int encapsulated_fd = _dbus_encapsulate_fd (fd);
 
       while (total < (int) sb.st_size)
         {
-          bytes_read = _dbus_read (fd, str,
+          bytes_read = _dbus_read (encapsulated_fd, str,
                                    sb.st_size - total);
           if (bytes_read <= 0)
             {
@@ -2157,7 +2391,7 @@
               _dbus_verbose ("read() failed: %s",
                              _dbus_strerror (errno));
               
-              close (fd);
+              _dbus_close (encapsulated_fd, NULL);
               _dbus_string_set_length (str, orig_len);
               return FALSE;
             }
@@ -2165,7 +2399,7 @@
             total += bytes_read;
         }
 
-      close (fd);
+      _dbus_close (encapsulated_fd, NULL);
       return TRUE;
     }
   else if (sb.st_size != 0)
@@ -2254,6 +2488,8 @@
       goto out;
     }
 
+  fd = _dbus_encapsulate_fd (fd);
+
   need_unlink = TRUE;
   
   total = 0;
@@ -2278,7 +2514,7 @@
       total += bytes_written;
     }
 
-  if (close (fd) < 0)
+  if (_dbus_close (fd, NULL) < 0)
     {
       dbus_set_error (error, _dbus_error_from_errno (errno),
                       "Could not close file %s: %s",
@@ -2289,7 +2525,11 @@
 
   fd = -1;
   
-  if (rename (tmp_filename_c, filename_c) < 0)
+  if (
+#ifdef DBUS_WIN
+      (unlink (filename_c) == -1 && errno != ENOENT) ||
+#endif
+      rename (tmp_filename_c, filename_c) < 0)
     {
       dbus_set_error (error, _dbus_error_from_errno (errno),
                       "Could not rename %s to %s: %s",
@@ -2309,7 +2549,7 @@
    */
 
   if (fd >= 0)
-    close (fd);
+    _dbus_close (fd, NULL);
         
   if (need_unlink && unlink (tmp_filename_c) < 0)
     _dbus_verbose ("Failed to unlink temp file %s: %s\n",
@@ -2447,6 +2687,7 @@
       _dbus_string_get_length (next_component) == 0)
     return TRUE;
   
+#ifndef DBUS_WIN
   dir_ends_in_slash = '/' == _dbus_string_get_byte (dir,
                                                     _dbus_string_get_length (dir) - 1);
 
@@ -2461,7 +2702,26 @@
       if (!_dbus_string_append_byte (dir, '/'))
         return FALSE;
     }
+#else
+  dir_ends_in_slash =
+    ('/' == _dbus_string_get_byte (dir, _dbus_string_get_length (dir) - 1) ||
+     '\\' == _dbus_string_get_byte (dir, _dbus_string_get_length (dir) - 1));
 
+  file_starts_with_slash =
+     ('/' == _dbus_string_get_byte (next_component, 0) ||
+      '\\' == _dbus_string_get_byte (next_component, 0));
+
+  if (dir_ends_in_slash && file_starts_with_slash)
+    {
+      _dbus_string_shorten (dir, 1);
+    }
+  else if (!(dir_ends_in_slash || file_starts_with_slash))
+    {
+      if (!_dbus_string_append_byte (dir, '\\'))
+        return FALSE;
+    }
+#endif
+
   return _dbus_string_copy (next_component, 0, dir,
                             _dbus_string_get_length (dir));
 }
@@ -2568,14 +2828,18 @@
   old_len = _dbus_string_get_length (str);
   fd = -1;
 
+#ifndef DBUS_WIN
   /* note, urandom on linux will fall back to pseudorandom */
   fd = open ("/dev/urandom", O_RDONLY);
+#endif
+
   if (fd < 0)
     return pseudorandom_generate_random_bytes (str, n_bytes);
 
+#ifndef DBUS_WIN
   if (_dbus_read (fd, str, n_bytes) != n_bytes)
     {
-      close (fd);
+      _dbus_close (fd, NULL);
       _dbus_string_set_length (str, old_len);
       return pseudorandom_generate_random_bytes (str, n_bytes);
     }
@@ -2586,6 +2850,10 @@
   close (fd);
   
   return TRUE;
+#else
+  _dbus_assert_not_reached ("_dbus_generate_random_bytes fails");
+  return FALSE;
+#endif
 }
 
 /**
@@ -2635,6 +2903,7 @@
 const char*
 _dbus_strerror (int error_number)
 {
+#ifndef DBUS_WIN
   const char *msg;
   
   msg = strerror (error_number);
@@ -2642,6 +2911,9 @@
     msg = "unknown";
 
   return msg;
+#else
+  return _dbus_strerror_win(error_number);
+#endif
 }
 
 /**
@@ -2650,7 +2922,9 @@
 void
 _dbus_disable_sigpipe (void)
 {
+#ifndef DBUS_WIN
   signal (SIGPIPE, SIG_IGN);
+#endif
 }
 
 /**
@@ -2663,6 +2937,9 @@
 void
 _dbus_fd_set_close_on_exec (int fd)
 {
+#ifdef DBUS_WIN
+  _dbus_fd_set_close_on_exec_win(fd);
+#else
   int val;
   
   val = fcntl (fd, F_GETFD, 0);
@@ -2673,15 +2950,16 @@
   val |= FD_CLOEXEC;
   
   fcntl (fd, F_SETFD, val);
+#endif
 }
 
 /**
- * Converts a UNIX errno into a #DBusError name.
+ * Converts a UNIX errno or a Winsock error code into a #DBusError name.
  *
  * @todo should cover more errnos, specifically those
  * from open().
  * 
- * @param error_number the errno.
+ * @param error_number the errno or Winsock error code.
  * @returns an error name
  */
 const char*
@@ -2795,6 +3073,10 @@
 _dbus_close (int        fd,
              DBusError *error)
 {
+#ifdef DBUS_WIN
+  return _dbus_close_win (fd, error);
+#else
+
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
   
  again:
@@ -2809,6 +3091,7 @@
     }
 
   return TRUE;
+#endif
 }
 
 /**
@@ -2822,6 +3105,9 @@
 _dbus_set_fd_nonblocking (int             fd,
                           DBusError      *error)
 {
+#ifdef DBUS_WIN
+  return _dbus_set_fd_nonblocking_win(fd, error);
+#else
   int val;
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
@@ -2849,6 +3135,7 @@
     }
 
   return TRUE;
+#endif
 }
 
 #if !defined (DBUS_DISABLE_ASSERT) || defined(DBUS_BUILD_TESTS)
@@ -2896,8 +3183,8 @@
 _dbus_parse_uid (const DBusString      *uid_str,
                  dbus_uid_t            *uid)
 {
+  dbus_uid_t val;
   int end;
-  long val;
   
   if (_dbus_string_get_length (uid_str) == 0)
     {
@@ -2907,8 +3194,7 @@
 
   val = -1;
   end = 0;
-  if (!_dbus_string_parse_int (uid_str, 0, &val,
-                               &end))
+  if (!_dbus_string_parse_int (uid_str, 0, &val, &end))
     {
       _dbus_verbose ("could not parse string as a UID\n");
       return FALSE;
@@ -2978,6 +3264,9 @@
                  *fd1, *fd2);
   
   return TRUE;  
+
+#elif defined (DBUS_WIN)
+  return _dbus_full_duplex_pipe_win (fd1, fd2, blocking, error);
 #else
   _dbus_warn ("_dbus_full_duplex_pipe() not implemented on this OS\n");
   dbus_set_error (error, DBUS_ERROR_FAILED,
Index: dbus/dbus-sysdeps.h
===================================================================
--- dbus/dbus-sysdeps.h	(revision 115)
+++ dbus/dbus-sysdeps.h	(working copy)
@@ -101,6 +101,22 @@
 #define DBUS_UID_FORMAT "%lu"
 #define DBUS_GID_FORMAT "%lu"
 
+#ifdef DBUS_WIN
+int _dbus_encapsulate_socket    (int socket);
+int _dbus_re_encapsulate_socket (int socket);
+int _dbus_encapsulate_fd        (int fd);
+int _dbus_re_encapsulate_fd     (int fd);
+int _dbus_decapsulate           (int fd);
+#else
+#define _dbus_encapsulate_socket(socket)    (socket)
+#define _dbus_re_encapsulate_socket(socket) (socket)
+#define _dbus_encapsulate_fd(fd)            (fd)
+#define _dbus_re_encapsulate_fd(fd)         (fd)
+#define _dbus_decapsulate(fd)               (fd)
+#endif
+                                                                                                                               
+                                                                                                                                    
+
 /**
  * Struct representing socket credentials
  */
Index: windows-patch.diff
===================================================================
--- windows-patch.diff	(revision 114)
+++ windows-patch.diff	(working copy)
@@ -1,57 +1,93 @@
-? .svn
-? README.win
-? TODO.win
-? cmake
-? qt-qdbus-win32.patch
-? tmp.patch
-? win-changes-before-merging.diff
-? win-patches
-? windows-patch.diff
-? bus/.svn
-? bus/dir-watch.c
-? dbus/.svn
-? dbus/dbus-dirent.h
-? dbus/dbus-example.c
-? dbus/dbus-sockets-win.h
-? dbus/dbus-spawn-win.c
-? dbus/dbus-sysdeps-util-unix.c
-? dbus/dbus-sysdeps-util-win.c
-? dbus/dbus-sysdeps-win.c
-? dbus/dbus-sysdeps-win.h
-? doc/.svn
-? glib/.svn
-? glib/examples/.svn
-? glib/examples/statemachine/.svn
-? test/.svn
-? test/data/.svn
-? test/data/auth/.svn
-? test/data/equiv-config-files/.svn
-? test/data/equiv-config-files/basic/.svn
-? test/data/equiv-config-files/basic/basic.d/.svn
-? test/data/equiv-config-files/entities/.svn
-? test/data/equiv-config-files/entities/basic.d/.svn
-? test/data/incomplete-messages/.svn
-? test/data/invalid-config-files/.svn
-? test/data/invalid-messages/.svn
-? test/data/sha-1/.svn
-? test/data/valid-config-files/.svn
-? test/data/valid-config-files/basic.d/.svn
-? test/data/valid-config-files/system.d/.svn
-? test/data/valid-introspection-files/.svn
-? test/data/valid-messages/.svn
-? test/data/valid-service-files/.svn
-? test/glib/.svn
-? test/name-test/.svn
-? test/python/.svn
-? test/qt/.svn
-? tools/.svn
+Index: test/spawn-test.c
+===================================================================
+--- test/spawn-test.c	(revision 113)
++++ test/spawn-test.c	(working copy)
+@@ -31,7 +31,11 @@
+     argv_copy [i] = argv[i + 1];
+   argv_copy[argc - 1] = NULL;
+   
++#ifdef DBUS_WIN
++  if (!_dbus_spawn_async_with_babysitter (NULL, argv_copy, setup_func, NULL, NULL, &error))
++#else
+   if (!_dbus_spawn_async_with_babysitter (NULL, argv_copy, setup_func, NULL, &error))
++#endif
+     {
+       fprintf (stderr, "Could not launch application: \"%s\"\n",
+ 	       error.message);
+Index: test/test-segfault.c
+===================================================================
+--- test/test-segfault.c	(revision 113)
++++ test/test-segfault.c	(working copy)
+@@ -1,10 +1,27 @@
+ /* This is simply a process that segfaults */
++#include <config.h>
+ #include <stdlib.h>
+ #include <signal.h>
+ 
++#ifdef DBUS_WIN
++#define RLIMIT_CORE	4		/* max core file size */
++typedef unsigned long rlim_t;
++struct rlimit {
++	rlim_t	rlim_cur;
++	rlim_t	rlim_max;
++};
++static int getrlimit (int __resource, struct rlimit *__rlp) {
++  return -1;
++}
++static int setrlimit (int __resource, const struct rlimit *__rlp) {
++  return -1;
++}
++#else
+ #include <sys/time.h>
+ #include <sys/resource.h>
++#endif
+ 
++
+ int
+ main (int argc, char **argv)
+ {
+Index: test/test-sleep-forever.c
+===================================================================
+--- test/test-sleep-forever.c	(revision 113)
++++ test/test-sleep-forever.c	(working copy)
+@@ -1,6 +1,10 @@
+ /* This is a process that just sleeps infinitely. */
+ 
++
++#include <config.h>
++#ifndef DBUS_WIN
+ #include <unistd.h>
++#endif
+ 
+ int
+ main (int argc, char **argv)
+Index: cmake/CMakeLists.txt
+===================================================================
+--- cmake/CMakeLists.txt	(revision 113)
++++ cmake/CMakeLists.txt	(working copy)
+@@ -45,6 +45,18 @@
+ # make some more macros available
+ include (MacroLibrary)
+ 
++if (WIN32)
++	set (DBUS_HAVE_INT64 1)
++	set (DBUS_INT64_TYPE "long long int")
++	set (DBUS_INT32_TYPE int)
++	set (DBUS_INT16_TYPE short)
++else (WIN32)
++	set (DBUS_HAVE_INT64 1)
++	set (DBUS_INT64_TYPE "long long int")
++	set (DBUS_INT32_TYPE int)
++	set (DBUS_INT16_TYPE short)
++endif (WIN32)
++
+ if(MSVC)
+     ADD_DEFINITIONS(-D_CRT_SECURE_NO_DEPRECATE -D_CRT_NONSTDC_NO_DEPRECATE)
+ 	SET(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -Zi " CACHE STRING "runtime-library flags" FORCE)
 Index: bus/activation.c
 ===================================================================
-RCS file: /cvs/dbus/dbus/bus/activation.c,v
-retrieving revision 1.44
-diff -u -B -b -r1.44 activation.c
---- bus/activation.c	10 Aug 2006 20:09:43 -0000	1.44
-+++ bus/activation.c	18 Aug 2006 17:26:21 -0000
+--- bus/activation.c	(revision 113)
++++ bus/activation.c	(working copy)
 @@ -34,7 +34,6 @@
  #include <dbus/dbus-spawn.h>
  #include <dbus/dbus-timeout.h>
@@ -78,11 +114,8 @@
      {
 Index: bus/test-main.c
 ===================================================================
-RCS file: /cvs/dbus/dbus/bus/test-main.c,v
-retrieving revision 1.21
-diff -u -B -b -r1.21 test-main.c
---- bus/test-main.c	3 Nov 2004 16:38:35 -0000	1.21
-+++ bus/test-main.c	18 Aug 2006 17:26:21 -0000
+--- bus/test-main.c	(revision 113)
++++ bus/test-main.c	(working copy)
 @@ -123,16 +123,22 @@
      die ("signals");
    test_post_hook ();
@@ -106,29 +139,10 @@
    test_post_hook ();
  
    test_pre_hook ();
-Index: dbus/dbus-mainloop.c
-===================================================================
-RCS file: /cvs/dbus/dbus/dbus/dbus-mainloop.c,v
-retrieving revision 1.18
-diff -u -B -b -r1.18 dbus-mainloop.c
---- dbus/dbus-mainloop.c	15 Jan 2005 07:15:38 -0000	1.18
-+++ dbus/dbus-mainloop.c	18 Aug 2006 17:26:27 -0000
-@@ -609,7 +609,7 @@
-                   
-               flags = dbus_watch_get_flags (wcb->watch);
-                   
--              fds[n_fds].fd = dbus_watch_get_fd (wcb->watch);
-+              fds[n_fds].fd = _dbus_re_encapsulate_socket(dbus_watch_get_fd (wcb->watch));
-               fds[n_fds].revents = 0;
-               fds[n_fds].events = 0;
-               if (flags & DBUS_WATCH_READABLE)
 Index: dbus/dbus-server-unix.c
 ===================================================================
-RCS file: /cvs/dbus/dbus/dbus/dbus-server-unix.c,v
-retrieving revision 1.29
-diff -u -B -b -r1.29 dbus-server-unix.c
---- dbus/dbus-server-unix.c	25 Oct 2005 15:57:13 -0000	1.29
-+++ dbus/dbus-server-unix.c	18 Aug 2006 17:26:21 -0000
+--- dbus/dbus-server-unix.c	(revision 113)
++++ dbus/dbus-server-unix.c	(working copy)
 @@ -27,12 +27,16 @@
  #include "dbus-connection-internal.h"
  #include "dbus-string.h"
@@ -181,9 +195,12 @@
  
 +#else /* ifndef DBUS_WIN */
 +
-+/**
+ /**
+- * Creates a new server listening on the given hostname and port.
+- * If the hostname is NULL, listens on localhost.
 + * Creates a new server listening on the given Windows named pipe.
-+ *
+  *
+- * @param host the hostname to listen on.
 + * @param path the path for the domain socket.
 + * @param abstract #TRUE to use abstract socket namespace
 + * @param error location to store reason for failure.
@@ -261,14 +278,11 @@
 +#endif /* ifndef DBUS_WIN */
 +
 +
- /**
-- * Creates a new server listening on the given hostname and port.
-- * If the hostname is NULL, listens on localhost.
++/**
 + * Creates a new server listening on the given hostname and port.  If
 + * the hostname is NULL, listens on localhost. If the hostname is an
 + * empty string, listens on any local host address.
-  *
-- * @param host the hostname to listen on.
++ *
 + * @param host the hostname for the address to listen.
   * @param port the port to listen on.
   * @param error location to store reason for failure.
@@ -282,13 +296,24 @@
        _dbus_string_free (&address);
        return NULL;
      }
+Index: dbus/dbus-test.c
+===================================================================
+--- dbus/dbus-test.c	(revision 113)
++++ dbus/dbus-test.c	(working copy)
+@@ -154,7 +154,9 @@
+   
+   run_test ("hash", specific_test, _dbus_hash_test);
+ 
++#ifndef DBUS_WIN
+   run_data_test ("spawn", specific_test, _dbus_spawn_test, test_data_dir);
++#endif
+   
+   run_data_test ("userdb", specific_test, _dbus_userdb_test, test_data_dir);
+   
 Index: dbus/dbus-spawn.h
 ===================================================================
-RCS file: /cvs/dbus/dbus/dbus/dbus-spawn.h,v
-retrieving revision 1.7
-diff -u -B -b -r1.7 dbus-spawn.h
---- dbus/dbus-spawn.h	9 Sep 2004 10:20:17 -0000	1.7
-+++ dbus/dbus-spawn.h	18 Aug 2006 17:26:27 -0000
+--- dbus/dbus-spawn.h	(revision 113)
++++ dbus/dbus-spawn.h	(working copy)
 @@ -37,6 +37,9 @@
  
  dbus_bool_t _dbus_spawn_async_with_babysitter     (DBusBabysitter           **sitter_p,
@@ -301,12 +326,9 @@
                                                     DBusError                 *error);
 Index: dbus/dbus-sysdeps-util.c
 ===================================================================
-RCS file: /cvs/dbus/dbus/dbus/dbus-sysdeps-util.c,v
-retrieving revision 1.8
-diff -u -B -b -r1.8 dbus-sysdeps-util.c
---- dbus/dbus-sysdeps-util.c	14 Aug 2006 19:11:35 -0000	1.8
-+++ dbus/dbus-sysdeps-util.c	18 Aug 2006 17:26:27 -0000
-@@ -29,152 +29,16 @@
+--- dbus/dbus-sysdeps-util.c	(revision 115)
++++ dbus/dbus-sysdeps-util.c	(working copy)
+@@ -29,154 +29,18 @@
  #include "dbus-userdb.h"
  #include "dbus-test.h"
  
@@ -349,9 +371,14 @@
 -  const char *s;
 -  pid_t child_pid;
 -  int dev_null_fd;
--
++#ifdef DBUS_WIN
++#include "dbus-sysdeps-util-win.c"
++#else
++#include "dbus-sysdeps-util-unix.c"
++#endif
+ 
 -  _dbus_verbose ("Becoming a daemon...\n");
--
+ 
 -  _dbus_verbose ("chdir to /\n");
 -  if (chdir ("/") < 0)
 -    {
@@ -456,15 +483,86 @@
 -  
 -  return TRUE;
 -}
-+#ifdef DBUS_WIN
-+#include "dbus-sysdeps-util-win.c"
-+#else
-+#include "dbus-sysdeps-util-unix.c"
-+#endif
+-
+-
+ /**
+  * Creates a file containing the process ID.
+  *
+@@ -235,73 +99,7 @@
+   return TRUE;
+ }
  
- 
+-
  /**
-@@ -329,115 +193,42 @@
+- * Changes the user and group the bus is running as.
+- *
+- * @param uid the new user ID
+- * @param gid the new group ID
+- * @param error return location for errors
+- * @returns #FALSE on failure
+- */
+-dbus_bool_t
+-_dbus_change_identity  (dbus_uid_t     uid,
+-                        dbus_gid_t     gid,
+-                        DBusError     *error)
+-{
+-  /* setgroups() only works if we are a privileged process,
+-   * so we don't return error on failure; the only possible
+-   * failure is that we don't have perms to do it.
+-   * FIXME not sure this is right, maybe if setuid()
+-   * is going to work then setgroups() should also work.
+-   */
+-  if (setgroups (0, NULL) < 0)
+-    _dbus_warn ("Failed to drop supplementary groups: %s\n",
+-                _dbus_strerror (errno));
+-  
+-  /* Set GID first, or the setuid may remove our permission
+-   * to change the GID
+-   */
+-  if (setgid (gid) < 0)
+-    {
+-      dbus_set_error (error, _dbus_error_from_errno (errno),
+-                      "Failed to set GID to %lu: %s", gid,
+-                      _dbus_strerror (errno));
+-      return FALSE;
+-    }
+-  
+-  if (setuid (uid) < 0)
+-    {
+-      dbus_set_error (error, _dbus_error_from_errno (errno),
+-                      "Failed to set UID to %lu: %s", uid,
+-                      _dbus_strerror (errno));
+-      return FALSE;
+-    }
+-  
+-  return TRUE;
+-}
+-
+-/** Installs a UNIX signal handler
+- *
+- * @param sig the signal to handle
+- * @param handler the handler
+- */
+-void
+-_dbus_set_signal_handler (int               sig,
+-                          DBusSignalHandler handler)
+-{
+-  struct sigaction act;
+-  sigset_t empty_mask;
+-  
+-  sigemptyset (&empty_mask);
+-  act.sa_handler = handler;
+-  act.sa_mask    = empty_mask;
+-  act.sa_flags   = 0;
+-  sigaction (sig,  &act, NULL);
+-}
+-
+-
+-/**
+  * Removes a directory; Directory must be empty
+  * 
+  * @param filename directory filename
+@@ -329,115 +127,42 @@
    return TRUE;
  }
  
@@ -570,7 +668,9 @@
  {
 -  const char *filename_c;
 -  struct stat sb;
--
++  return fill_group_info (info, DBUS_GID_UNSET,
++                          groupname, error);
+ 
 -  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
 -  
 -  filename_c = _dbus_string_get_const_data (filename);
@@ -590,9 +690,7 @@
 -  statbuf->atime = sb.st_atime;
 -  statbuf->mtime = sb.st_mtime;
 -  statbuf->ctime = sb.st_ctime;
-+  return fill_group_info (info, DBUS_GID_UNSET,
-+                          groupname, error);
- 
+-
 -  return TRUE;
  }
  
@@ -600,7 +698,7 @@
  /**
   * Internals of directory iterator
   */
-@@ -466,7 +257,7 @@
+@@ -466,7 +191,7 @@
    
    filename_c = _dbus_string_get_const_data (filename);
  
@@ -609,7 +707,7 @@
    if (d == NULL)
      {
        dbus_set_error (error, _dbus_error_from_errno (errno),
-@@ -478,7 +269,7 @@
+@@ -478,7 +203,7 @@
    iter = dbus_new0 (DBusDirIter, 1);
    if (iter == NULL)
      {
@@ -618,7 +716,7 @@
        dbus_set_error (error, DBUS_ERROR_NO_MEMORY,
                        "Could not allocate memory for directory iterator");
        return NULL;
-@@ -513,7 +304,7 @@
+@@ -513,7 +238,7 @@
    
   again:
    errno = 0;
@@ -627,7 +725,7 @@
    if (ent == NULL)
      {
        if (errno != 0)
-@@ -546,317 +337,9 @@
+@@ -546,317 +271,9 @@
  void
  _dbus_directory_close (DBusDirIter *iter)
  {
@@ -645,7 +743,7 @@
 -  
 -  info->gid = g->gr_gid;
 -  info->groupname = _dbus_strdup (g->gr_name);
--
+ 
 -  /* info->members = dbus_strdupv (g->gr_mem) */
 -  
 -  if (info->groupname == NULL)
@@ -750,7 +848,7 @@
 -                          groupname, error);
 -
 -}
- 
+-
 -/**
 - * Initializes the given DBusGroupInfo struct
 - * with information about the given group ID.
@@ -946,13 +1044,66 @@
 -  return TRUE;
 -}
 -#endif /* DBUS_BUILD_TESTS */
+Index: dbus/dbus-watch.c
+===================================================================
+--- dbus/dbus-watch.c	(revision 113)
++++ dbus/dbus-watch.c	(working copy)
+@@ -486,7 +486,10 @@
+ int
+ dbus_watch_get_fd (DBusWatch *watch)
+ {
+-  return watch->fd;
++  if (watch->fd == -1)
++    return -1;
++  else
++    return _dbus_decapsulate (watch->fd);
+ }
+ 
+ /**
+Index: dbus/dbus-transport-unix.c
+===================================================================
+--- dbus/dbus-transport-unix.c	(revision 115)
++++ dbus/dbus-transport-unix.c	(working copy)
+@@ -26,6 +26,9 @@
+ #include "dbus-transport-unix.h"
+ #include "dbus-transport-protected.h"
+ #include "dbus-watch.h"
++#ifdef DBUS_WIN
++#include "dbus-sockets-win.h"
++#endif
+ 
+ 
+ /**
+Index: dbus/dbus-mainloop.c
+===================================================================
+--- dbus/dbus-mainloop.c	(revision 113)
++++ dbus/dbus-mainloop.c	(working copy)
+@@ -609,7 +609,7 @@
+                   
+               flags = dbus_watch_get_flags (wcb->watch);
+                   
+-              fds[n_fds].fd = dbus_watch_get_fd (wcb->watch);
++              fds[n_fds].fd = _dbus_re_encapsulate_socket(dbus_watch_get_fd (wcb->watch));
+               fds[n_fds].revents = 0;
+               fds[n_fds].events = 0;
+               if (flags & DBUS_WATCH_READABLE)
+Index: dbus/dbus-sysdeps-win.c
+===================================================================
+--- dbus/dbus-sysdeps-win.c	(revision 113)
++++ dbus/dbus-sysdeps-win.c	(working copy)
+@@ -29,7 +29,7 @@
+ #include "dbus-threads.h"
+ #include "dbus-protocol.h"
+ #include "dbus-hash.h"
+-#include "dbus-dirent.h"
++//#include "dbus-dirent.h"
+ #include "dbus-sockets-win.h"
+ #include "dbus-string.h"
+ #include <sys/types.h>
 Index: dbus/dbus-sysdeps.c
 ===================================================================
-RCS file: /cvs/dbus/dbus/dbus/dbus-sysdeps.c,v
-retrieving revision 1.108
-diff -u -B -b -r1.108 dbus-sysdeps.c
---- dbus/dbus-sysdeps.c	18 Aug 2006 15:46:59 -0000	1.108
-+++ dbus/dbus-sysdeps.c	18 Aug 2006 17:26:28 -0000
+--- dbus/dbus-sysdeps.c	(revision 115)
++++ dbus/dbus-sysdeps.c	(working copy)
 @@ -3,6 +3,7 @@
   * 
   * Copyright (C) 2002, 2003  Red Hat, Inc.
@@ -961,7 +1112,7 @@
   *
   * Licensed under the Academic Free License version 2.1
   * 
-@@ -31,22 +32,30 @@
+@@ -31,23 +32,31 @@
  #include <stdlib.h>
  #include <string.h>
  #include <signal.h>
@@ -989,13 +1140,14 @@
  #include <netdb.h>
  #include <grp.h>
 +#endif
-+
+ 
 +#include <time.h>
 +#include <locale.h>
 +#include <sys/stat.h>
- 
++
  #ifdef HAVE_WRITEV
  #include <sys/uio.h>
+ #endif
 @@ -72,6 +81,14 @@
  _DBUS_DEFINE_GLOBAL_LOCK (win_fds);
  _DBUS_DEFINE_GLOBAL_LOCK (sid_atom_cache);
@@ -1256,8 +1408,8 @@
 +#ifdef DBUS_WIN
 +  struct in_addr ina;
 +#endif
-+
  
++
    _DBUS_ASSERT_ERROR_IS_CLEAR (error);
    
 +#ifdef DBUS_WIN
@@ -1764,7 +1916,7 @@
    dir_ends_in_slash = '/' == _dbus_string_get_byte (dir,
                                                      _dbus_string_get_length (dir) - 1);
  
-@@ -2461,6 +2702,25 @@
+@@ -2461,7 +2702,26 @@
        if (!_dbus_string_append_byte (dir, '/'))
          return FALSE;
      }
@@ -1772,7 +1924,7 @@
 +  dir_ends_in_slash =
 +    ('/' == _dbus_string_get_byte (dir, _dbus_string_get_length (dir) - 1) ||
 +     '\\' == _dbus_string_get_byte (dir, _dbus_string_get_length (dir) - 1));
-+
+ 
 +  file_starts_with_slash =
 +     ('/' == _dbus_string_get_byte (next_component, 0) ||
 +      '\\' == _dbus_string_get_byte (next_component, 0));
@@ -1787,9 +1939,10 @@
 +        return FALSE;
 +    }
 +#endif
- 
++
    return _dbus_string_copy (next_component, 0, dir,
                              _dbus_string_get_length (dir));
+ }
 @@ -2568,14 +2828,18 @@
    old_len = _dbus_string_get_length (str);
    fd = -1;
@@ -1947,11 +2100,8 @@
    dbus_set_error (error, DBUS_ERROR_FAILED,
 Index: dbus/dbus-sysdeps.h
 ===================================================================
-RCS file: /cvs/dbus/dbus/dbus/dbus-sysdeps.h,v
-retrieving revision 1.54
-diff -u -B -b -r1.54 dbus-sysdeps.h
---- dbus/dbus-sysdeps.h	14 Aug 2006 19:11:35 -0000	1.54
-+++ dbus/dbus-sysdeps.h	18 Aug 2006 17:26:28 -0000
+--- dbus/dbus-sysdeps.h	(revision 115)
++++ dbus/dbus-sysdeps.h	(working copy)
 @@ -101,6 +101,22 @@
  #define DBUS_UID_FORMAT "%lu"
  #define DBUS_GID_FORMAT "%lu"
@@ -1975,182 +2125,3 @@
  /**
   * Struct representing socket credentials
   */
-Index: dbus/dbus-test.c
-===================================================================
-RCS file: /cvs/dbus/dbus/dbus/dbus-test.c,v
-retrieving revision 1.42
-diff -u -B -b -r1.42 dbus-test.c
---- dbus/dbus-test.c	24 Feb 2005 16:03:56 -0000	1.42
-+++ dbus/dbus-test.c	18 Aug 2006 17:26:21 -0000
-@@ -154,7 +154,9 @@
-   
-   run_test ("hash", specific_test, _dbus_hash_test);
- 
-+#ifndef DBUS_WIN
-   run_data_test ("spawn", specific_test, _dbus_spawn_test, test_data_dir);
-+#endif
-   
-   run_data_test ("userdb", specific_test, _dbus_userdb_test, test_data_dir);
-   
-Index: dbus/dbus-transport-unix.c
-===================================================================
-RCS file: /cvs/dbus/dbus/dbus/dbus-transport-unix.c,v
-retrieving revision 1.50
-diff -u -B -b -r1.50 dbus-transport-unix.c
---- dbus/dbus-transport-unix.c	14 Aug 2006 19:11:35 -0000	1.50
-+++ dbus/dbus-transport-unix.c	18 Aug 2006 17:26:27 -0000
-@@ -26,6 +26,9 @@
- #include "dbus-transport-unix.h"
- #include "dbus-transport-protected.h"
- #include "dbus-watch.h"
-+#ifdef DBUS_WIN
-+#include "dbus-sockets-win.h"
-+#endif
- 
- 
- /**
-Index: dbus/dbus-watch.c
-===================================================================
-RCS file: /cvs/dbus/dbus/dbus/dbus-watch.c,v
-retrieving revision 1.19
-diff -u -B -b -r1.19 dbus-watch.c
---- dbus/dbus-watch.c	3 Aug 2006 20:34:36 -0000	1.19
-+++ dbus/dbus-watch.c	18 Aug 2006 17:26:27 -0000
-@@ -486,7 +486,10 @@
- int
- dbus_watch_get_fd (DBusWatch *watch)
- {
--  return watch->fd;
-+  if (watch->fd == -1)
-+    return -1;
-+  else
-+    return _dbus_decapsulate (watch->fd);
- }
- 
- /**
-Index: test/spawn-test.c
-===================================================================
-RCS file: /cvs/dbus/dbus/test/spawn-test.c,v
-retrieving revision 1.3
-diff -u -B -b -r1.3 spawn-test.c
---- test/spawn-test.c	5 Apr 2003 00:37:17 -0000	1.3
-+++ test/spawn-test.c	18 Aug 2006 17:26:21 -0000
-@@ -31,7 +31,11 @@
-     argv_copy [i] = argv[i + 1];
-   argv_copy[argc - 1] = NULL;
-   
-+#ifdef DBUS_WIN
-+  if (!_dbus_spawn_async_with_babysitter (NULL, argv_copy, setup_func, NULL, NULL, &error))
-+#else
-   if (!_dbus_spawn_async_with_babysitter (NULL, argv_copy, setup_func, NULL, &error))
-+#endif
-     {
-       fprintf (stderr, "Could not launch application: \"%s\"\n",
- 	       error.message);
-Index: test/test-segfault.c
-===================================================================
-RCS file: /cvs/dbus/dbus/test/test-segfault.c,v
-retrieving revision 1.4
-diff -u -B -b -r1.4 test-segfault.c
---- test/test-segfault.c	30 Nov 2005 19:32:26 -0000	1.4
-+++ test/test-segfault.c	18 Aug 2006 17:26:21 -0000
-@@ -1,9 +1,26 @@
- /* This is simply a process that segfaults */
-+#include <config.h>
- #include <stdlib.h>
- #include <signal.h>
- 
-+#ifdef DBUS_WIN
-+#define RLIMIT_CORE	4		/* max core file size */
-+typedef unsigned long rlim_t;
-+struct rlimit {
-+	rlim_t	rlim_cur;
-+	rlim_t	rlim_max;
-+};
-+static int getrlimit (int __resource, struct rlimit *__rlp) {
-+  return -1;
-+}
-+static int setrlimit (int __resource, const struct rlimit *__rlp) {
-+  return -1;
-+}
-+#else
- #include <sys/time.h>
- #include <sys/resource.h>
-+#endif
-+
- 
- int
- main (int argc, char **argv)
-Index: test/test-sleep-forever.c
-===================================================================
-RCS file: /cvs/dbus/dbus/test/test-sleep-forever.c,v
-retrieving revision 1.1
-diff -u -B -b -r1.1 test-sleep-forever.c
---- test/test-sleep-forever.c	5 Apr 2003 00:37:17 -0000	1.1
-+++ test/test-sleep-forever.c	18 Aug 2006 17:26:21 -0000
-@@ -1,6 +1,10 @@
- /* This is a process that just sleeps infinitely. */
- 
-+
-+#include <config.h>
-+#ifndef DBUS_WIN
- #include <unistd.h>
-+#endif
- 
- int
- main (int argc, char **argv)
-Index: test/data/sha-1/Readme.txt
-===================================================================
-RCS file: /cvs/dbus/dbus/test/data/sha-1/Readme.txt,v
-retrieving revision 1.1
-diff -u -B -b -r1.1 Readme.txt
-Index: test/data/sha-1/bit-hashes.sha1
-===================================================================
-RCS file: /cvs/dbus/dbus/test/data/sha-1/bit-hashes.sha1,v
-retrieving revision 1.1
-diff -u -B -b -r1.1 bit-hashes.sha1
-Index: test/data/sha-1/bit-messages.sha1
-===================================================================
-RCS file: /cvs/dbus/dbus/test/data/sha-1/bit-messages.sha1,v
-retrieving revision 1.1
-diff -u -B -b -r1.1 bit-messages.sha1
-Index: test/data/sha-1/byte-hashes.sha1
-===================================================================
-RCS file: /cvs/dbus/dbus/test/data/sha-1/byte-hashes.sha1,v
-retrieving revision 1.1
-diff -u -B -b -r1.1 byte-hashes.sha1
-Index: test/data/sha-1/byte-messages.sha1
-===================================================================
-RCS file: /cvs/dbus/dbus/test/data/sha-1/byte-messages.sha1,v
-retrieving revision 1.1
-diff -u -B -b -r1.1 byte-messages.sha1
-Index: tools/dbus-monitor.c
-===================================================================
-RCS file: /cvs/dbus/dbus/tools/dbus-monitor.c,v
-retrieving revision 1.16
-diff -u -B -b -r1.16 dbus-monitor.c
---- tools/dbus-monitor.c	14 Jun 2006 14:39:51 -0000	1.16
-+++ tools/dbus-monitor.c	18 Aug 2006 17:26:31 -0000
-@@ -19,6 +19,7 @@
-  *
-  */
- 
-+#include <config.h>
- #include <stdio.h>
- #include <stdlib.h>
- #include <string.h>
-Index: tools/dbus-send.c
-===================================================================
-RCS file: /cvs/dbus/dbus/tools/dbus-send.c,v
-retrieving revision 1.21
-diff -u -B -b -r1.21 dbus-send.c
---- tools/dbus-send.c	3 Aug 2006 20:34:36 -0000	1.21
-+++ tools/dbus-send.c	18 Aug 2006 17:26:32 -0000
-@@ -19,6 +19,7 @@
-  *
-  */
- 
-+#include <config.h>
- #include <stdio.h>
- #include <stdlib.h>
- #include <string.h>
Index: tools/dbus-monitor.c
===================================================================
--- tools/dbus-monitor.c	(revision 113)
+++ tools/dbus-monitor.c	(working copy)
@@ -19,6 +19,7 @@
  *
  */
 
+#include <config.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
Index: tools/dbus-send.c
===================================================================
--- tools/dbus-send.c	(revision 113)
+++ tools/dbus-send.c	(working copy)
@@ -19,6 +19,7 @@
  *
  */
 
+#include <config.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

Index: test/spawn-test.c
===================================================================
--- test/spawn-test.c	(Revision 206)
+++ test/spawn-test.c	(Arbeitskopie)
@@ -31,7 +31,7 @@
     argv_copy [i] = argv[i + 1];
   argv_copy[argc - 1] = NULL;
   
-  if (!_dbus_spawn_async_with_babysitter (NULL, argv_copy, setup_func, NULL, &error))
+  if (!_dbus_spawn_async_with_babysitter (NULL, argv_copy, NULL, setup_func, NULL, &error))
     {
       fprintf (stderr, "Could not launch application: \"%s\"\n",
 	       error.message);
Index: test/name-test/test-names.c
===================================================================
--- test/name-test/test-names.c	(Revision 206)
+++ test/name-test/test-names.c	(Arbeitskopie)
@@ -1,9 +1,11 @@
 #include <stdio.h>
 #include <stdlib.h>
-#include <unistd.h>
 #include <string.h>
 #include <dbus/dbus.h>
 #include <dbus/dbus-connection-internal.h>
+#ifndef DBUS_WIN
+#include <unistd.h>
+#endif
 
 #define REMOVE_CONNECTION 0
 #define ADD_CONNECTION 1
Index: test/test-segfault.c
===================================================================
--- test/test-segfault.c	(Revision 206)
+++ test/test-segfault.c	(Arbeitskopie)
@@ -1,10 +1,27 @@
 /* This is simply a process that segfaults */
+#include <config.h>
 #include <stdlib.h>
 #include <signal.h>
 
+#ifdef DBUS_WIN
+#define RLIMIT_CORE	4		/* max core file size */
+typedef unsigned long rlim_t;
+struct rlimit {
+	rlim_t	rlim_cur;
+	rlim_t	rlim_max;
+};
+static int getrlimit (int __resource, struct rlimit *__rlp) {
+  return -1;
+}
+static int setrlimit (int __resource, const struct rlimit *__rlp) {
+  return -1;
+}
+#else
 #include <sys/time.h>
 #include <sys/resource.h>
+#endif
 
+
 int
 main (int argc, char **argv)
 {
Index: test/test-sleep-forever.c
===================================================================
--- test/test-sleep-forever.c	(Revision 206)
+++ test/test-sleep-forever.c	(Arbeitskopie)
@@ -1,6 +1,10 @@
 /* This is a process that just sleeps infinitely. */
 
+
+#include <config.h>
+#ifndef DBUS_WIN
 #include <unistd.h>
+#endif
 
 int
 main (int argc, char **argv)
Index: bus/activation.c
===================================================================
--- bus/activation.c	(Revision 206)
+++ bus/activation.c	(Arbeitskopie)
@@ -34,7 +34,6 @@
 #include <dbus/dbus-spawn.h>
 #include <dbus/dbus-timeout.h>
 #include <dbus/dbus-sysdeps.h>
-#include <dirent.h>
 #include <errno.h>
 
 #define DBUS_SERVICE_SECTION "D-BUS Service"
@@ -1304,6 +1303,7 @@
   DBusMessage *message;
   DBusString service_str;
   char **argv;
+  char **envp = NULL;
   int argc;
   dbus_bool_t retval;
   DBusHashIter iter;
@@ -1535,6 +1535,7 @@
 
   _dbus_verbose ("Spawning %s ...\n", argv[0]);
   if (!_dbus_spawn_async_with_babysitter (&pending_activation->babysitter, argv,
+                                          envp,
                                           child_setup, activation, 
                                           error))
     {
Index: bus/test-main.c
===================================================================
--- bus/test-main.c	(Revision 206)
+++ bus/test-main.c	(Arbeitskopie)
@@ -123,16 +123,23 @@
     die ("signals");
   test_post_hook ();
 
+#ifdef DBUS_WIN
   test_pre_hook ();
   printf ("%s: Running SHA1 connection test\n", argv[0]);
   if (!bus_dispatch_sha1_test (&test_data_dir))
     die ("sha1");
   test_post_hook ();
-
+#else
+  printf ("%s: Running SHA1 connection test - skipped\n", argv[0]);
+#endif
+#ifndef DBUS_WIN
   test_pre_hook ();
   printf ("%s: Running message dispatch test\n", argv[0]);
   if (!bus_dispatch_test (&test_data_dir)) 
     die ("dispatch");
+#else
+  printf ("%s: Running message dispatch test - skipped\n",argv[0]);
+#endif
   test_post_hook ();
 
   test_pre_hook ();
Index: bus/desktop-file.c
===================================================================
--- bus/desktop-file.c	(Revision 206)
+++ bus/desktop-file.c	(Arbeitskopie)
@@ -360,15 +360,15 @@
 static void
 parse_comment_or_blank (BusDesktopFileParser *parser)
 {
-  int line_end;
+  int line_end, eol_len;
   
-  if (!_dbus_string_find (&parser->data, parser->pos, "\n", &line_end))
+  if (!_dbus_string_find_eol (&parser->data, parser->pos, &line_end, &eol_len))
     line_end = parser->len;
 
   if (line_end == parser->len)
     parser->pos = parser->len;
   else
-    parser->pos = line_end + 1;
+    parser->pos = line_end + eol_len;
   
   parser->line_num += 1;
 }
@@ -393,12 +393,12 @@
 static dbus_bool_t
 parse_section_start (BusDesktopFileParser *parser, DBusError *error)
 {
-  int line_end;
+  int line_end, eol_len;
   char *section_name;
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
-  
-  if (!_dbus_string_find (&parser->data, parser->pos, "\n", &line_end))
+    
+  if (!_dbus_string_find_eol (&parser->data, parser->pos, &line_end, &eol_len))
     line_end = parser->len;
   
   if (line_end - parser->pos <= 2 ||
@@ -436,7 +436,7 @@
   if (line_end == parser->len)
     parser->pos = parser->len;
   else
-    parser->pos = line_end + 1;
+    parser->pos = line_end + eol_len;
   
   parser->line_num += 1;
 
@@ -448,7 +448,7 @@
 static dbus_bool_t
 parse_key_value (BusDesktopFileParser *parser, DBusError *error)
 {
-  int line_end;
+  int line_end, eol_len;
   int key_start, key_end;
   int value_start;
   int p;
@@ -458,7 +458,7 @@
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
   
-  if (!_dbus_string_find (&parser->data, parser->pos, "\n", &line_end))
+  if (!_dbus_string_find_eol (&parser->data, parser->pos, &line_end, &eol_len))
     line_end = parser->len;
   
   p = parser->pos;
@@ -481,7 +481,7 @@
       if (line_end == parser->len)
 	parser->pos = parser->len;
       else
-	parser->pos = line_end + 1;
+	parser->pos = line_end + eol_len;
 	  
       parser->line_num += 1;
 
@@ -560,7 +560,7 @@
   if (line_end == parser->len)
     parser->pos = parser->len;
   else
-    parser->pos = line_end + 1;
+    parser->pos = line_end + eol_len;
   
   parser->line_num += 1;
 
Index: dbus/dbus-string.c
===================================================================
--- dbus/dbus-string.c	(Revision 206)
+++ dbus/dbus-string.c	(Arbeitskopie)
@@ -1790,6 +1790,72 @@
 }
 
 /**
+ * Finds end of line ("\r\n" or "\n") in the string,
+ * returning #TRUE and filling in the byte index
+ * where the eol string was found, if it was found.
+ * Returns #FALSE if eol wasn't found.
+ *
+ * @param str the string
+ * @param start where to start looking
+ * @param found return location for where it was found, or #NULL
+ * @param found_len return length of found eol string
+ * @returns #TRUE if found
+ */
+dbus_bool_t
+_dbus_string_find_eol (const DBusString *str,
+                   int               start,
+                   int              *found,
+                   int              *found_len)
+{
+  int i;
+
+  DBUS_CONST_STRING_PREAMBLE (str);
+  _dbus_assert (start <= real->len);
+  _dbus_assert (start >= 0);
+  
+  i = start;
+  while (i < real->len)
+    {
+      if (real->str[i] == '\r') 
+        {
+          if ((i+1) < real->len && real->str[i+1] == '\n') /* "\r\n" */
+            {
+              if (found) 
+                *found = i;
+              if (found_len)
+                *found_len = 2;
+              return TRUE;
+            } 
+          else /* only "\r" */
+            {
+              if (found) 
+                *found = i;
+              if (found_len)
+                *found_len = 1;
+              return TRUE;
+            }
+        } 
+      else if (real->str[i] == '\n')  /* only "\n" */
+        {
+          if (found) 
+            *found = i;
+          if (found_len)
+            *found_len = 1;
+          return TRUE;
+        }      
+      ++i;
+    }
+
+  if (found)
+    *found = real->len;
+
+  if (found_len)
+    *found_len = 0;
+  
+  return FALSE;
+}
+
+/**
  * Finds the given substring in the string,
  * up to a certain position,
  * returning #TRUE and filling in the byte index
@@ -1957,52 +2023,18 @@
 _dbus_string_pop_line (DBusString *source,
                        DBusString *dest)
 {
-  int eol;
-  dbus_bool_t have_newline;
+  int eol, eol_len;
   
   _dbus_string_set_length (dest, 0);
   
   eol = 0;
-  if (_dbus_string_find (source, 0, "\n", &eol))
-    {
-      have_newline = TRUE;
-      eol += 1; /* include newline */
-    }
-  else
-    {
+  if (!_dbus_string_find_eol (source, 0, &eol, &eol_len))
       eol = _dbus_string_get_length (source);
-      have_newline = FALSE;
-    }
 
   if (eol == 0)
     return FALSE; /* eof */
   
-  if (!_dbus_string_move_len (source, 0, eol,
-                              dest, 0))
-    {
-      return FALSE;
-    }
-
-  /* dump the newline and the \r if we have one */
-  if (have_newline)
-    {
-      dbus_bool_t have_cr;
-      
-      _dbus_assert (_dbus_string_get_length (dest) > 0);
-
-      if (_dbus_string_get_length (dest) > 1 &&
-          _dbus_string_get_byte (dest,
-                                 _dbus_string_get_length (dest) - 2) == '\r')
-        have_cr = TRUE;
-      else
-        have_cr = FALSE;
-        
-      _dbus_string_set_length (dest,
-                               _dbus_string_get_length (dest) -
-                               (have_cr ? 2 : 1));
-    }
-  
-  return TRUE;
+  return _dbus_string_move_len (source, 0, eol, dest, 0);
 }
 
 #ifdef DBUS_BUILD_TESTS
Index: dbus/dbus-string.h
===================================================================
--- dbus/dbus-string.h	(Revision 206)
+++ dbus/dbus-string.h	(Arbeitskopie)
@@ -215,6 +215,10 @@
                                                   int                start,
                                                   const char        *substr,
                                                   int               *found);
+dbus_bool_t   _dbus_string_find_eol               (const DBusString *str,
+                                                  int               start,
+                                                  int               *found,
+                                                  int               *found_len);
 dbus_bool_t   _dbus_string_find_to               (const DBusString  *str,
                                                   int                start,
                                                   int                end,
Index: dbus/dbus-server-unix.c
===================================================================
--- dbus/dbus-server-unix.c	(Revision 206)
+++ dbus/dbus-server-unix.c	(Arbeitskopie)
@@ -27,12 +27,16 @@
 #include "dbus-connection-internal.h"
 #include "dbus-string.h"
 #include <sys/types.h>
+#ifdef DBUS_WIN
+#include "dbus-sockets-win.h"
+#else
 #include <unistd.h>
+#endif
 
 /**
- * @defgroup DBusServerUnix DBusServer implementations for UNIX
+ * @defgroup DBusServerUnix DBusServer implementations for UNIX and Winsock
  * @ingroup  DBusInternals
- * @brief Implementation details of DBusServer on UNIX
+ * @brief Implementation details of DBusServer on UNIX and Winsock
  *
  * @{
  */
@@ -102,7 +106,7 @@
   transport = _dbus_transport_new_for_fd (client_fd, &server->guid_hex, NULL);
   if (transport == NULL)
     {
-      close (client_fd);
+      _dbus_close (client_fd, NULL);
       SERVER_UNLOCK (server);
       return FALSE;
     }
@@ -219,7 +223,7 @@
       unix_server->watch = NULL;
     }
   
-  close (unix_server->fd);
+  _dbus_close (unix_server->fd, NULL);
   unix_server->fd = -1;
 
   if (unix_server->socket_name != NULL)
@@ -303,6 +307,8 @@
   return (DBusServer*) unix_server;
 }
 
+#ifndef DBUS_WIN
+
 /**
  * Creates a new server listening on the given Unix domain socket.
  *
@@ -382,11 +388,94 @@
   return NULL;
 }
 
+#else /* ifndef DBUS_WIN */
+
 /**
- * Creates a new server listening on the given hostname and port.
- * If the hostname is NULL, listens on localhost.
+ * Creates a new server listening on the given Windows named pipe.
  *
- * @param host the hostname to listen on.
+ * @param path the path for the domain socket.
+ * @param abstract #TRUE to use abstract socket namespace
+ * @param error location to store reason for failure.
+ * @returns the new server, or #NULL on failure.
+ */
+DBusServer*
+_dbus_server_new_for_domain_socket (const char     *path,
+                                    dbus_bool_t     abstract,
+                                    DBusError      *error)
+{
+  DBusServer *server;
+  DBusServerUnix *unix_server;
+  int listen_fd;
+  DBusString address;
+  char *path_copy;
+  
+  _DBUS_ASSERT_ERROR_IS_CLEAR (error);
+
+  if (!_dbus_string_init (&address))
+    {
+      _DBUS_SET_OOM (error);
+      return NULL;
+    }
+
+  if ((abstract &&
+       !_dbus_string_append (&address, "unix:abstract=")) ||
+      (!abstract &&
+       !_dbus_string_append (&address, "unix:path=")) ||
+      !_dbus_string_append (&address, path))
+    {
+      _DBUS_SET_OOM (error);
+      goto failed_0;
+    }
+
+  path_copy = _dbus_strdup (path);
+  if (path_copy == NULL)
+    {
+      _DBUS_SET_OOM (error);
+      goto failed_0;
+    }
+  
+  listen_fd = _dbus_listen_unix_socket (path, abstract, error);
+  
+  if (listen_fd < 0)
+    {
+      _DBUS_ASSERT_ERROR_IS_SET (error);
+      goto failed_1;
+    }
+  
+  _dbus_fd_set_close_on_exec (listen_fd);
+  server = _dbus_server_new_for_fd (listen_fd, &address);
+  if (server == NULL)
+    {
+      _DBUS_SET_OOM (error);
+      goto failed_2;
+    }
+
+  unix_server = (DBusServerUnix*) server;
+  unix_server->socket_name = path_copy;
+  
+  _dbus_string_free (&address);
+  
+  return server;
+
+ failed_2:
+  _dbus_close (listen_fd, NULL);
+ failed_1:
+  dbus_free (path_copy);
+ failed_0:
+  _dbus_string_free (&address);
+
+  return NULL;
+}
+
+#endif /* ifndef DBUS_WIN */
+
+
+/**
+ * Creates a new server listening on the given hostname and port.  If
+ * the hostname is NULL, listens on localhost. If the hostname is an
+ * empty string, listens on any local host address.
+ *
+ * @param host the hostname for the address to listen.
  * @param port the port to listen on.
  * @param error location to store reason for failure.
  * @returns the new server, or #NULL on failure.
@@ -436,7 +525,7 @@
   if (server == NULL)
     {
       dbus_set_error (error, DBUS_ERROR_NO_MEMORY, NULL);
-      close (listen_fd);
+      _dbus_close (listen_fd, NULL);
       _dbus_string_free (&address);
       return NULL;
     }
Index: dbus/dbus-test.c
===================================================================
--- dbus/dbus-test.c	(Revision 206)
+++ dbus/dbus-test.c	(Arbeitskopie)
@@ -154,7 +154,9 @@
   
   run_test ("hash", specific_test, _dbus_hash_test);
 
+#ifndef DBUS_WIN
   run_data_test ("spawn", specific_test, _dbus_spawn_test, test_data_dir);
+#endif
   
   run_data_test ("userdb", specific_test, _dbus_userdb_test, test_data_dir);
   
Index: dbus/dbus-spawn.c
===================================================================
--- dbus/dbus-spawn.c	(Revision 206)
+++ dbus/dbus-spawn.c	(Arbeitskopie)
@@ -1021,6 +1021,7 @@
  *
  * @param sitter_p return location for babysitter or #NULL
  * @param argv the executable and arguments
+ * @param env the environment (not used on unix yet)
  * @param child_setup function to call in child pre-exec()
  * @param user_data user data for setup function
  * @param error error object to be filled in if function fails
@@ -1029,6 +1030,7 @@
 dbus_bool_t
 _dbus_spawn_async_with_babysitter (DBusBabysitter          **sitter_p,
                                    char                    **argv,
+                                   char                    **env,
                                    DBusSpawnChildSetupFunc   child_setup,
                                    void                     *user_data,
                                    DBusError                *error)
@@ -1216,7 +1218,7 @@
   
   argv[0] = "/this/does/not/exist/32542sdgafgafdg";
   if (_dbus_spawn_async_with_babysitter (&sitter, argv,
-                                         NULL, NULL,
+                                         NULL, NULL, NULL,
                                          &error))
     {
       _dbus_babysitter_block_for_child_exit (sitter);
@@ -1261,7 +1263,7 @@
   
   argv[0] = TEST_SEGFAULT_BINARY;
   if (_dbus_spawn_async_with_babysitter (&sitter, argv,
-                                         NULL, NULL,
+                                         NULL, NULL, NULL,
                                          &error))
     {
       _dbus_babysitter_block_for_child_exit (sitter);
@@ -1306,7 +1308,7 @@
   
   argv[0] = TEST_EXIT_BINARY;
   if (_dbus_spawn_async_with_babysitter (&sitter, argv,
-                                         NULL, NULL,
+                                         NULL, NULL, NULL,
                                          &error))
     {
       _dbus_babysitter_block_for_child_exit (sitter);
@@ -1351,7 +1353,7 @@
 
   argv[0] = TEST_SLEEP_FOREVER_BINARY;
   if (_dbus_spawn_async_with_babysitter (&sitter, argv,
-                                         NULL, NULL,
+                                         NULL, NULL, NULL,
                                          &error))
     {
       _dbus_babysitter_kill_child (sitter);
Index: dbus/dbus-spawn.h
===================================================================
--- dbus/dbus-spawn.h	(Revision 206)
+++ dbus/dbus-spawn.h	(Arbeitskopie)
@@ -37,6 +37,7 @@
 
 dbus_bool_t _dbus_spawn_async_with_babysitter     (DBusBabysitter           **sitter_p,
                                                    char                     **argv,
+                                                   char                     **env,
                                                    DBusSpawnChildSetupFunc    child_setup,
                                                    void                      *user_data,
                                                    DBusError                 *error);
Index: dbus/dbus-sysdeps-util.c
===================================================================
--- dbus/dbus-sysdeps-util.c	(Revision 206)
+++ dbus/dbus-sysdeps-util.c	(Arbeitskopie)
@@ -81,7 +81,28 @@
   DBusString str;
   double val;
   int pos;
-  
+
+#ifdef DBUS_WIN
+  check_dirname ("foo\\bar", "foo");
+  check_dirname ("foo\\\\bar", "foo");
+  check_dirname ("foo/\\/bar", "foo");
+  check_dirname ("foo\\bar/", "foo");
+  check_dirname ("foo//bar\\", "foo");
+  check_dirname ("foo\\bar/", "foo");
+  check_dirname ("foo/bar\\\\", "foo");
+  check_dirname ("\\foo", "\\");
+  check_dirname ("\\\\foo", "\\");
+  check_dirname ("\\", "\\");
+  check_dirname ("\\\\", "\\");
+  check_dirname ("\\/", "\\");
+  check_dirname ("/\\/", "/");
+  check_dirname ("c:\\foo\\bar", "c:\\foo");
+  check_dirname ("c:\\foo", "c:\\");
+  check_dirname ("c:/foo", "c:/");
+  check_dirname ("c:\\", "c:\\");
+  check_dirname ("c:/", "c:/");
+  check_dirname ("", ".");  
+#else  
   check_dirname ("foo", ".");
   check_dirname ("foo/bar", "foo");
   check_dirname ("foo//bar", "foo");
@@ -100,8 +121,8 @@
   check_dirname ("/", "/");
   check_dirname ("///", "/");
   check_dirname ("", ".");  
+#endif
 
-
   _dbus_string_init_const (&str, "3.5");
   if (!_dbus_string_parse_double (&str,
 				  0, &val, &pos))
@@ -137,12 +158,27 @@
       _dbus_warn ("_dbus_string_parse_double of \"0xff\" returned wrong position %d", pos);
       exit (1);
     }
-  
+#ifdef DBUS_WIN
+  check_path_absolute ("c:/", TRUE);
+  check_path_absolute ("c:/foo", TRUE);
+  check_path_absolute ("", FALSE);
+  check_path_absolute ("foo", FALSE);
+  check_path_absolute ("foo/bar", FALSE);
+  check_path_absolute ("", FALSE);
+  check_path_absolute ("foo\\bar", FALSE);
+  check_path_absolute ("c:\\", TRUE);
+  check_path_absolute ("c:\\foo", TRUE);
+  check_path_absolute ("c:", TRUE);
+  check_path_absolute ("c:\\foo\\bar", TRUE);
+  check_path_absolute ("\\", TRUE);
   check_path_absolute ("/", TRUE);
+#else  
+  check_path_absolute ("/", TRUE);
   check_path_absolute ("/foo", TRUE);
   check_path_absolute ("", FALSE);
   check_path_absolute ("foo", FALSE);
   check_path_absolute ("foo/bar", FALSE);
+#endif
   
   return TRUE;
 }
Index: dbus/dbus-transport-unix.c
===================================================================
--- dbus/dbus-transport-unix.c	(Revision 206)
+++ dbus/dbus-transport-unix.c	(Arbeitskopie)
@@ -26,6 +26,9 @@
 #include "dbus-transport-unix.h"
 #include "dbus-transport-protected.h"
 #include "dbus-watch.h"
+#ifdef DBUS_WIN
+#include "dbus-sockets-win.h"
+#endif
 
 
 /**
Index: dbus/dbus-sysdeps.c
===================================================================
--- dbus/dbus-sysdeps.c	(Revision 206)
+++ dbus/dbus-sysdeps.c	(Arbeitskopie)
@@ -3,6 +3,7 @@
  * 
  * Copyright (C) 2002, 2003  Red Hat, Inc.
  * Copyright (C) 2003 CodeFactory AB
+ * Copyright (C) 2005 Novell, Inc.
  *
  * Licensed under the Academic Free License version 2.1
  * 
@@ -31,23 +32,31 @@
 #include <stdlib.h>
 #include <string.h>
 #include <signal.h>
-#include <unistd.h>
 #include <stdio.h>
 #include <errno.h>
 #include <fcntl.h>
+
+#ifdef DBUS_WIN
+#include "dbus-sysdeps-win.h"
+#include "dbus-hash.h"
+#include "dbus-sockets-win.h"
+#else
+#include <unistd.h>
 #include <sys/socket.h>
 #include <dirent.h>
 #include <sys/un.h>
 #include <pwd.h>
-#include <time.h>
-#include <locale.h>
 #include <sys/time.h>
-#include <sys/stat.h>
 #include <sys/wait.h>
 #include <netinet/in.h>
 #include <netdb.h>
 #include <grp.h>
+#endif
 
+#include <time.h>
+#include <locale.h>
+#include <sys/stat.h>
+
 #ifdef HAVE_WRITEV
 #include <sys/uio.h>
 #endif
@@ -72,11 +81,19 @@
 _DBUS_DEFINE_GLOBAL_LOCK (win_fds);
 _DBUS_DEFINE_GLOBAL_LOCK (sid_atom_cache);
 
+#ifndef DBUS_WIN
+#define _dbus_decapsulate_quick(i)       (i)
+#define DBUS_SOCKET_IS_INVALID(s)        ((s) < 0)
+#define DBUS_SOCKET_API_RETURNS_ERROR(n) ((n) < 0)
+#define DBUS_SOCKET_SET_ERRNO()          /* empty */
+#define DBUS_CLOSE_SOCKET(s)             close(s)
+#endif
+
 /**
  * @addtogroup DBusInternalsUtils
  * @{
  */
-#ifndef DBUS_DISABLE_ASSERT
+#if !defined(DBUS_DISABLE_ASSERT) && !defined(DBUS_WIN)
 /**
  * Aborts the program with SIGABRT (dumping core).
  */
@@ -89,6 +106,10 @@
   if (s && *s)
     _dbus_print_backtrace ();
 #endif
+#if defined (DBUS_WIN) && defined (__GNUC__)
+  if (IsDebuggerPresent ())
+    __asm__ __volatile__ ("int $03");
+#endif
   abort ();
   _exit (1); /* in case someone manages to ignore SIGABRT */
 }
@@ -126,11 +147,18 @@
        * will get upset about.
        */
       
+#ifdef DBUS_WIN
+      putenv_value = malloc (len + 2);
+#else
       putenv_value = malloc (len + 1);
+#endif
       if (putenv_value == NULL)
         return FALSE;
 
       strcpy (putenv_value, varname);
+#ifdef DBUS_WIN
+      strcat (putenv_value, "=");
+#endif
       
       return (putenv (putenv_value) == 0);
 #endif
@@ -197,6 +225,9 @@
             DBusString       *buffer,
             int               count)
 {
+#ifdef DBUS_WIN
+  return _dbus_read_win (fd, buffer, count);
+#else
   int bytes_read;
   int start;
   char *data;
@@ -240,6 +271,7 @@
       
       return bytes_read;
     }
+#endif
 }
 
 /**
@@ -258,6 +290,9 @@
              int               start,
              int               len)
 {
+#ifdef DBUS_WIN
+  return _dbus_write_win (fd, buffer, start, len);
+#else
   const char *data;
   int bytes_written;
   
@@ -276,6 +311,7 @@
 #endif
   
   return bytes_written;
+#endif
 }
 
 /**
@@ -313,6 +349,10 @@
   _dbus_assert (len1 >= 0);
   _dbus_assert (len2 >= 0);
   
+#ifdef DBUS_WIN
+  return _dbus_write_two_win(fd, buffer1, start1, len1, buffer2, start2, len2);
+#else
+
 #ifdef HAVE_WRITEV
   {
     struct iovec vectors[2];
@@ -364,6 +404,8 @@
       return ret1;
   }
 #endif /* !HAVE_WRITEV */   
+
+#endif
 }
 
 #define _DBUS_MAX_SUN_PATH_LENGTH 99
@@ -386,6 +428,10 @@
  * given path.  The connection fd is returned, and is set up as
  * nonblocking.
  * 
+ * On Windows there are no UNIX domain sockets. Instead, connects to a
+ * localhost-bound TCP socket, whose port number is stored in a file
+ * at the given path.
+ * 
  * Uses abstract sockets instead of filesystem-linked sockets if
  * requested (it's possible only on Linux; see "man 7 unix" on Linux).
  * On non-Linux abstract socket usage always fails.
@@ -400,6 +446,10 @@
                            dbus_bool_t     abstract,
                            DBusError      *error)
 {
+#ifdef DBUS_WIN
+  return _dbus_connect_unix_socket_win(path, abstract, error);
+#else
+
   int fd;
   size_t path_len;
   struct sockaddr_un addr;  
@@ -485,6 +535,7 @@
     }
 
   return fd;
+#endif
 }
 
 /**
@@ -507,6 +558,10 @@
                           dbus_bool_t     abstract,
                           DBusError      *error)
 {
+#ifdef DBUS_WIN
+  return _dbus_listen_unix_socket_win(path, abstract,error);
+#else
+
   int listen_fd;
   struct sockaddr_un addr;
   size_t path_len;
@@ -620,6 +675,7 @@
                 path);
   
   return listen_fd;
+#endif
 }
 
 /**
@@ -627,7 +683,7 @@
  * and port. The connection fd is returned, and is set up as
  * nonblocking.
  *
- * @param host the host name to connect to
+ * @param host the host name to connect to, NULL for loopback
  * @param port the prot to connect to
  * @param error return location for error code
  * @returns connection file descriptor or -1 on error
@@ -641,13 +697,21 @@
   struct sockaddr_in addr;
   struct hostent *he;
   struct in_addr *haddr;
+#ifdef DBUS_WIN
+  struct in_addr ina;
+#endif
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
   
+#ifdef DBUS_WIN
+  _dbus_win_startup_winsock ();
+#endif
+
   fd = socket (AF_INET, SOCK_STREAM, 0);
   
-  if (fd < 0)
+  if (DBUS_SOCKET_IS_INVALID (fd))
     {
+      DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error,
                       _dbus_error_from_errno (errno),
                       "Failed to create socket: %s",
@@ -657,16 +721,23 @@
     }
 
   if (host == NULL)
+    {
     host = "localhost";
+#ifdef DBUS_WIN
+      ina.s_addr = htonl (INADDR_LOOPBACK);
+      haddr = &ina;
+#endif
+    }
 
   he = gethostbyname (host);
   if (he == NULL) 
     {
+      DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error,
                       _dbus_error_from_errno (errno),
                       "Failed to lookup hostname: %s",
                       host);
-      close (fd);
+      DBUS_CLOSE_SOCKET (fd);
       return -1;
     }
   
@@ -677,22 +748,26 @@
   addr.sin_family = AF_INET;
   addr.sin_port = htons (port);
   
-  if (connect (fd, (struct sockaddr*) &addr, sizeof (addr)) < 0)
+  if (DBUS_SOCKET_API_RETURNS_ERROR
+     (connect (fd, (struct sockaddr*) &addr, sizeof (addr)) < 0))
     {      
+      DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error,
                        _dbus_error_from_errno (errno),
                       "Failed to connect to socket %s:%d %s",
                       host, port, _dbus_strerror (errno));
 
-      close (fd);
+      DBUS_CLOSE_SOCKET (fd);
       fd = -1;
       
       return -1;
     }
 
+  fd = _dbus_encapsulate_socket (fd);
+
   if (!_dbus_set_fd_nonblocking (fd, error))
     {
-      close (fd);
+      _dbus_close (fd, NULL);
       fd = -1;
 
       return -1;
@@ -702,12 +777,12 @@
 }
 
 /**
- * Creates a socket and binds it to the given path,
+ * Creates a socket and binds it to the given port,
  * then listens on the socket. The socket is
  * set to be nonblocking. 
  *
- * @param host the host name to listen on
- * @param port the prot to listen on
+ * @param host the interface to listen on, NULL for loopback, empty for any
+ * @param port the port to listen on
  * @param error return location for errors
  * @returns the listening file descriptor or -1 on error
  */
@@ -720,31 +795,58 @@
   struct sockaddr_in addr;
   struct hostent *he;
   struct in_addr *haddr;
+#ifdef DBUS_WIN
+  struct in_addr ina;
+#endif
 
+
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
   
+#ifdef DBUS_WIN
+  _dbus_win_startup_winsock ();
+#endif
+
   listen_fd = socket (AF_INET, SOCK_STREAM, 0);
   
-  if (listen_fd < 0)
+  if (DBUS_SOCKET_IS_INVALID (listen_fd))
     {
+      DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error, _dbus_error_from_errno (errno),
                       "Failed to create socket \"%s:%d\": %s",
                       host, port, _dbus_strerror (errno));
       return -1;
     }
-
+#ifdef DBUS_WIN
+  if (host == NULL)
+    {
+      host = "localhost";
+      ina.s_addr = htonl (INADDR_LOOPBACK);
+      haddr = &ina;
+    }
+  else if (!host[0])
+    {
+      ina.s_addr = htonl (INADDR_ANY);
+      haddr = &ina;
+    }
+  else
+    {
+#endif
   he = gethostbyname (host);
   if (he == NULL) 
     {
+      DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error,
                       _dbus_error_from_errno (errno),
                       "Failed to lookup hostname: %s",
                       host);
-      close (listen_fd);
+      DBUS_CLOSE_SOCKET (listen_fd);
       return -1;
     }
   
   haddr = ((struct in_addr *) (he->h_addr_list)[0]);
+#ifdef DBUS_WIN
+  }
+#endif
 
   _DBUS_ZERO (addr);
   memcpy (&addr.sin_addr, haddr, sizeof (struct in_addr));
@@ -753,25 +855,29 @@
 
   if (bind (listen_fd, (struct sockaddr*) &addr, sizeof (struct sockaddr)))
     {
+      DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error, _dbus_error_from_errno (errno),
                       "Failed to bind socket \"%s:%d\": %s",
                       host, port, _dbus_strerror (errno));
-      close (listen_fd);
+      DBUS_CLOSE_SOCKET (listen_fd);
       return -1;
     }
 
-  if (listen (listen_fd, 30 /* backlog */) < 0)
+  if (DBUS_SOCKET_API_RETURNS_ERROR (listen (listen_fd, 30 /* backlog */)))
     {
+      DBUS_SOCKET_SET_ERRNO ();
       dbus_set_error (error, _dbus_error_from_errno (errno),  
                       "Failed to listen on socket \"%s:%d\": %s",
                       host, port, _dbus_strerror (errno));
-      close (listen_fd);
+      DBUS_CLOSE_SOCKET (listen_fd);
       return -1;
     }
 
+  listen_fd = _dbus_encapsulate_socket (listen_fd);
+
   if (!_dbus_set_fd_nonblocking (listen_fd, error))
     {
-      close (listen_fd);
+      _dbus_close (listen_fd, NULL);
       return -1;
     }
   
@@ -782,6 +888,33 @@
 write_credentials_byte (int             server_fd,
                         DBusError      *error)
 {
+#ifdef DBUS_WIN
+  /* FIXME: for the session bus credentials shouldn't matter (?), but
+   * for the system bus they are presumably essential. A rough outline
+   * of a way to implement the credential transfer would be this:
+   *
+   * client waits to *read* a byte.
+   *
+   * server creates a named pipe with a random name, sends a byte
+   * contining its length, and its name.
+   *
+   * client reads the name, connects to it (using Win32 API).
+   *
+   * server waits for connection to the named pipe, then calls
+   * ImpersonateNamedPipeClient(), notes its now-current credentials,
+   * calls RevertToSelf(), closes its handles to the named pipe, and
+   * is done. (Maybe there is some other way to get the SID of a named
+   * pipe client without having to use impersonation?)
+   *
+   * client closes its handles and is done.
+   *
+   */
+
+  return TRUE;
+
+#else
+
+
   int bytes_written;
   char buf[1] = { '\0' };
 #if defined(HAVE_CMSGCRED) && !defined(LOCAL_CREDS)
@@ -841,6 +974,8 @@
       _dbus_verbose ("wrote credentials byte\n");
       return TRUE;
     }
+
+#endif
 }
 
 /**
@@ -866,6 +1001,8 @@
                                      DBusCredentials *credentials,
                                      DBusError       *error)
 {
+#ifndef DBUS_WIN
+
   struct msghdr msg;
   struct iovec iov;
   char buf;
@@ -1005,6 +1142,15 @@
 		 credentials->gid);
     
   return TRUE;
+
+#else
+
+  /* FIXME bogus testing credentials */
+  _dbus_credentials_from_current_process (credentials);
+
+  return TRUE;
+
+#endif
 }
 
 /**
@@ -1052,16 +1198,23 @@
 
   addrlen = sizeof (addr);
   
+#ifndef DBUS_WIN
  retry:
+#endif
   client_fd = accept (listen_fd, &addr, &addrlen);
   
-  if (client_fd < 0)
+  if (DBUS_SOCKET_IS_INVALID (client_fd))
     {
+      DBUS_SOCKET_SET_ERRNO ();
+#ifndef DBUS_WIN
       if (errno == EINTR)
         goto retry;
+#else
+      client_fd = -1;
+#endif
     }
   
-  return client_fd;
+  return _dbus_encapsulate_socket (client_fd);
 }
 
 /** @} */
@@ -1241,6 +1394,7 @@
 	
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
     
+#ifndef DBUS_WIN    
   directory = _dbus_string_get_const_data (dir);
 	
   if (stat (directory, &sb) < 0)
@@ -1258,7 +1412,7 @@
                      "%s directory is not private to the user", directory);
       return FALSE;
     }
-    
+#endif    
   return TRUE;
 }
 
@@ -1342,6 +1496,10 @@
 ascii_strtod (const char *nptr,
 	      char      **endptr)
 {
+  /* FIXME: The Win32 C library's strtod() doesn't handle hex.
+   * Presumably many Unixes don't either.
+   */
+
   char *fail_pos;
   double val;
   struct lconv *locale_data;
@@ -1510,6 +1668,9 @@
  * @addtogroup DBusInternalsUtils
  * @{
  */
+
+#ifndef DBUS_WIN
+
 static dbus_bool_t
 fill_user_info_from_passwd (struct passwd *p,
                             DBusUserInfo  *info,
@@ -1532,6 +1693,7 @@
 
   return TRUE;
 }
+#endif
 
 static dbus_bool_t
 fill_user_info (DBusUserInfo       *info,
@@ -1557,6 +1719,7 @@
   else
     username_c = NULL;
 
+#ifndef DBUS_WIN
   /* For now assuming that the getpwnam() and getpwuid() flavors
    * are always symmetrical, if not we have to add more configure
    * checks
@@ -1707,8 +1870,36 @@
  failed:
   _DBUS_ASSERT_ERROR_IS_SET (error);
   return FALSE;
+
+#else  /* DBUS_WIN */
+
+  if (uid != DBUS_UID_UNSET)
+    {
+      if (!fill_win_user_info_from_uid (uid, info, error)) {
+      	_dbus_verbose("%s after fill_win_user_info_from_uid\n",__FUNCTION__);
+      return FALSE;
+    }
+    }
+  else
+    {
+      wchar_t *wname = _dbus_win_utf8_to_utf16 (username_c, error);
+      
+      if (!wname)
+	return FALSE;
+      
+    if (!fill_win_user_info_from_name (wname, info, error))
+	  {
+	    dbus_free (wname);
+	    return FALSE;
+	  }
+    dbus_free (wname);
+    }
+
+  return TRUE;
+#endif  /* DBUS_WIN */
 }
 
+
 /**
  * Gets user info for the given username.
  *
@@ -1756,7 +1947,7 @@
   dbus_free (info->homedir);
 }
 
-/**
+ /**
  * Frees the members of info (but not info itself).
  *
  * @param info the group info
@@ -1789,6 +1980,7 @@
 void
 _dbus_credentials_from_current_process (DBusCredentials *credentials)
 {
+#ifndef DBUS_WIN
   /* The POSIX spec certainly doesn't promise this, but
    * we need these assertions to fail as soon as we're wrong about
    * it so we can do the porting fixups
@@ -1796,10 +1988,11 @@
   _dbus_assert (sizeof (pid_t) <= sizeof (credentials->pid));
   _dbus_assert (sizeof (uid_t) <= sizeof (credentials->uid));
   _dbus_assert (sizeof (gid_t) <= sizeof (credentials->gid));
+#endif
   
-  credentials->pid = getpid ();
-  credentials->uid = getuid ();
-  credentials->gid = getgid ();
+  credentials->pid = _dbus_getpid ();
+  credentials->uid = _dbus_getuid ();
+  credentials->gid = _dbus_getgid ();
 }
 
 /**
@@ -1833,7 +2026,11 @@
 unsigned long
 _dbus_getpid (void)
 {
+#ifndef DBUS_WIN
   return getpid ();
+#else
+  return GetCurrentProcessId ();
+#endif
 }
 
 /** Gets our UID
@@ -1842,7 +2039,11 @@
 dbus_uid_t
 _dbus_getuid (void)
 {
+#ifdef DBUS_WIN
+  return _dbus_getuid_win ();
+#else
   return getuid ();
+#endif
 }
 
 #ifdef DBUS_BUILD_TESTS
@@ -1852,7 +2053,11 @@
 dbus_gid_t
 _dbus_getgid (void)
 {
+#ifdef DBUS_WIN
+  return _dbus_getgid_win ();
+#else
   return getgid ();
+#endif 
 }
 #endif
 
@@ -1934,6 +2139,9 @@
             int         n_fds,
             int         timeout_milliseconds)
 {
+#ifdef DBUS_WIN
+	return _dbus_poll_win (fds, n_fds, timeout_milliseconds);
+#else
 #ifdef HAVE_POLL
   /* This big thing is a constant expression and should get optimized
    * out of existence. So it's more robust than a configure check at
@@ -2019,8 +2227,10 @@
 
   return ready;
 #endif
+#endif /* DBUS_WIN */
 }
 
+
 /** nanoseconds in a second */
 #define NANOSECONDS_PER_SECOND       1000000000
 /** microseconds in a second */
@@ -2039,6 +2249,7 @@
 void
 _dbus_sleep_milliseconds (int milliseconds)
 {
+#ifndef DBUS_WIN
 #ifdef HAVE_NANOSLEEP
   struct timespec req;
   struct timespec rem;
@@ -2055,18 +2266,22 @@
 #else /* ! HAVE_USLEEP */
   sleep (MAX (milliseconds / 1000, 1));
 #endif
+#else  /* DBUS_WIN */
+  Sleep (milliseconds);
+#endif /* !DBUS_WIN */
 }
 
 /**
  * Get current time, as in gettimeofday().
  *
  * @param tv_sec return location for number of seconds
- * @param tv_usec return location for number of microseconds (thousandths)
+ * @param tv_usec return location for number of microseconds
  */
 void
 _dbus_get_current_time (long *tv_sec,
                         long *tv_usec)
 {
+#ifndef DBUS_WIN
   struct timeval t;
 
   gettimeofday (&t, NULL);
@@ -2075,6 +2290,24 @@
     *tv_sec = t.tv_sec;
   if (tv_usec)
     *tv_usec = t.tv_usec;
+#else
+  FILETIME ft;
+  dbus_uint64_t *time64 = (dbus_uint64_t *) &ft;
+
+  GetSystemTimeAsFileTime (&ft);
+
+  /* Convert from 100s of nanoseconds since 1601-01-01
+   * to Unix epoch. Yes, this is Y2038 unsafe.
+   */
+  *time64 -= DBUS_INT64_CONSTANT (116444736000000000);
+  *time64 /= 10;
+
+  if (tv_sec)
+    *tv_sec = *time64 / 1000000;
+
+  if (tv_usec)
+    *tv_usec = *time64 % 1000000;
+#endif
 }
 
 /**
@@ -2102,7 +2335,7 @@
   
   filename_c = _dbus_string_get_const_data (filename);
   
-  /* O_BINARY useful on Cygwin */
+  /* O_BINARY useful on Cygwin and Win32 */
   fd = open (filename_c, O_RDONLY | O_BINARY);
   if (fd < 0)
     {
@@ -2142,10 +2375,11 @@
   if (sb.st_size > 0 && S_ISREG (sb.st_mode))
     {
       int bytes_read;
+      const int encapsulated_fd = _dbus_encapsulate_fd (fd);
 
       while (total < (int) sb.st_size)
         {
-          bytes_read = _dbus_read (fd, str,
+          bytes_read = _dbus_read (encapsulated_fd, str,
                                    sb.st_size - total);
           if (bytes_read <= 0)
             {
@@ -2157,7 +2391,7 @@
               _dbus_verbose ("read() failed: %s",
                              _dbus_strerror (errno));
               
-              close (fd);
+              _dbus_close (encapsulated_fd, NULL);
               _dbus_string_set_length (str, orig_len);
               return FALSE;
             }
@@ -2165,7 +2399,7 @@
             total += bytes_read;
         }
 
-      close (fd);
+      _dbus_close (encapsulated_fd, NULL);
       return TRUE;
     }
   else if (sb.st_size != 0)
@@ -2254,6 +2488,8 @@
       goto out;
     }
 
+  fd = _dbus_encapsulate_fd (fd);
+
   need_unlink = TRUE;
   
   total = 0;
@@ -2278,7 +2514,7 @@
       total += bytes_written;
     }
 
-  if (close (fd) < 0)
+  if (_dbus_close (fd, NULL) < 0)
     {
       dbus_set_error (error, _dbus_error_from_errno (errno),
                       "Could not close file %s: %s",
@@ -2289,7 +2525,11 @@
 
   fd = -1;
   
-  if (rename (tmp_filename_c, filename_c) < 0)
+  if (
+#ifdef DBUS_WIN
+      (unlink (filename_c) == -1 && errno != ENOENT) ||
+#endif
+      rename (tmp_filename_c, filename_c) < 0)
     {
       dbus_set_error (error, _dbus_error_from_errno (errno),
                       "Could not rename %s to %s: %s",
@@ -2309,7 +2549,7 @@
    */
 
   if (fd >= 0)
-    close (fd);
+    _dbus_close (fd, NULL);
         
   if (need_unlink && unlink (tmp_filename_c) < 0)
     _dbus_verbose ("Failed to unlink temp file %s: %s\n",
@@ -2447,6 +2687,7 @@
       _dbus_string_get_length (next_component) == 0)
     return TRUE;
   
+#ifndef DBUS_WIN
   dir_ends_in_slash = '/' == _dbus_string_get_byte (dir,
                                                     _dbus_string_get_length (dir) - 1);
 
@@ -2461,7 +2702,26 @@
       if (!_dbus_string_append_byte (dir, '/'))
         return FALSE;
     }
+#else
+  dir_ends_in_slash =
+    ('/' == _dbus_string_get_byte (dir, _dbus_string_get_length (dir) - 1) ||
+     '\\' == _dbus_string_get_byte (dir, _dbus_string_get_length (dir) - 1));
 
+  file_starts_with_slash =
+     ('/' == _dbus_string_get_byte (next_component, 0) ||
+      '\\' == _dbus_string_get_byte (next_component, 0));
+
+  if (dir_ends_in_slash && file_starts_with_slash)
+    {
+      _dbus_string_shorten (dir, 1);
+    }
+  else if (!(dir_ends_in_slash || file_starts_with_slash))
+    {
+      if (!_dbus_string_append_byte (dir, '\\'))
+        return FALSE;
+    }
+#endif
+
   return _dbus_string_copy (next_component, 0, dir,
                             _dbus_string_get_length (dir));
 }
@@ -2568,14 +2828,18 @@
   old_len = _dbus_string_get_length (str);
   fd = -1;
 
+#ifndef DBUS_WIN
   /* note, urandom on linux will fall back to pseudorandom */
   fd = open ("/dev/urandom", O_RDONLY);
+#endif
+
   if (fd < 0)
     return pseudorandom_generate_random_bytes (str, n_bytes);
 
+#ifndef DBUS_WIN
   if (_dbus_read (fd, str, n_bytes) != n_bytes)
     {
-      close (fd);
+      _dbus_close (fd, NULL);
       _dbus_string_set_length (str, old_len);
       return pseudorandom_generate_random_bytes (str, n_bytes);
     }
@@ -2586,6 +2850,10 @@
   close (fd);
   
   return TRUE;
+#else
+  _dbus_assert_not_reached ("_dbus_generate_random_bytes fails");
+  return FALSE;
+#endif
 }
 
 /**
@@ -2635,6 +2903,7 @@
 const char*
 _dbus_strerror (int error_number)
 {
+#ifndef DBUS_WIN
   const char *msg;
   
   msg = strerror (error_number);
@@ -2642,6 +2911,9 @@
     msg = "unknown";
 
   return msg;
+#else
+  return _dbus_strerror_win(error_number);
+#endif
 }
 
 /**
@@ -2650,7 +2922,9 @@
 void
 _dbus_disable_sigpipe (void)
 {
+#ifndef DBUS_WIN
   signal (SIGPIPE, SIG_IGN);
+#endif
 }
 
 /**
@@ -2663,6 +2937,9 @@
 void
 _dbus_fd_set_close_on_exec (int fd)
 {
+#ifdef DBUS_WIN
+  _dbus_fd_set_close_on_exec_win(fd);
+#else
   int val;
   
   val = fcntl (fd, F_GETFD, 0);
@@ -2673,15 +2950,16 @@
   val |= FD_CLOEXEC;
   
   fcntl (fd, F_SETFD, val);
+#endif
 }
 
 /**
- * Converts a UNIX errno into a #DBusError name.
+ * Converts a UNIX errno or a Winsock error code into a #DBusError name.
  *
  * @todo should cover more errnos, specifically those
  * from open().
  * 
- * @param error_number the errno.
+ * @param error_number the errno or Winsock error code.
  * @returns an error name
  */
 const char*
@@ -2795,6 +3073,10 @@
 _dbus_close (int        fd,
              DBusError *error)
 {
+#ifdef DBUS_WIN
+  return _dbus_close_win (fd, error);
+#else
+
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
   
  again:
@@ -2809,6 +3091,7 @@
     }
 
   return TRUE;
+#endif
 }
 
 /**
@@ -2822,6 +3105,9 @@
 _dbus_set_fd_nonblocking (int             fd,
                           DBusError      *error)
 {
+#ifdef DBUS_WIN
+  return _dbus_set_fd_nonblocking_win(fd, error);
+#else
   int val;
 
   _DBUS_ASSERT_ERROR_IS_CLEAR (error);
@@ -2849,6 +3135,7 @@
     }
 
   return TRUE;
+#endif
 }
 
 #if !defined (DBUS_DISABLE_ASSERT) || defined(DBUS_BUILD_TESTS)
@@ -2896,8 +3183,8 @@
 _dbus_parse_uid (const DBusString      *uid_str,
                  dbus_uid_t            *uid)
 {
+  dbus_uid_t val;
   int end;
-  long val;
   
   if (_dbus_string_get_length (uid_str) == 0)
     {
@@ -2907,8 +3194,7 @@
 
   val = -1;
   end = 0;
-  if (!_dbus_string_parse_int (uid_str, 0, &val,
-                               &end))
+  if (!_dbus_string_parse_int (uid_str, 0, &val, &end))
     {
       _dbus_verbose ("could not parse string as a UID\n");
       return FALSE;
@@ -2978,6 +3264,9 @@
                  *fd1, *fd2);
   
   return TRUE;  
+
+#elif defined (DBUS_WIN)
+  return _dbus_full_duplex_pipe_win (fd1, fd2, blocking, error);
 #else
   _dbus_warn ("_dbus_full_duplex_pipe() not implemented on this OS\n");
   dbus_set_error (error, DBUS_ERROR_FAILED,
@@ -2986,7 +3275,7 @@
 #endif
 }
 
-
+#ifndef DBUS_WIN
 /**
  * Measure the length of the given format string and arguments,
  * not including the terminating nul.
@@ -3002,6 +3291,7 @@
   char c;
   return vsnprintf (&c, 1, format, args);
 }
+#endif
 
 /**
  * Gets the temporary files directory by inspecting the environment variables 
Index: dbus/dbus-sysdeps.h
===================================================================
--- dbus/dbus-sysdeps.h	(Revision 206)
+++ dbus/dbus-sysdeps.h	(Arbeitskopie)
@@ -101,6 +101,22 @@
 #define DBUS_UID_FORMAT "%lu"
 #define DBUS_GID_FORMAT "%lu"
 
+#ifdef DBUS_WIN
+int _dbus_encapsulate_socket    (int socket);
+int _dbus_re_encapsulate_socket (int socket);
+int _dbus_encapsulate_fd        (int fd);
+int _dbus_re_encapsulate_fd     (int fd);
+int _dbus_decapsulate           (int fd);
+#else
+#define _dbus_encapsulate_socket(socket)    (socket)
+#define _dbus_re_encapsulate_socket(socket) (socket)
+#define _dbus_encapsulate_fd(fd)            (fd)
+#define _dbus_re_encapsulate_fd(fd)         (fd)
+#define _dbus_decapsulate(fd)               (fd)
+#endif
+                                                                                                                               
+                                                                                                                                    
+
 /**
  * Struct representing socket credentials
  */
Index: dbus/dbus-string-util.c
===================================================================
--- dbus/dbus-string-util.c	(Revision 206)
+++ dbus/dbus-string-util.c	(Arbeitskopie)
@@ -739,7 +739,27 @@
   test_roundtrips (test_hex_roundtrip);
   
   _dbus_string_free (&str);
-  
+
+  {
+  int found,found_len;
+  _dbus_string_init_const (&str, "012\r\n567\n90");
+
+  if (!_dbus_string_find_eol(&str, 0, &found, &found_len) || found != 3 || found_len != 2)
+    _dbus_assert_not_reached ("Did not find '\\r\\n'");
+  if (found != 3 || found_len != 2)
+    _dbus_assert_not_reached ("invalid return values");
+
+  if (!_dbus_string_find_eol(&str, 5, &found, &found_len))
+    _dbus_assert_not_reached ("Did not find '\\n'");
+  if (found != 8 || found_len != 1)
+    _dbus_assert_not_reached ("invalid return values");
+  	
+  if (_dbus_string_find_eol(&str, 9, NULL, NULL))
+    _dbus_assert_not_reached ("Found not expected '\\n'");
+
+  _dbus_string_free (&str);
+  }
+
   return TRUE;
 }
 
Index: tools/dbus-monitor.c
===================================================================
--- tools/dbus-monitor.c	(Revision 206)
+++ tools/dbus-monitor.c	(Arbeitskopie)
@@ -19,6 +19,7 @@
  *
  */
 
+#include <config.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
Index: tools/dbus-send.c
===================================================================
--- tools/dbus-send.c	(Revision 206)
+++ tools/dbus-send.c	(Arbeitskopie)
@@ -19,6 +19,7 @@
  *
  */
 
+#include <config.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
